<!doctype html>
<html >
<head>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->

    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->


    <!-- <script src="script.js"></script> -->

    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
    <link href="./elegant_bootstrap.css" rel="stylesheet" type="text/css" />
    <!-- <link href="https://cdn.rawgit.com/ryangrose/easy-pandoc-templates/948e28e5/css/elegant_bootstrap.css" rel="stylesheet" type="text/css" /> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script src="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/script.js"></script>

    <script src="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <meta name="author" content="Gabriel Parmer" />
  <meta name="author" content="Sibin Mohan" />
  <title>GWU CSCi 2410: Systems Programming</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>


    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">GWU CSCi 2410: Systems Programming</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">Gabriel Parmer</p></li>
                    <li><p class="navbar-text">Sibin Mohan</p></li>
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#intro-to-systems-programming"><span class="toc-section-number">1</span> Intro to Systems Programming</a><ul>
        <li><a href="#computer-organization"><span class="toc-section-number">1.1</span> Computer Organization</a></li>
        </ul></li>
        <li><a href="#memory"><span class="toc-section-number">2</span> Memory</a><ul>
        <li><a href="#computer-memory"><span class="toc-section-number">2.1</span> Computer memory</a><ul>
        <li><a href="#registers"><span class="toc-section-number">2.1.1</span> Registers</a></li>
        <li><a href="#important-question-how-much-memory-is-necessary"><span class="toc-section-number">2.1.2</span> Important question: <strong>how much memory</strong> is necessary?</a></li>
        <li><a href="#why-do-we-need-memory"><span class="toc-section-number">2.1.3</span> <strong>Why</strong> do we need memory?</a></li>
        </ul></li>
        <li><a href="#memory-layout"><span class="toc-section-number">2.2</span> memory layout</a><ul>
        <li><a href="#caches"><span class="toc-section-number">2.2.1</span> Caches</a></li>
        <li><a href="#main-memory"><span class="toc-section-number">2.2.2</span> Main Memory</a></li>
        <li><a href="#enter-virtual-memory"><span class="toc-section-number">2.2.3</span> Enter <strong>Virtual Memory</strong>!</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#intro-to-c"><span class="toc-section-number">3</span> Intro to C</a><ul>
        <li><a href="#c-constructs-if-youre-familiar-with-java-python-etc."><span class="toc-section-number">3.0.1</span> C constructs [if you’re familiar with Java, Python, etc.]</a></li>
        <li><a href="#compound-types"><span class="toc-section-number">3.0.2</span> Compound types</a></li>
        <li><a href="#unix-manual-man-pages"><span class="toc-section-number">3.0.3</span> Unix Manual (<code>man</code>) pages</a></li>
        <li><a href="#header-files"><span class="toc-section-number">3.0.4</span> Header Files</a></li>
        <li><a href="#some-common-c-libraries"><span class="toc-section-number">3.0.5</span> Some Common C libraries</a></li>
        <li><a href="#basic-types"><span class="toc-section-number">3.0.6</span> Basic Types</a></li>
        <li><a href="#code-samples">Code Samples</a></li>
        <li><a href="#compound-types-struct-enum-unions"><span class="toc-section-number">3.0.7</span> Compound types | <code>struct</code>, <code>enum</code>, <code>unions</code></a></li>
        <li><a href="#code-samples-1">Code Samples</a></li>
        <li><a href="#so-what-is-a-union">So what is a <code>union</code>?</a></li>
        <li><a href="#code-samples-2">Code Samples</a></li>
        </ul></li>
        <li><a href="#intermediate-c"><span class="toc-section-number">4</span> Intermediate C</a><ul>
        <li><a href="#objectives"><span class="toc-section-number">4.1</span> Objectives</a></li>
        <li><a href="#types"><span class="toc-section-number">4.2</span> Types</a><ul>
        <li><a href="#basic-types-1"><span class="toc-section-number">4.2.1</span> <span>Basic types</span></a></li>
        <li><a href="#common-posix-types-and-values"><span class="toc-section-number">4.2.2</span> Common POSIX types and values</a></li>
        <li><a href="#format-strings"><span class="toc-section-number">4.2.3</span> Format Strings</a></li>
        <li><a href="#compound-types-1"><span class="toc-section-number">4.2.4</span> Compound types</a></li>
        <li><a href="#pointers-arrays"><span class="toc-section-number">4.2.5</span> Pointers &amp; Arrays</a></li>
        </ul></li>
        <li><a href="#memory-allocation"><span class="toc-section-number">4.3</span> Memory Allocation</a><ul>
        <li><a href="#common-errors"><span class="toc-section-number">4.3.1</span> Common Errors</a></li>
        </ul></li>
        <li><a href="#exercises"><span class="toc-section-number">4.4</span> Exercises</a><ul>
        <li><a href="#c-is-a-thin-language-layer-on-top-of-memory"><span class="toc-section-number">4.4.1</span> C is a Thin Language Layer on Top of Memory</a></li>
        <li><a href="#quick-and-dirty-key-value-store"><span class="toc-section-number">4.4.2</span> Quick-and-dirty Key-Value Store</a></li>
        </ul></li>
        <li><a href="#pointers-and-arrays"><span class="toc-section-number">4.5</span> Pointers and Arrays</a></li>
        <li><a href="#pointer-arithmetic"><span class="toc-section-number">4.6</span> Pointer Arithmetic</a></li>
        <li><a href="#pointer-casting"><span class="toc-section-number">4.7</span> Pointer Casting!</a><ul>
        <li><a href="#casting-from-int-to-char"><span class="toc-section-number">4.7.1</span> Casting from <code>int*</code> to <code>char*</code></a></li>
        <li><a href="#example-3"><span class="toc-section-number">4.7.2</span> Example</a></li>
        </ul></li>
        <li><a href="#pointer-casting-void"><span class="toc-section-number">4.8</span> Pointer Casting | <code>void*</code></a></li>
        </ul></li>
        <li><a href="#function-pointers"><span class="toc-section-number">5</span> Function Pointers</a><ul>
        <li><a href="#example-bubble-sort"><span class="toc-section-number">5.0.1</span> Example | Bubble Sort</a></li>
        <li><a href="#example-generic-bubble-sort"><span class="toc-section-number">5.0.2</span> Example | Generic Bubble Sort</a></li>
        <li><a href="#what-is-generic"><span class="toc-section-number">5.0.3</span> What is “<em>generic</em>”?</a></li>
        <li><a href="#generic-to-concrete-functions"><span class="toc-section-number">5.0.4</span> Generic to <em>concrete</em> functions</a></li>
        <li><a href="#putting-it-all-together-using-function-pointers"><span class="toc-section-number">5.0.5</span> Putting it all Together | Using Function Pointers</a></li>
        <li><a href="#why-bother-if-we-need-concrete-functions-anyways"><span class="toc-section-number">5.0.6</span> Why bother if we need <code>concrete</code> functions anyways?</a></li>
        <li><a href="#in-class-exercise-generic-insertion-sort-for-struct"><span class="toc-section-number">5.0.7</span> In-class Exercise | Generic Insertion Sort for <code>struct</code></a></li>
        </ul></li>
        <li><a href="#c-memory-model-data-structures-and-apis"><span class="toc-section-number">6</span> C Memory Model, Data-structures, and APIs</a><ul>
        <li><a href="#memory-allocation-options"><span class="toc-section-number">6.1</span> Memory Allocation Options</a><ul>
        <li><a href="#internal-allocation"><span class="toc-section-number">6.1.1</span> Internal Allocation</a></li>
        <li><a href="#heap-allocation"><span class="toc-section-number">6.1.2</span> Heap Allocation</a></li>
        <li><a href="#global-allocation"><span class="toc-section-number">6.1.3</span> Global Allocation</a></li>
        <li><a href="#stack-allocation"><span class="toc-section-number">6.1.4</span> Stack Allocation</a></li>
        <li><a href="#putting-it-all-together"><span class="toc-section-number">6.1.5</span> Putting it all Together</a></li>
        <li><a href="#comparing-c-to-java"><span class="toc-section-number">6.1.6</span> Comparing C to Java</a></li>
        </ul></li>
        <li><a href="#strings"><span class="toc-section-number">6.2</span> Strings</a><ul>
        <li><a href="#string.h-functions"><span class="toc-section-number">6.2.1</span> <code>string.h</code> Functions</a></li>
        <li><a href="#bonus-explicit-strings"><span class="toc-section-number">6.2.2</span> Bonus: Explicit Strings</a></li>
        </ul></li>
        <li><a href="#api-design-and-concerns"><span class="toc-section-number">6.3</span> API Design and Concerns</a><ul>
        <li><a href="#return-values"><span class="toc-section-number">6.3.1</span> Return Values</a></li>
        <li><a href="#memory-ownership"><span class="toc-section-number">6.3.2</span> Memory Ownership</a></li>
        </ul></li>
        <li><a href="#exercises-1"><span class="toc-section-number">6.4</span> Exercises</a><ul>
        <li><a href="#stack-allocation-1"><span class="toc-section-number">6.4.1</span> Stack Allocation</a></li>
        <li><a href="#understanding-memory-ownership"><span class="toc-section-number">6.4.2</span> Understanding Memory Ownership</a></li>
        </ul></li>
        <li><a href="#errors"><span class="toc-section-number">6.5</span> Errors</a><ul>
        <li><a href="#return-vals-indicate-errors"><span class="toc-section-number">6.5.1</span> <strong>return</strong> vals → indicate errors</a></li>
        <li><a href="#errno-variable-and-command"><span class="toc-section-number">6.5.2</span> <code>errno</code> variable and command</a></li>
        <li><a href="#additional-helper-functions"><span class="toc-section-number">6.5.3</span> Additional Helper Functions</a></li>
        <li><a href="#understand-return-values-of-unix-library-functions"><span class="toc-section-number">6.5.4</span> Understand Return Values of UNIX library functions:</a></li>
        <li><a href="#in-class-exercise-printing-all-error-codesstrings-in-sequence"><span class="toc-section-number">6.5.5</span> In-class Exercise | Printing <strong>all</strong> error codes/strings in sequence</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#processes"><span class="toc-section-number">7</span> Processes</a><ul>
        <li><a href="#history-unix-posix-and-linux"><span class="toc-section-number">7.1</span> History: UNIX, POSIX, and Linux</a><ul>
        <li><a href="#tackling-complexity"><span class="toc-section-number">7.1.1</span> tackling complexity</a></li>
        </ul></li>
        <li><a href="#process"><span class="toc-section-number">7.2</span> process</a></li>
        <li><a href="#fork"><span class="toc-section-number">7.3</span> <code>fork()</code></a><ul>
        <li><a href="#after-fork"><span class="toc-section-number">7.3.1</span> after <code>fork()</code></a></li>
        <li><a href="#process-creationterminationcoordination-api"><span class="toc-section-number">7.3.2</span> process creation/termination/coordination API</a></li>
        <li><a href="#pdt_t"><span class="toc-section-number">7.3.3</span> <code>pdt_t</code></a></li>
        <li><a href="#lets-revisit-fork"><span class="toc-section-number">7.3.4</span> let’s revisit <code>fork()</code></a></li>
        <li><a href="#fork-return-values"><span class="toc-section-number">7.3.5</span> <code>fork()</code> return values</a></li>
        <li><a href="#fork-questions"><span class="toc-section-number">7.3.6</span> <code>fork</code> Questions</a></li>
        </ul></li>
        <li><a href="#wait"><span class="toc-section-number">7.4</span> <code>wait()</code></a><ul>
        <li><a href="#process-vs-thread"><span class="toc-section-number">7.4.1</span> process vs thread</a></li>
        </ul></li>
        <li><a href="#exit"><span class="toc-section-number">7.5</span> <code>exit()</code></a><ul>
        <li><a href="#interpreting-exit-status"><span class="toc-section-number">7.5.1</span> Interpreting <code>exit()</code> status</a></li>
        <li><a href="#relationship-between-wait-and-exit"><span class="toc-section-number">7.5.2</span> Relationship between <code>wait()</code> and <code>exit()</code></a></li>
        <li><a href="#life-after-exit"><span class="toc-section-number">7.5.3</span> life after <code>exit()</code>?</a></li>
        </ul></li>
        <li><a href="#command-line-arguments"><span class="toc-section-number">7.6</span> Command Line Arguments</a></li>
        <li><a href="#environment-variables"><span class="toc-section-number">7.7</span> Environment Variables</a><ul>
        <li><a href="#environment-variable-apis"><span class="toc-section-number">7.7.1</span> Environment Variable APIs</a></li>
        <li><a href="#an-aside-creating-processes-with-posix_spawn"><span class="toc-section-number">7.7.2</span> An Aside: Creating Processes with <code>posix_spawn</code></a></li>
        </ul></li>
        <li><a href="#representations-of-processes"><span class="toc-section-number">7.8</span> Representations of Processes</a></li>
        <li><a href="#process-exercises"><span class="toc-section-number">7.9</span> Process Exercises</a><ul>
        <li><a href="#exercise-1-fibonacci-with-fork"><span class="toc-section-number">7.9.1</span> Exercise 1: fibonacci with <code>fork</code></a></li>
        <li><a href="#exercise-2-shell-support-for-environment-variables"><span class="toc-section-number">7.9.2</span> Exercise 2: Shell Support for Environment Variables</a></li>
        <li><a href="#exercise-3-process-detective"><span class="toc-section-number">7.9.3</span> Exercise 3: Process Detective</a></li>
        </ul></li>
        <li><a href="#executing-other-processes"><span class="toc-section-number">7.10</span> Executing Other Processes</a><ul>
        <li><a href="#sequence-of-operations"><span class="toc-section-number">7.10.1</span> Sequence of operations</a></li>
        </ul></li>
        <li><a href="#exec_-family"><span class="toc-section-number">7.11</span> <code>exec_()</code> family</a><ul>
        <li><a href="#execve"><span class="toc-section-number">7.11.1</span> <code>execve()</code></a></li>
        <li><a href="#fork-and-exec"><span class="toc-section-number">7.11.2</span> <code>fork()</code> and <code>exec()</code></a></li>
        <li><a href="#launch-any-child-processes"><span class="toc-section-number">7.11.3</span> Launch <strong>Any</strong> Child Processes</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#process-descriptors"><span class="toc-section-number">8</span> Process Descriptors</a><ul>
        <li><a href="#key-mechanisms"><span class="toc-section-number">8.0.1</span> Key Mechanisms</a></li>
        <li><a href="#current-working-directory"><span class="toc-section-number">8.0.2</span> current working directory</a></li>
        <li><a href="#process-descriptors-1"><span class="toc-section-number">8.0.3</span> Process Descriptors</a></li>
        <li><a href="#file-descriptor-operations"><span class="toc-section-number">8.0.4</span> File Descriptor Operations</a></li>
        <li><a href="#pipes"><span class="toc-section-number">8.1</span> Pipes</a><ul>
        <li><a href="#unix-pipes"><span class="toc-section-number">8.1.1</span> unix ‘pipes’</a></li>
        <li><a href="#pipes-api"><span class="toc-section-number">8.1.2</span> pipes api</a></li>
        <li><a href="#the-shell"><span class="toc-section-number">8.1.3</span> The Shell</a></li>
        </ul></li>
        <li><a href="#signals"><span class="toc-section-number">8.2</span> Signals</a><ul>
        <li><a href="#enter-signals"><span class="toc-section-number">8.2.1</span> Enter ‘<strong>signals</strong>’</a></li>
        <li><a href="#signals-interface"><span class="toc-section-number">8.2.2</span> Signals Interface</a></li>
        <li><a href="#notable-signals"><span class="toc-section-number">8.2.3</span> Notable Signals</a></li>
        <li><a href="#minor-detour-sa_sigaction"><span class="toc-section-number">8.2.4</span> Minor Detour | <code>sa_sigaction</code></a></li>
        <li><a href="#signals-further-examples"><span class="toc-section-number">8.2.5</span> Signals | Further Examples</a></li>
        <li><a href="#the-dark-side-of-signals"><span class="toc-section-number">8.2.6</span> The Dark Side of Signals</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#files-and-file-handling"><span class="toc-section-number">9</span> Files and File Handling</a><ul>
        <li><a href="#basic-file-access"><span class="toc-section-number">9.1</span> Basic File Access</a></li>
        <li><a href="#moving-around-in-files"><span class="toc-section-number">9.2</span> Moving Around in Files</a></li>
        <li><a href="#other-ways-to-access-files"><span class="toc-section-number">9.3</span> Other Ways to Access Files</a><ul>
        <li><a href="#memory-mapping-files-mmap"><span class="toc-section-number">9.3.1</span> Memory Mapping Files | <code>mmap()</code></a></li>
        <li><a href="#stream-based-io"><span class="toc-section-number">9.3.2</span> Stream-Based I/O</a></li>
        </ul></li>
        <li><a href="#accessing-directories"><span class="toc-section-number">9.4</span> Accessing Directories</a></li>
        <li><a href="#exercises-2"><span class="toc-section-number">9.5</span> Exercises</a><ul>
        <li><a href="#task-1-markdown-tree"><span class="toc-section-number">9.5.1</span> Task 1: Markdown Tree</a></li>
        <li><a href="#task-2-file-and-directory-sizes"><span class="toc-section-number">9.5.2</span> Task 2: File and Directory Sizes</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#io-inter-process-communication"><span class="toc-section-number">10</span> I/O: Inter-Process Communication</a><ul>
        <li><a href="#ipc-example-modern-browsers"><span class="toc-section-number">10.1</span> IPC Example: Modern Browsers</a></li>
        <li><a href="#goals-of-ipc-mechanisms"><span class="toc-section-number">10.2</span> Goals of IPC Mechanisms</a></li>
        <li><a href="#files-shared-memory"><span class="toc-section-number">10.3</span> Files &amp; Shared Memory</a></li>
        <li><a href="#named-pipes"><span class="toc-section-number">10.4</span> Named Pipes</a><ul>
        <li><a href="#challenges-with-named-pipes-for-multi-client-communication"><span class="toc-section-number">10.4.1</span> Challenges with Named Pipes for Multi-Client Communication</a></li>
        </ul></li>
        <li><a href="#unix-domain-sockets"><span class="toc-section-number">10.5</span> UNIX Domain Sockets</a><ul>
        <li><a href="#domain-sockets-for-multi-client-communication"><span class="toc-section-number">10.5.1</span> Domain sockets for Multi-Client Communication</a></li>
        </ul></li>
        <li><a href="#ipc-exercises"><span class="toc-section-number">10.6</span> IPC Exercises</a></li>
        </ul></li>
        <li><a href="#reinforcing-ideas-assorted-exercises-and-event-notification"><span class="toc-section-number">11</span> Reinforcing Ideas: Assorted Exercises and Event Notification</a><ul>
        <li><a href="#fork-and-stream-behavior"><span class="toc-section-number">11.0.1</span> <code>fork</code> and Stream Behavior</a></li>
        <li><a href="#wait-behavior"><span class="toc-section-number">11.0.2</span> Wait Behavior</a></li>
        <li><a href="#read-behavior"><span class="toc-section-number">11.0.3</span> <code>read</code> Behavior</a></li>
        <li><a href="#signals-1"><span class="toc-section-number">11.0.4</span> Signals</a></li>
        <li><a href="#communication-with-multiple-clients"><span class="toc-section-number">11.0.5</span> Communication with Multiple Clients</a></li>
        <li><a href="#revisiting-ipc-with-multiple-clients"><span class="toc-section-number">11.1</span> Revisiting IPC with Multiple Clients</a><ul>
        <li><a href="#system-services"><span class="toc-section-number">11.1.1</span> System Services</a></li>
        <li><a href="#understanding-descriptor-events-with-poll"><span class="toc-section-number">11.1.2</span> Understanding Descriptor Events with <code>poll</code></a></li>
        <li><a href="#event-loops-and-poll"><span class="toc-section-number">11.1.3</span> Event Loops and <code>poll</code></a></li>
        <li><a href="#poll-api"><span class="toc-section-number">11.1.4</span> <code>poll</code> API</a></li>
        <li><a href="#example-poll-code"><span class="toc-section-number">11.1.5</span> Example <code>poll</code> Code</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#libraries"><span class="toc-section-number">12</span> Libraries</a><ul>
        <li><a href="#libraries---goals-and-overview"><span class="toc-section-number">12.1</span> Libraries - Goals and Overview</a></li>
        <li><a href="#libraries---header-files"><span class="toc-section-number">12.2</span> Libraries - Header Files</a></li>
        <li><a href="#linking-undefined-symbols-to-references-across-objects"><span class="toc-section-number">12.3</span> Linking Undefined Symbols to References Across Objects</a><ul>
        <li><a href="#elf-object-format"><span class="toc-section-number">12.3.1</span> ELF Object Format</a></li>
        <li><a href="#linking-summary"><span class="toc-section-number">12.3.2</span> Linking Summary</a></li>
        </ul></li>
        <li><a href="#static-libraries"><span class="toc-section-number">12.4</span> Static Libraries</a><ul>
        <li><a href="#saving-memory-with-static-libraries"><span class="toc-section-number">12.4.1</span> Saving Memory with Static Libraries</a></li>
        </ul></li>
        <li><a href="#shareddynamic-libraries"><span class="toc-section-number">12.5</span> Shared/Dynamic Libraries</a><ul>
        <li><a href="#compiling-and-executing-with-dynamic-libraries"><span class="toc-section-number">12.5.1</span> Compiling and Executing with Dynamic Libraries</a></li>
        <li><a href="#exec-with-dynamic-linking"><span class="toc-section-number">12.5.2</span> <code>exec</code> with Dynamic Linking</a></li>
        <li><a href="#diving-into-dynamic-linking-at-exec"><span class="toc-section-number">12.5.3</span> Diving into Dynamic Linking at <code>exec</code></a></li>
        <li><a href="#dynamic-loading-summary"><span class="toc-section-number">12.5.4</span> Dynamic Loading Summary</a></li>
        <li><a href="#saving-memory-with-dynamic-libraries"><span class="toc-section-number">12.5.5</span> Saving Memory with Dynamic Libraries</a></li>
        </ul></li>
        <li><a href="#static-vs.-dynamic-library-memory-usage-summary"><span class="toc-section-number">12.6</span> Static vs. Dynamic Library Memory Usage Summary</a></li>
        </ul></li>
        <li><a href="#organizing-software-with-dynamic-libraries-exercises-and-programming"><span class="toc-section-number">13</span> Organizing Software with Dynamic Libraries: Exercises and Programming</a><ul>
        <li><a href="#exercise-understanding-library-memory-consumption"><span class="toc-section-number">13.1</span> Exercise: Understanding Library Memory Consumption</a></li>
        <li><a href="#library-trade-offs"><span class="toc-section-number">13.2</span> Library Trade-offs</a></li>
        <li><a href="#programming-dynamic-libraries"><span class="toc-section-number">13.3</span> Programming Dynamic Libraries</a><ul>
        <li><a href="#plugins-and-dynamic-library-apis"><span class="toc-section-number">13.3.1</span> Plugins and Dynamic Library APIs</a></li>
        <li><a href="#interposing-libraries-on-library-apis"><span class="toc-section-number">13.3.2</span> Interposing Libraries on Library APIs</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#system-calls-and-memory-management"><span class="toc-section-number">14</span> System Calls and Memory Management</a><ul>
        <li><a href="#system-calls"><span class="toc-section-number">14.1</span> System Calls</a><ul>
        <li><a href="#system-calls-and-processes"><span class="toc-section-number">14.1.1</span> System Calls and Processes</a></li>
        </ul></li>
        <li><a href="#observing-system-calls"><span class="toc-section-number">14.2</span> Observing System Calls</a></li>
        <li><a href="#system-call-overhead"><span class="toc-section-number">14.3</span> System Call Overhead</a></li>
        <li><a href="#library-vs.-kernel-trade-offs-in-memory-allocation"><span class="toc-section-number">14.4</span> Library vs. Kernel Trade-offs in Memory Allocation</a><ul>
        <li><a href="#library-tracking-of-memory"><span class="toc-section-number">14.4.1</span> Library Tracking of Memory</a></li>
        <li><a href="#malloc-data-structures"><span class="toc-section-number">14.4.2</span> Malloc Data-structures</a></li>
        <li><a href="#exercise-smalloc"><span class="toc-section-number">14.4.3</span> Exercise: <code>smalloc</code></a></li>
        </ul></li>
        </ul></li>
        <li><a href="#unix-security-users-groups-and-filesystem-permissions"><span class="toc-section-number">15</span> UNIX Security: Users, Groups, and Filesystem Permissions</a><ul>
        <li><a href="#file-and-directory-permissions"><span class="toc-section-number">15.1</span> File and Directory Permissions</a><ul>
        <li><a href="#file-ownership-and-groups"><span class="toc-section-number">15.1.1</span> File Ownership and Groups</a></li>
        <li><a href="#file-permissions"><span class="toc-section-number">15.1.2</span> File Permissions</a></li>
        <li><a href="#numerical-representation-of-permissions"><span class="toc-section-number">15.1.3</span> Numerical Representation of Permissions</a></li>
        <li><a href="#updating-filedirectory-permissions"><span class="toc-section-number">15.1.4</span> Updating File/Directory Permissions</a></li>
        <li><a href="#changing-filedirectory-owner-and-group"><span class="toc-section-number">15.1.5</span> Changing File/Directory Owner and Group</a></li>
        </ul></li>
        <li><a href="#security-and-programming-with-users-and-groups"><span class="toc-section-number">15.2</span> Security and Programming with Users and Groups</a><ul>
        <li><a href="#user-and-group-strings"><span class="toc-section-number">15.2.1</span> User and Group Strings</a></li>
        </ul></li>
        <li><a href="#application-specific-privileges-using-set-user-idset-group-id"><span class="toc-section-number">15.3</span> Application-Specific Privileges using set-user-id/set-group-id</a></li>
        <li><a href="#applications-of-identify-and-permission-management"><span class="toc-section-number">15.4</span> Applications of Identify and Permission Management</a><ul>
        <li><a href="#logging-events-selectively-increasing-access-rights"><span class="toc-section-number">15.4.1</span> Logging Events: Selectively Increasing Access Rights</a></li>
        <li><a href="#logging-in-carefully-decreasing-access-rights"><span class="toc-section-number">15.4.2</span> Logging In: Carefully Decreasing Access Rights</a></li>
        <li><a href="#sudo-and-su-increasing-access-rights"><span class="toc-section-number">15.4.3</span> <code>sudo</code> and <code>su</code>: Increasing Access Rights</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#security-attacks-on-system-programs"><span class="toc-section-number">16</span> Security: Attacks on System Programs</a><ul>
        <li><a href="#path-attacks"><span class="toc-section-number">16.1</span> Path Attacks</a><ul>
        <li><a href="#system"><span class="toc-section-number">16.1.1</span> <code>system()</code></a></li>
        <li><a href="#path-attacks-with-set-user-id-bits-for-privilege-escalation"><span class="toc-section-number">16.1.2</span> Path Attacks with Set-user-id Bits for Privilege Escalation</a></li>
        <li><a href="#ld_preload-attacks"><span class="toc-section-number">16.1.3</span> <code>LD_PRELOAD</code> Attacks?</a></li>
        </ul></li>
        <li><a href="#injection-attacks"><span class="toc-section-number">16.2</span> Injection Attacks</a></li>
        <li><a href="#overflow-attacks"><span class="toc-section-number">16.3</span> Overflow Attacks</a></li>
        </ul></li>
        <li><a href="#the-android-unix-personality"><span class="toc-section-number">17</span> The Android UNIX Personality</a></li>
        <li><a href="#unix-containers"><span class="toc-section-number">18</span> UNIX Containers</a></li>
        <li><a href="#appendix-c-programming-conventions"><span class="toc-section-number">19</span> Appendix: C Programming Conventions</a><ul>
        <li><a href="#naming-conventions"><span class="toc-section-number">19.1</span> Naming Conventions</a></li>
        <li><a href="#namespacing"><span class="toc-section-number">19.2</span> Namespacing</a></li>
        <li><a href="#headers-and-visibility"><span class="toc-section-number">19.3</span> Headers and Visibility</a></li>
        <li><a href="#what-to-include"><span class="toc-section-number">19.4</span> What to Include?</a></li>
        <li><a href="#depth-complexity"><span class="toc-section-number">19.5</span> Depth = Complexity</a></li>
        <li><a href="#object-orientation-initialization-destruction-and-methods"><span class="toc-section-number">19.6</span> Object Orientation: Initialization, Destruction, and Methods</a></li>
        </ul></li>
        </ul>

        </div>
      </div>
            <div class="span9">
            <h1 id="intro-to-systems-programming"><span class="header-section-number">1</span> Intro to Systems Programming</h1>
<h2 id="computer-organization"><span class="header-section-number">1.1</span> Computer Organization</h2>
<p>Find the <a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2024/slides/reveal_slides/comparch.html">slides</a>.</p>
<!--## Memory Hierarchies

Find the [slides](https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/memory.html#/10).-->
<h1 id="memory"><span class="header-section-number">2</span> Memory</h1>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2024/slides/reveal_slides/memory.html#/">Slides</a></p>
<p><img src="figures/memory_brain.jpg" height="300"></p>
<h2 id="computer-memory"><span class="header-section-number">2.1</span> Computer memory</h2>
<p>different shapes, sizes and <strong>speeds</strong></p>
<ul>
<li>registers</li>
<li>caches (L1, L2, L3)</li>
<li>main memory/RAM</li>
<li>disk (hard disks, flash)</li>
</ul>
<h3 id="registers"><span class="header-section-number">2.1.1</span> Registers</h3>
<ul>
<li><strong>fastest</strong> form of memory</li>
<li>this what the processor uses</li>
<li>e.g., <code>a = 3 + 4 ;</code></li>
<li><code>3</code> and <code>4</code> → loaded into registers</li>
</ul>
<h4 id="register-width-defines-width-of-cpu"><span class="header-section-number">2.1.1.1</span> register “width” | defines “width” of cpu</h4>
<ul>
<li>“32 bit processor” → 32-bit registers</li>
<li>“64 bit processor” → 64-bit registers</li>
</ul>
<h4 id="all-known-x86-registers"><span class="header-section-number">2.1.1.2</span> All (known) x86 registers</h4>
<p>for the <strong>64-bit</strong> architecture [source: <a href="https://en.wikipedia.org/wiki/X86#x86_registers">wikipedia</a>]</p>
<p><img src="figures/x86_64_registers.png" height="300"> <br></p>
<h3 id="important-question-how-much-memory-is-necessary"><span class="header-section-number">2.1.2</span> Important question: <strong>how much memory</strong> is necessary?</h3>
<p>But before we answer that, we need to answer this question: <strong>why</strong> do we need memory?</p>
<h3 id="why-do-we-need-memory"><span class="header-section-number">2.1.3</span> <strong>Why</strong> do we need memory?</h3>
<table>
<thead>
<tr class="header">
<th>component</th>
<th>(typical) sizes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>programs/code</td>
<td>kilobytes to megabytes</td>
</tr>
<tr class="even">
<td>temporary values</td>
<td>kilobytes to megabytes*</td>
</tr>
<tr class="odd">
<td>data</td>
<td>kilobytes to <strong>tera</strong>bytes!</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>[*depends on the program]</p>
<h4 id="so-the-memory-hierarchy-looks-like-this"><span class="header-section-number">2.1.3.1</span> So, the <strong>memory hierarchy</strong> looks like this:</h4>
<p><img src="figures/mem_hierarchy.png" width="200"></p>
<p><br><br></p>
<p>But, if the registers are the fastest type of memory, then why do we need these layers?</p>
<p><img src="figures/mem_hierarchy-highlight_box.png" width="200"></p>
<p><br><br> <strong>Because, registers are expensive</strong>!</p>
<p>The classic tradeoff: <strong>speed vs size</strong>! The faster the memory → more <strong>expensive</strong>!</p>
<h2 id="memory-layout"><span class="header-section-number">2.2</span> memory layout</h2>
<p><img src="figures/cpu_memory_structure-bus_ram.png" width="200"></p>
<h3 id="caches"><span class="header-section-number">2.2.1</span> Caches</h3>
<ul>
<li>fast, on-chip memory</li>
<li><strong>transparent</strong> to program</li>
<li>used by cpu to improve performance</li>
</ul>
<h3 id="main-memory"><span class="header-section-number">2.2.2</span> Main Memory</h3>
<ul>
<li>random access memory [ram]</li>
<li>typical → <strong>giga</strong>bytes range</li>
<li><strong>limited by “width” of cpu/registers</strong></li>
<li>e.g. <scb>32 bit</scb> cpu → max <scb>4 gb</scb> memory!</li>
</ul>
<p><br> Wait, what’s with the “register width”, “memory”…</p>
<p><img src="figures/math_confused.gif" width="200"></p>
<p><br> <br></p>
<p><strong>Memory Addressing:</strong></p>
<p><img src="figures/register_addressing/register_addressing5.png" width="200"></p>
<p><br></p>
<p>But <em>what</em> goes into this memory?</p>
<p>The typical memory layout for a program/system looks like this:</p>
<p><img src="figures/memory_sw_components/memory_sw_components4.png" width="200"></p>
<p>But what happens when you have more than one program? Note that each program needs its own access to the OS services and also has to store/mainpulate its own data!</p>
<p>So, do we have something like this (for <em>two</em> programs)?</p>
<p><img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"></p>
<p>What if we have <em>more than two</em> programs?</p>
<p><img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"></p>
<p>This can get messy, really quick! Also, note that the system may not have enough memory to fit all of these programs and their data. We nave to deal with additional issues such as programs overwiting other programs’ data/memory!</p>
<h3 id="enter-virtual-memory"><span class="header-section-number">2.2.3</span> Enter <strong>Virtual Memory</strong>!</h3>
<p><img src="figures/mind-blown.gif" width="200"></p>
<ul>
<li>makes each program “<em>believe</em>”</li>
<li>it has the <strong>entire</strong> memory to itself!</li>
<li>combination of os+hardware</li>
</ul>
<p>So, instead of this…</p>
<p><img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components5.png" width="100"></p>
<p><br> we get…</p>
<p><img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components4.png" width="100"> <img src="figures/memory_sw_components/memory_sw_components4.png" width="100"></p>
<p><br> or, at least the programs “<em>think</em>” so!</p>
<p>Hence, <strong>programmers need </strong>not** worry about other programs!**</p>
<h1 id="intro-to-c"><span class="header-section-number">3</span> Intro to C</h1>
<details>
<p><summary>[Notes]</summary></p>
<blockquote>
<ul>
<li>Start by talking through slides</li>
</ul>
</blockquote>
</details>
<p><strong>You already know </strong>C<strong>!</strong></p>
<p>well, some of it anyways…</p>
<h3 id="c-constructs-if-youre-familiar-with-java-python-etc."><span class="header-section-number">3.0.1</span> C constructs [if you’re familiar with Java, Python, etc.]</h3>
<table>
<thead>
<tr class="header">
<th>construct</th>
<th>syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>conditionals</td>
<td><code>if</code> and <code>else</code></td>
</tr>
<tr class="even">
<td>loops</td>
<td><code>while{}</code>, <code>do...while</code>, <code>for</code></td>
</tr>
<tr class="odd">
<td><strong>basic</strong> types</td>
<td><code>int</code>, <code>float</code>, <code>double</code>, <code>char</code></td>
</tr>
<tr class="even">
<td><strong>compound</strong></td>
<td><code>arrays</code>*, <code>struct</code>, <code>union</code>, <code>enum</code></td>
</tr>
<tr class="odd">
<td>functions</td>
<td><code>ret_val</code> <strong><code>func_name</code></strong> <code>(args){}</code></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>* <strong>no range checks!!</strong></p>
<p>C will let you access an array beyond the maximum size that you have specified while creating it. The effects of such access are <strong>implementation specific</strong> – each platform/operating system will handle it differently. Note that on platforms that don’t have memory protection, this can cause some serious problems!</p>
<p><strong>What’s different [from Java]</strong></p>
<ul>
<li>no object-oriented programming</li>
<li>no function overloading</li>
<li><strong>no classes!</strong></li>
<li>we have <code>struct</code> instead
<ul>
<li>which is similar but <em>very</em> different</li>
</ul></li>
<li><strong>compiled</strong> not interpreted</li>
<li><strong>pointers!!!</strong></li>
</ul>
<h3 id="compound-types"><span class="header-section-number">3.0.2</span> Compound types</h3>
<p><strong>contiguous memory</strong> layouts: objects within these data types are laid out in memory, next to each other. This becomes important when you’re trying to use pointers to access various elements.</p>
<table>
<thead>
<tr class="header">
<th>type</th>
<th>usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>struct</code></td>
<td>related variables (like class)</td>
</tr>
<tr class="even">
<td><code>union</code></td>
<td>same, but <em>shared</em> memory</td>
</tr>
<tr class="odd">
<td><code>enum</code></td>
<td>enumeration, assign names</td>
</tr>
<tr class="even">
<td>array</td>
<td>pointer to contiguous memory</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>More details in following sections.</p>
<h4 id="no-built-in-boolean" class="unnumbered"><strong>no (built-in) boolean!</strong></h4>
<p>C does not have a built in boolean data type. We can mimic it by using integer values, <em>e.g.,</em></p>
<table>
<tbody>
<tr class="odd">
<td><code>0</code></td>
<td><code>false</code></td>
</tr>
<tr class="even">
<td><strong>any non-zero value</strong></td>
<td><code>true</code></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="unix-manual-man-pages"><span class="header-section-number">3.0.3</span> Unix Manual (<code>man</code>) pages</h3>
<ul>
<li>compilation of unix/C knowledge</li>
<li><code>man \&lt;topic\&gt;</code></li>
</ul>
<p>Organized into sections:</p>
<table>
<thead>
<tr class="header">
<th>#</th>
<th>contents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>general commands</td>
</tr>
<tr class="even">
<td><strong>2</strong></td>
<td><strong>system calls</strong></td>
</tr>
<tr class="odd">
<td><strong>3</strong></td>
<td><strong>library funtions (c)</strong></td>
</tr>
<tr class="even">
<td>4</td>
<td>special files</td>
</tr>
<tr class="odd">
<td>5</td>
<td>file formats and conventions</td>
</tr>
<tr class="even">
<td>6</td>
<td>games and screensavers</td>
</tr>
<tr class="odd">
<td>7</td>
<td>miscellaneous</td>
</tr>
<tr class="even">
<td>8</td>
<td>system administration</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>[the highlighted sections are most relevant to us.]</p>
<p>Consider the following example. If we want to see details about the common <code>C</code> standard library function, <code>printf()</code>, we type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1">man <span class="dv">3</span> printf</a></code></pre></div>
<p>The <em>initial</em> part of the output will look something like this (run the above command in a terminal for the full output):</p>
<p><img src="figures/man_printf_output.png" width="500"></p>
<details>
<p><summary>[Notes]</summary></p>
<blockquote>
<ul>
<li>show man 3 printf example</li>
<li>compare against just man printf</li>
</ul>
</blockquote>
</details>
<h3 id="header-files"><span class="header-section-number">3.0.4</span> Header Files</h3>
<ul>
<li>include libraries in your program</li>
<li>even the C standard library</li>
<li>similar to <code>import</code> in java</li>
</ul>
<table>
<thead>
<tr class="header">
<th>method</th>
<th>what is included</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\#include \&lt;stdio.h\&gt;</code></td>
<td>common libraries</td>
</tr>
<tr class="even">
<td><code>\#include \"my_header.h"</code></td>
<td>user header file</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Depending on how you invlude your header files, is determined by <em>where</em> they are located on your system:</p>
<table>
<thead>
<tr class="header">
<th>method</th>
<th><strong>location</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\#include \&lt;...\&gt;</code></td>
<td>header path, e.g., <br> <code>\/usr\/include\/</code>*</td>
</tr>
<tr class="even">
<td><code>\#include \"..."</code></td>
<td><strong>current</strong> directory</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>* <strong>not</strong> exhaustive</p>
<h3 id="some-common-c-libraries"><span class="header-section-number">3.0.5</span> Some Common C libraries</h3>
<table>
<thead>
<tr class="header">
<th>library</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>stdio.h</code></td>
<td>standard <strong>input/ouput</strong></td>
</tr>
<tr class="even">
<td><code>stdlib.h</code></td>
<td><strong>C</strong> standard library/utilities</td>
</tr>
<tr class="odd">
<td><code>unistd.h</code></td>
<td><strong>unix</strong> standard library</td>
</tr>
<tr class="even">
<td><code>sys/types.h</code></td>
<td><strong>system types</strong> library</td>
</tr>
<tr class="odd">
<td><code>string.h</code></td>
<td><strong>string</strong> manipulation</td>
</tr>
<tr class="even">
<td><code>math.h</code></td>
<td><strong>math</strong> utility functions</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basic-types"><span class="header-section-number">3.0.6</span> Basic Types</h3>
<p>These are the basic data types defined by the C language:</p>
<table>
<thead>
<tr class="header">
<th>type</th>
<th>description/size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char</code></td>
<td>smallest type, <strong>one</strong> byte</td>
</tr>
<tr class="even">
<td><code>short int</code></td>
<td><strong>two</strong> bytes</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td><strong>four</strong> bytes</td>
</tr>
<tr class="even">
<td><code>long int</code>/<code>long</code></td>
<td>larger <code>int</code>, <strong>four-eight</strong> bytes</td>
</tr>
<tr class="odd">
<td><code>float</code></td>
<td>floating point, <strong>four</strong> bytes*</td>
</tr>
<tr class="even">
<td><code>double</code></td>
<td>double precision, <strong>eight</strong> bytes*</td>
</tr>
<tr class="odd">
<td><code>void</code></td>
<td><strong>lack</strong> of a type</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Important Caveats!</strong></p>
<ul>
<li>when we say “one byte” → depends on <strong>platform</strong></li>
<li><code>char</code> is one byte, typically on <strong>intel</strong></li>
<li>varies based on,
<ul>
<li>architectures (ARM, IBM, INTEL)</li>
<li>32-bit vs 64-bit</li>
</ul></li>
<li>* Similarly, the size of the <code>float</code> and <code>double</code> data types are not defined by C. Different compilers (and platforms) implement them with different sizes.</li>
</ul>
<details>
<p><summary>[Notes]</summary></p>
<blockquote>
<ul>
<li>stop with slides here</li>
<li>switch to code examples</li>
</ul>
</blockquote>
</details>
<h3 id="code-samples" class="unnumbered">Code Samples</h3>
<p>Now, let’s look at some code!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb2-4" title="4">{</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb2-6" title="6">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<p>This is a basic <code>C</code> program. Some details to note:</p>
<ul>
<li><code>&lt;stdio.h&gt;</code> is the header file for the <strong>standard I/O library</strong> in C</li>
<li><strong>Every</strong> C program requires a <code>main()</code> function – this is where the execution starts and ends (for the most part – we will look at nuances later)</li>
<li>This function expects a return value as an <code>int</code>. Hence we return <code>0</code> at the end. This return value from main, is the value <em>returned by your program</em> when it completes execution.</li>
</ul>
<p>Note that this doesn’t have to be the signature of <code>main()</code> but it is <em>typical</em>. We will explore the “proper” signature for <code>main()</code> later on but let’s stick to this.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// this is a single line comment</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb4-6" title="6">{</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">char</span> c = <span class="ch">&#39;a&#39;</span> ;</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="dt">int</span> i ;</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="dt">float</span> f ;</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="dt">double</span> d ;</a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12">    i = <span class="dv">100</span> ;</a>
<a class="sourceLine" id="cb4-13" title="13">    f = <span class="fl">1.0</span> ;</a>
<a class="sourceLine" id="cb4-14" title="14">    d = <span class="fl">12398723897.2332</span> ;</a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16">    printf( <span class="st">&quot;Memory sizes of variables...</span><span class="sc">\n\n</span><span class="st"> \</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="st">            size of char: %lu \</span></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="st">            size of int: %lu \</span></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="st">            size of float: %lu \</span></a>
<a class="sourceLine" id="cb4-20" title="20"><span class="st">            size of double: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb4-21" title="21">            <span class="kw">sizeof</span>(c), <span class="kw">sizeof</span>(<span class="dt">int</span>), <span class="kw">sizeof</span>(f), <span class="kw">sizeof</span>(d) ) ;</a>
<a class="sourceLine" id="cb4-22" title="22"> </a>
<a class="sourceLine" id="cb4-23" title="23">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ; <span class="co">// adding an extra line for nice printing at the end</span></a>
<a class="sourceLine" id="cb4-24" title="24">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb4-25" title="25">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Memory sizes of variables...

             size of char: 1             size of int: 4             size of float: 4             size of double: 8
</code></pre>
<p><code>sizeof()</code> is a unary operator in the programming languages C and C++. It generates the storage size of an expression or a data type, measured in the number of char-sized units. Consequently, the construct sizeof (char) is guaranteed to be <strong>1</strong><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<blockquote>
<p>What happens when you try: <code>man sizeof</code>?</p>
</blockquote>
<h3 id="compound-types-struct-enum-unions"><span class="header-section-number">3.0.7</span> Compound types | <code>struct</code>, <code>enum</code>, <code>unions</code></h3>
<details>
<p><summary>[Notes]</summary></p>
<blockquote>
<ul>
<li>switch to slides for the compound types</li>
<li>switch back to code examples</li>
</ul>
</blockquote>
</details>
<p>The C standard defines multiple <strong>compound</strong> data types, <em>viz.</em>,</p>
<table>
<thead>
<tr class="header">
<th>type</th>
<th>description</th>
<th>size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>struct</code></td>
<td>collection of <strong>different</strong> values</td>
<td><strong>sum</strong> of all fields</td>
</tr>
<tr class="even">
<td><code>union</code></td>
<td><strong>one</strong> of a set of values</td>
<td>size of <strong>largest</strong> field</td>
</tr>
<tr class="odd">
<td><code>enum</code></td>
<td>an <strong>enumeration</strong> with “named” values</td>
<td>typically size of <code>int</code></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="code-samples-1" class="unnumbered">Code Samples</h3>
<p>Consider the following use case: we want to build a calendar. What information do we need? * date * month * year</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// this is a single line comment</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">struct</span> calendar{</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="dt">int</span> _date ;</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="dt">int</span> _month ;</a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="dt">int</span> _year ;</a>
<a class="sourceLine" id="cb6-9" title="9">} ;</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb6-12" title="12">{</a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="kw">struct</span> calendar today ; <span class="co">// creating an object of type &quot;calendar&quot;</span></a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15">    printf( <span class="st">&quot;size of struct calendar: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(today) ) ;</a>
<a class="sourceLine" id="cb6-16" title="16"></a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="co">// let&#39;s initialize the object, &quot;today&quot;</span></a>
<a class="sourceLine" id="cb6-18" title="18">    <span class="co">// remember, no &quot;constructors&quot;</span></a>
<a class="sourceLine" id="cb6-19" title="19">    today._month = <span class="dv">9</span> ;</a>
<a class="sourceLine" id="cb6-20" title="20">    today._date = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb6-21" title="21">    today._year = <span class="dv">2024</span> ;</a>
<a class="sourceLine" id="cb6-22" title="22"></a>
<a class="sourceLine" id="cb6-23" title="23">    printf( <span class="st">&quot;date: %d/%d/%d</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb6-24" title="24">            today._month, today._date, today._year ) ;</a>
<a class="sourceLine" id="cb6-25" title="25"></a>
<a class="sourceLine" id="cb6-26" title="26"> </a>
<a class="sourceLine" id="cb6-27" title="27">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ; <span class="co">// adding an extra line for nice printing at the end</span></a>
<a class="sourceLine" id="cb6-28" title="28">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb6-29" title="29">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>size of struct calendar: 12
date: 9/5/2024
</code></pre>
<p>Are we missing anything else? * what about the day of the week? * so let’s add a field in the struct for the day of the week</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// this is a single line comment</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">struct</span> calendar{</a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="dt">int</span> _date ;</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="dt">int</span> _month ;</a>
<a class="sourceLine" id="cb8-8" title="8">    <span class="dt">int</span> _year ;</a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="dt">int</span> _day_of_week ; <span class="co">// 1 -- sunday, 2 -- monday, etc.</span></a>
<a class="sourceLine" id="cb8-10" title="10">} ;</a>
<a class="sourceLine" id="cb8-11" title="11"></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb8-13" title="13">{</a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="kw">struct</span> calendar today ; <span class="co">// creating an object of type &quot;calendar&quot;</span></a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">    printf( <span class="st">&quot;size of struct calendar: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(today) ) ;</a>
<a class="sourceLine" id="cb8-17" title="17"></a>
<a class="sourceLine" id="cb8-18" title="18">    <span class="co">// let&#39;s initialize the object, &quot;today&quot;</span></a>
<a class="sourceLine" id="cb8-19" title="19">    <span class="co">// remember, no &quot;constructors&quot;</span></a>
<a class="sourceLine" id="cb8-20" title="20">    today._month = <span class="dv">9</span> ;</a>
<a class="sourceLine" id="cb8-21" title="21">    today._date = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb8-22" title="22">    today._year = <span class="dv">2024</span> ;</a>
<a class="sourceLine" id="cb8-23" title="23">    today._day_of_week = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb8-24" title="24"></a>
<a class="sourceLine" id="cb8-25" title="25">    printf( <span class="st">&quot;date: %d/%d/%d</span><span class="sc">\t</span><span class="st"> day: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb8-26" title="26">            today._month, today._date, today._year, today._day_of_week ) ;</a>
<a class="sourceLine" id="cb8-27" title="27"></a>
<a class="sourceLine" id="cb8-28" title="28"> </a>
<a class="sourceLine" id="cb8-29" title="29">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ; <span class="co">// adding an extra line for nice printing at the end</span></a>
<a class="sourceLine" id="cb8-30" title="30">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb8-31" title="31">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>size of struct calendar: 16
date: 9/5/2024   day: 5
</code></pre>
<p>But this is a little tedious. We need to keep track of the mapping, <em>i.e.</em>, “1” → “sunday”, “2” → “monday”, <em>etc.</em> Liable to make a mistake or forget, especially if we’re writing a of code that needs to use this mapping.</p>
<h4 id="enter-enum"><span class="header-section-number">3.0.7.1</span> Enter <code>enum</code></h4>
<p>An <code>enum</code> is a way to create an “enumeration”, <em>i.e.,</em> a list of things that are spelled out in natural language, but are really just numbers (typically <code>int</code>).</p>
<p>So, we could define something like,</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">enum</span> weekdays{ sunday, monday, tuesday, wednesday, thursday, friday, saturday } ;</a></code></pre></div>
<p>and use if in the code as follows,</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="co">// this is a single line comment</span></a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">enum</span> weekdays{ sunday, monday, tuesday, wednesday, thursday, friday, saturday } ;</a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="kw">struct</span> calendar{</a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="dt">int</span> _date ;</a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="dt">int</span> _month ;</a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="dt">int</span> _year ;</a>
<a class="sourceLine" id="cb11-11" title="11">    <span class="co">// int _day_of_week ; // 1 -- sunday, 2 -- monday, etc.</span></a>
<a class="sourceLine" id="cb11-12" title="12">    <span class="kw">enum</span> weekdays _day_of_week ;</a>
<a class="sourceLine" id="cb11-13" title="13">} ;</a>
<a class="sourceLine" id="cb11-14" title="14"></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb11-16" title="16">{</a>
<a class="sourceLine" id="cb11-17" title="17">    <span class="kw">struct</span> calendar today ; <span class="co">// creating an object of type &quot;calendar&quot;</span></a>
<a class="sourceLine" id="cb11-18" title="18"></a>
<a class="sourceLine" id="cb11-19" title="19">    printf( <span class="st">&quot;size of struct calendar: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(today) ) ;</a>
<a class="sourceLine" id="cb11-20" title="20"></a>
<a class="sourceLine" id="cb11-21" title="21">    <span class="co">// let&#39;s initialize the object, &quot;today&quot;</span></a>
<a class="sourceLine" id="cb11-22" title="22">    <span class="co">// remember, no &quot;constructors&quot;</span></a>
<a class="sourceLine" id="cb11-23" title="23">    today._month = <span class="dv">9</span> ;</a>
<a class="sourceLine" id="cb11-24" title="24">    today._date = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb11-25" title="25">    today._year = <span class="dv">2024</span> ;</a>
<a class="sourceLine" id="cb11-26" title="26">    <span class="co">// today._day_of_week = 5 ;</span></a>
<a class="sourceLine" id="cb11-27" title="27">    today._day_of_week = thursday ;</a>
<a class="sourceLine" id="cb11-28" title="28"></a>
<a class="sourceLine" id="cb11-29" title="29">    printf( <span class="st">&quot;date: %d/%d/%d</span><span class="sc">\t</span><span class="st"> day: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb11-30" title="30">            today._month, today._date, today._year, today._day_of_week ) ;</a>
<a class="sourceLine" id="cb11-31" title="31"></a>
<a class="sourceLine" id="cb11-32" title="32"> </a>
<a class="sourceLine" id="cb11-33" title="33">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ; <span class="co">// adding an extra line for nice printing at the end</span></a>
<a class="sourceLine" id="cb11-34" title="34">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb11-35" title="35">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>size of struct calendar: 16
date: 9/5/2024   day: 4
</code></pre>
<p>But, to be honest, this is not very useful. It <em>still</em> prints out a <em>number</em> instead of a string, like “monday”, “tuesday”, etc.</p>
<p>Well, if what we want is a <em>string</em>, then we need to store a <strong>string</strong>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// this is a single line comment</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="kw">enum</span> weekdays{ sunday, monday, tuesday, wednesday, thursday, friday, saturday } ;</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">struct</span> calendar{</a>
<a class="sourceLine" id="cb13-8" title="8">    <span class="dt">int</span> _date ;</a>
<a class="sourceLine" id="cb13-9" title="9">    <span class="dt">int</span> _month ;</a>
<a class="sourceLine" id="cb13-10" title="10">    <span class="dt">int</span> _year ;</a>
<a class="sourceLine" id="cb13-11" title="11">    <span class="co">// int _day_of_week ; // 1 -- sunday, 2 -- monday, etc.</span></a>
<a class="sourceLine" id="cb13-12" title="12">    <span class="co">// weekdays _day_of_week ;</span></a>
<a class="sourceLine" id="cb13-13" title="13">    <span class="dt">char</span> _day_of_week[<span class="dv">64</span>] ;</a>
<a class="sourceLine" id="cb13-14" title="14">} ;</a>
<a class="sourceLine" id="cb13-15" title="15"></a>
<a class="sourceLine" id="cb13-16" title="16"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb13-17" title="17">{</a>
<a class="sourceLine" id="cb13-18" title="18">    <span class="kw">struct</span> calendar today ; <span class="co">// creating an object of type &quot;calendar&quot;</span></a>
<a class="sourceLine" id="cb13-19" title="19"></a>
<a class="sourceLine" id="cb13-20" title="20">    printf( <span class="st">&quot;size of struct calendar: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(today) ) ;</a>
<a class="sourceLine" id="cb13-21" title="21"></a>
<a class="sourceLine" id="cb13-22" title="22">    <span class="co">// let&#39;s initialize the object, &quot;today&quot;</span></a>
<a class="sourceLine" id="cb13-23" title="23">    <span class="co">// remember, no &quot;constructors&quot;</span></a>
<a class="sourceLine" id="cb13-24" title="24">    today._month = <span class="dv">9</span> ;</a>
<a class="sourceLine" id="cb13-25" title="25">    today._date = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb13-26" title="26">    today._year = <span class="dv">2024</span> ;</a>
<a class="sourceLine" id="cb13-27" title="27">    <span class="co">// today._day_of_week = 5 ;</span></a>
<a class="sourceLine" id="cb13-28" title="28">    <span class="co">// today._day_of_week = thursday ;</span></a>
<a class="sourceLine" id="cb13-29" title="29">    today._day_of_week = <span class="st">&quot;thursday&quot;</span> ;</a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31">    printf( <span class="st">&quot;date: %d/%d/%d</span><span class="sc">\t</span><span class="st"> day: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb13-32" title="32">            today._month, today._date, today._year, today._day_of_week ) ;</a>
<a class="sourceLine" id="cb13-33" title="33"></a>
<a class="sourceLine" id="cb13-34" title="34"> </a>
<a class="sourceLine" id="cb13-35" title="35">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ; <span class="co">// adding an extra line for nice printing at the end</span></a>
<a class="sourceLine" id="cb13-36" title="36">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb13-37" title="37">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c: In function main:
inline_exec_tmp.c:29:24: error: assignment to expression with array type
   29 |     today._day_of_week = &quot;thursday&quot; ;
      |                        ^
make[1]: *** [Makefile:33: inline_exec_tmp] Error 1</code></pre>
<p>Wait, why does this fail?</p>
<p>We <strong>cannot</strong> assign one array to another! C has no way of knowing how to do this.</p>
<p>One way to bypass this, is to do it <em>at creation time</em> for the <code>today</code> object, as follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// all items created and initialized together so this works!</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">struct</span> calendar today = {<span class="dv">9</span>, <span class="dv">5</span>, <span class="dv">2024</span>, <span class="st">&quot;thursday&quot;</span>} ; </a></code></pre></div>
<p>One alternative is to <strong>explicitly</strong> set the elements of the array, as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="co">// this is a single line comment</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="kw">enum</span> weekdays{ sunday, monday, tuesday, wednesday, thursday, friday, saturday } ;</a>
<a class="sourceLine" id="cb16-6" title="6"></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">struct</span> calendar{</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="dt">int</span> _date ;</a>
<a class="sourceLine" id="cb16-9" title="9">    <span class="dt">int</span> _month ;</a>
<a class="sourceLine" id="cb16-10" title="10">    <span class="dt">int</span> _year ;</a>
<a class="sourceLine" id="cb16-11" title="11">    <span class="co">// int _day_of_week ; // 1 -- sunday, 2 -- monday, etc.</span></a>
<a class="sourceLine" id="cb16-12" title="12">    <span class="co">// weekdays _day_of_week ;</span></a>
<a class="sourceLine" id="cb16-13" title="13">    <span class="dt">char</span> _day_of_week[<span class="dv">10</span>] ;</a>
<a class="sourceLine" id="cb16-14" title="14">} ;</a>
<a class="sourceLine" id="cb16-15" title="15"></a>
<a class="sourceLine" id="cb16-16" title="16"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb16-17" title="17">{</a>
<a class="sourceLine" id="cb16-18" title="18">    <span class="kw">struct</span> calendar today ; <span class="co">// creating an object of type &quot;calendar&quot;</span></a>
<a class="sourceLine" id="cb16-19" title="19"></a>
<a class="sourceLine" id="cb16-20" title="20">    printf( <span class="st">&quot;size of struct calendar: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(today) ) ;</a>
<a class="sourceLine" id="cb16-21" title="21"></a>
<a class="sourceLine" id="cb16-22" title="22">    <span class="co">// let&#39;s initialize the object, &quot;today&quot;</span></a>
<a class="sourceLine" id="cb16-23" title="23">    <span class="co">// remember, no &quot;constructors&quot;</span></a>
<a class="sourceLine" id="cb16-24" title="24">    today._month = <span class="dv">9</span> ;</a>
<a class="sourceLine" id="cb16-25" title="25">    today._date = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb16-26" title="26">    today._year = <span class="dv">2024</span> ;</a>
<a class="sourceLine" id="cb16-27" title="27">    <span class="co">// today._day_of_week = 5 ;</span></a>
<a class="sourceLine" id="cb16-28" title="28">    <span class="co">// today._day_of_week = thursday ;</span></a>
<a class="sourceLine" id="cb16-29" title="29">    <span class="co">// today._day_of_week = &quot;thursday&quot; ;</span></a>
<a class="sourceLine" id="cb16-30" title="30">    today._day_of_week[<span class="dv">0</span>] = <span class="ch">&#39;t&#39;</span> ;</a>
<a class="sourceLine" id="cb16-31" title="31">    today._day_of_week[<span class="dv">1</span>] = <span class="ch">&#39;h&#39;</span> ;</a>
<a class="sourceLine" id="cb16-32" title="32">    today._day_of_week[<span class="dv">2</span>] = <span class="ch">&#39;u&#39;</span> ;</a>
<a class="sourceLine" id="cb16-33" title="33">    today._day_of_week[<span class="dv">3</span>] = <span class="ch">&#39;r&#39;</span> ;</a>
<a class="sourceLine" id="cb16-34" title="34">    today._day_of_week[<span class="dv">4</span>] = <span class="ch">&#39;s&#39;</span> ;</a>
<a class="sourceLine" id="cb16-35" title="35">    today._day_of_week[<span class="dv">5</span>] = <span class="ch">&#39;d&#39;</span> ;</a>
<a class="sourceLine" id="cb16-36" title="36">    today._day_of_week[<span class="dv">6</span>] = <span class="ch">&#39;a&#39;</span> ;</a>
<a class="sourceLine" id="cb16-37" title="37">    today._day_of_week[<span class="dv">7</span>] = <span class="ch">&#39;y&#39;</span> ;</a>
<a class="sourceLine" id="cb16-38" title="38">    today._day_of_week[<span class="dv">8</span>] = &#39;\<span class="dv">0</span><span class="er">&#39;</span> ;</a>
<a class="sourceLine" id="cb16-39" title="39"></a>
<a class="sourceLine" id="cb16-40" title="40">    printf( <span class="st">&quot;date: %d/%d/%d</span><span class="sc">\t</span><span class="st"> day: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb16-41" title="41">            today._month, today._date, today._year, today._day_of_week ) ;</a>
<a class="sourceLine" id="cb16-42" title="42"></a>
<a class="sourceLine" id="cb16-43" title="43"> </a>
<a class="sourceLine" id="cb16-44" title="44">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ; <span class="co">// adding an extra line for nice printing at the end</span></a>
<a class="sourceLine" id="cb16-45" title="45">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb16-46" title="46">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>size of struct calendar: 24
date: 9/5/2024   day: thursday
</code></pre>
<details>
<p><summary>[Notes]</summary></p>
<blockquote>
<ul>
<li>switch to slides for the C string/array slides</li>
<li>switch back to code examples</li>
</ul>
</blockquote>
</details>
<p>strings in <code>C</code> → an <strong>array</strong> of characters that are <code>null</code> terminated, <em>i.e.</em>, <code>\0</code>. So the `day_of_week’ field looks like this.</p>
<p><img src="figures/string_array_basic.png" width="700"></p>
<p>There’s a reason I’ve used the arrow in the above image. :wink:</p>
<h3 id="so-what-is-a-union" class="unnumbered">So what is a <code>union</code>?</h3>
<p>A <code>union</code> is a value that may have any of <strong>multiple representations</strong> or formats within the <strong>same area of memory</strong>; that consists of a variable that may hold such a data structure.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<p>A union specifies the <em>oermitted</em> data types that may be stored in that region of memory, <em>e.g.,</em> an <code>int</code> and a <code>float</code>, but <strong>never</strong> both. Hence, a union can hold only <em>one</em> data type at a time. Once a new value is assigned, the existing data is <em>overwritten</em> with the new value.</p>
<p>Syntax is similar to <code>struct</code> but the <em>effects</em> are very different.</p>
<h3 id="code-samples-2" class="unnumbered">Code Samples</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="kw">struct</span> calendar{</a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="dt">int</span> _date ;</a>
<a class="sourceLine" id="cb18-6" title="6">    <span class="dt">int</span> _month ;</a>
<a class="sourceLine" id="cb18-7" title="7">    <span class="dt">int</span> _year ;</a>
<a class="sourceLine" id="cb18-8" title="8">    <span class="co">// int _day_of_week ; // 1 -- sunday, 2 -- monday, etc.</span></a>
<a class="sourceLine" id="cb18-9" title="9">    <span class="co">// weekdays _day_of_week ;</span></a>
<a class="sourceLine" id="cb18-10" title="10">    <span class="dt">char</span> _day_of_week[<span class="dv">10</span>] ;</a>
<a class="sourceLine" id="cb18-11" title="11">} ;</a>
<a class="sourceLine" id="cb18-12" title="12"></a>
<a class="sourceLine" id="cb18-13" title="13"><span class="kw">union</span> info{</a>
<a class="sourceLine" id="cb18-14" title="14">    <span class="dt">int</span> _age ;</a>
<a class="sourceLine" id="cb18-15" title="15">    <span class="dt">double</span> _weight ;</a>
<a class="sourceLine" id="cb18-16" title="16">} ;</a>
<a class="sourceLine" id="cb18-17" title="17"></a>
<a class="sourceLine" id="cb18-18" title="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb18-19" title="19">{</a>
<a class="sourceLine" id="cb18-20" title="20">    <span class="kw">union</span> info my_info ;</a>
<a class="sourceLine" id="cb18-21" title="21"></a>
<a class="sourceLine" id="cb18-22" title="22">    <span class="kw">struct</span> calendar today ; <span class="co">// creating an object of type &quot;calendar&quot;</span></a>
<a class="sourceLine" id="cb18-23" title="23"></a>
<a class="sourceLine" id="cb18-24" title="24">    <span class="co">// look at the output of this sizeof!</span></a>
<a class="sourceLine" id="cb18-25" title="25">    printf( <span class="st">&quot;size of struct = %lu</span><span class="sc">\t</span><span class="st"> size of union = %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb18-26" title="26">            <span class="kw">sizeof</span>(today), <span class="kw">sizeof</span>(my_info) ) ;</a>
<a class="sourceLine" id="cb18-27" title="27"></a>
<a class="sourceLine" id="cb18-28" title="28"></a>
<a class="sourceLine" id="cb18-29" title="29">    <span class="co">// now I&#39;m using the &quot;int&quot; part of the union</span></a>
<a class="sourceLine" id="cb18-30" title="30">    my_info._age = <span class="dv">23452345</span> ;</a>
<a class="sourceLine" id="cb18-31" title="31">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st"> age = %d</span><span class="sc">\t</span><span class="st"> weight = %f</span><span class="sc">\n</span><span class="st">&quot;</span>, my_info._age, my_info._weight ) ;</a>
<a class="sourceLine" id="cb18-32" title="32"></a>
<a class="sourceLine" id="cb18-33" title="33">    <span class="co">// now I&#39;m using the &quot;float&quot; part of the union</span></a>
<a class="sourceLine" id="cb18-34" title="34">    my_info._weight = <span class="dv">999999</span> ;</a>
<a class="sourceLine" id="cb18-35" title="35">    printf( <span class="st">&quot;age = %d</span><span class="sc">\t</span><span class="st"> weight = %f</span><span class="sc">\n</span><span class="st">&quot;</span>, my_info._age, my_info._weight ) ;</a>
<a class="sourceLine" id="cb18-36" title="36"></a>
<a class="sourceLine" id="cb18-37" title="37">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb18-38" title="38">    <span class="cf">return</span> <span class="dv">0</span> ; <span class="co">// default value</span></a>
<a class="sourceLine" id="cb18-39" title="39">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>size of struct = 24  size of union = 8

 age = 23452345  weight = 0.000000
age = 0  weight = 999999.000000
</code></pre>
<p>As we see, we can only use one of the fields at any point in time. Unions aren’t very common today bit still do find use in may systems with limited memory, <em>e.g.,</em> embedded systems.</p>
<h1 id="intermediate-c"><span class="header-section-number">4</span> Intermediate C</h1>
<h2 id="objectives"><span class="header-section-number">4.1</span> Objectives</h2>
<ul>
<li>Recalling C types with a focus on pointers.</li>
<li>Focus on more advanced features like <code>void *</code>s and function pointers.</li>
<li>Practice thinking about C programs as memory.</li>
</ul>
<h2 id="types"><span class="header-section-number">4.2</span> Types</h2>
<h3 id="basic-types-1"><span class="header-section-number">4.2.1</span> <a href="https://en.wikipedia.org/wiki/C_data_types">Basic types</a></h3>
<ul>
<li><code>char</code> - think “one byte”. Same as <code>signed char</code>.</li>
<li><code>short int</code> - think “two bytes”. Same as <code>short</code>.</li>
<li><code>int</code> - think “four bytes”.</li>
<li><code>long int</code> - think “potentially larger <code>int</code>”. Most commonly known solely as <code>long</code>.</li>
<li><code>float</code>, <code>double</code> - floating point values (not used in the class).</li>
<li><code>void</code> - the lack of a type. Variables <em>cannot</em> have this type.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="co">/* `void` is fine to denote &quot;no variables/return values&quot;, ... */</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="dt">int</span></a>
<a class="sourceLine" id="cb20-3" title="3">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb20-4" title="4">{</a>
<a class="sourceLine" id="cb20-5" title="5">    <span class="co">/* ...but not fine on variables */</span></a>
<a class="sourceLine" id="cb20-6" title="6">    <span class="dt">void</span> a;</a>
<a class="sourceLine" id="cb20-7" title="7"></a>
<a class="sourceLine" id="cb20-8" title="8">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb20-9" title="9">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c: In function main:
inline_exec_tmp.c:6:7: error: variable or field a declared void
    6 |  void a;
      |       ^
make[1]: *** [Makefile:33: inline_exec_tmp] Error 1</code></pre>
<ul>
<li><code>enum</code> - an <code>int</code> or <code>short int</code> with some “named” values.</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="kw">enum</span> weekdays {</a>
<a class="sourceLine" id="cb22-4" title="4">    MON, TUES, WED, THURS, FRI</a>
<a class="sourceLine" id="cb22-5" title="5">};</a>
<a class="sourceLine" id="cb22-6" title="6"></a>
<a class="sourceLine" id="cb22-7" title="7"><span class="dt">int</span></a>
<a class="sourceLine" id="cb22-8" title="8">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb22-9" title="9">{</a>
<a class="sourceLine" id="cb22-10" title="10">    printf(<span class="st">&quot;MON = %d, TUES = %d, ..., FRI = %d</span><span class="sc">\n</span><span class="st">&quot;</span>, MON, TUES, FRI);</a>
<a class="sourceLine" id="cb22-11" title="11"></a>
<a class="sourceLine" id="cb22-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb22-13" title="13">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>MON = 0, TUES = 1, ..., FRI = 4</code></pre>
<p>You can choose the values explicitly (e.g. <code>enum grades { MON = 1, TUES = 2, WED = 3, THURS = 4, FRI = 5};</code>).</p>
<p><strong>Modifiers</strong></p>
<ul>
<li><code>unsigned</code> - variables that cannot be negative. Given that variables have a fixed bit-width, they can use the extra bit (“negative” no longer needs to be tracked) to instead represent numbers twice the size of <code>signed</code> variants.</li>
<li><code>signed</code> - signed variables. You don’t see this modifier as much because <code>char</code>, <code>int</code>, <code>long</code> all default to <code>signed</code>.</li>
<li><code>long</code> - Used to modify another type to make it larger in some cases. <code>long int</code> can represent larger numbers and is synonymous with <code>long</code>. <code>long long int</code> (or <code>long long</code>) is an even larger value!</li>
<li><code>static</code> - this variable should not be accessible <em>outside of the .c file</em> in which it is defined.</li>
<li><code>const</code> - an immutable value. We won’t focus much on this modifier.</li>
<li><code>volatile</code> - this variable should be “read from memory” every time it is accessed. Confusing now, relevant later, but not a focus.</li>
</ul>
<h4 id="examples"><span class="header-section-number">4.2.1.1</span> Examples</h4>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">int</span></a>
<a class="sourceLine" id="cb24-2" title="2">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb24-3" title="3">{</a>
<a class="sourceLine" id="cb24-4" title="4">    <span class="dt">char</span> a;</a>
<a class="sourceLine" id="cb24-5" title="5">    <span class="dt">signed</span> <span class="dt">char</span> a_signed;     <span class="co">/* same type as `a` */</span></a>
<a class="sourceLine" id="cb24-6" title="6">    <span class="dt">char</span> b;                   <span class="co">/* values between [-128, 127] */</span></a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="dt">unsigned</span> <span class="dt">char</span> b_unsigned; <span class="co">/* values between [0, 256] */</span></a>
<a class="sourceLine" id="cb24-8" title="8">    <span class="dt">int</span> c;</a>
<a class="sourceLine" id="cb24-9" title="9">    <span class="dt">short</span> <span class="dt">int</span> c_shortint;</a>
<a class="sourceLine" id="cb24-10" title="10">    <span class="dt">short</span> c_short;            <span class="co">/* same as `c_shortint` */</span></a>
<a class="sourceLine" id="cb24-11" title="11">    <span class="dt">long</span> <span class="dt">int</span> c_longint;</a>
<a class="sourceLine" id="cb24-12" title="12">    <span class="dt">long</span> c_long;              <span class="co">/* same type as `c_longint` */</span></a>
<a class="sourceLine" id="cb24-13" title="13"></a>
<a class="sourceLine" id="cb24-14" title="14">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb24-15" title="15">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<p>You might see all of these, but the common primitives, and their sizes:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="co">/* Commonly used types that you practically see in a lot of C */</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="dt">int</span></a>
<a class="sourceLine" id="cb26-5" title="5">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb26-6" title="6">{</a>
<a class="sourceLine" id="cb26-7" title="7">    <span class="dt">char</span> c;</a>
<a class="sourceLine" id="cb26-8" title="8">    <span class="dt">unsigned</span> <span class="dt">char</span> uc;</a>
<a class="sourceLine" id="cb26-9" title="9">    <span class="dt">short</span> s;</a>
<a class="sourceLine" id="cb26-10" title="10">    <span class="dt">unsigned</span> <span class="dt">short</span> us;</a>
<a class="sourceLine" id="cb26-11" title="11">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb26-12" title="12">    <span class="dt">unsigned</span> <span class="dt">int</span> ui;</a>
<a class="sourceLine" id="cb26-13" title="13">    <span class="dt">long</span> l;</a>
<a class="sourceLine" id="cb26-14" title="14">    <span class="dt">unsigned</span> <span class="dt">long</span> ul;</a>
<a class="sourceLine" id="cb26-15" title="15"></a>
<a class="sourceLine" id="cb26-16" title="16">    printf(<span class="st">&quot;char:</span><span class="sc">\t</span><span class="st">%ld</span><span class="sc">\n</span><span class="st">short:</span><span class="sc">\t</span><span class="st">%ld</span><span class="sc">\n</span><span class="st">int:</span><span class="sc">\t</span><span class="st">%ld</span><span class="sc">\n</span><span class="st">long:</span><span class="sc">\t</span><span class="st">%ld</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb26-17" title="17">        <span class="kw">sizeof</span>(c), <span class="kw">sizeof</span>(s), <span class="kw">sizeof</span>(i), <span class="kw">sizeof</span>(l));</a>
<a class="sourceLine" id="cb26-18" title="18"></a>
<a class="sourceLine" id="cb26-19" title="19">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb26-20" title="20">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>char:   1
short:  2
int:    4
long:   8</code></pre>
<h3 id="common-posix-types-and-values"><span class="header-section-number">4.2.2</span> Common POSIX types and values</h3>
<ul>
<li><p><code>stddef.h</code><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>:</p>
<ul>
<li><code>size_t</code>, <code>usize_t</code>, <code>ssize_t</code> - types for variables that correspond to sizes. These include the size of the memory request to <code>malloc</code>, the return value from <code>sizeof</code>, and the arguments and return values from <code>read</code>/<code>write</code>/… <code>ssize_t</code> is signed (allows negative values), while the others are unsigned.</li>
<li><code>NULL</code> - is just <code>#define NULL ((void *)0)</code></li>
</ul></li>
<li><p><code>limits.h</code><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>:</p>
<ul>
<li><code>INT_MAX</code>, <code>INT_MIN</code>, <code>UINT_MAX</code> - maximum and minimum values for a signed integer, and the maximum value for an unsigned integer.</li>
<li><code>LONG_MAX</code>, <code>LONG_MIN</code>, <code>ULONG_MAX</code> - minimum and maximum numerical values for <code>long</code>s and <code>unsigned long</code>s.</li>
<li>Same for <code>short ints</code> (<code>SHRT_MAX</code>, etc…) and <code>char</code>s (<code>CHAR_MAX</code>, etc…).</li>
</ul></li>
</ul>
<h3 id="format-strings"><span class="header-section-number">4.2.3</span> Format Strings</h3>
<p>Many standard library calls take “format strings”. You’ve seen these in <code>printf</code>. The following format specifiers should be used:</p>
<ul>
<li><code>%d</code> - <code>int</code></li>
<li><code>%ld</code> - <code>long int</code></li>
<li><code>%u</code> - <code>unsigned int</code></li>
<li><code>%c</code> - <code>char</code></li>
<li><code>%x</code> - <code>unsigned int</code> printed as hexadecimal</li>
<li><code>%lx</code> - <code>long unsigned int</code> printed as hexadecimal</li>
<li><code>%p</code> - prints out any pointer value, <code>void *</code></li>
<li><code>%s</code> - prints out a string, <code>char *</code></li>
</ul>
<p>Format strings are also used in <code>scanf</code> functions to read and parse input.</p>
<p>You can control the spacing of the printouts using <code>%NX</code> where <code>N</code> is the number of characters you want printed out (as spaces), and <code>X</code> is the format specifier above. For example, <code>"%10ld"</code>would print a long integer in a 10 character slot. Adding <code>\n</code> and <code>\t</code> add in the newlines and the tabs. If you need to print out a “\”, use <code>\\</code>.</p>
<h4 id="example"><span class="header-section-number">4.2.3.1</span> Example</h4>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="dt">int</span></a>
<a class="sourceLine" id="cb28-5" title="5">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb28-6" title="6">{</a>
<a class="sourceLine" id="cb28-7" title="7">    printf(<span class="st">&quot;Integers: %d, %ld, %u, %c</span><span class="sc">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb28-8" title="8">           <span class="st">&quot;Hex and pointers: %lx, %p</span><span class="sc">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb28-9" title="9">           <span class="st">&quot;Strings: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb28-10" title="10">           INT_MAX, LONG_MAX, UINT_MAX, <span class="ch">&#39;*&#39;</span>,</a>
<a class="sourceLine" id="cb28-11" title="11">           LONG_MAX, &amp;main,</a>
<a class="sourceLine" id="cb28-12" title="12">           <span class="st">&quot;hello world&quot;</span>);</a>
<a class="sourceLine" id="cb28-13" title="13"></a>
<a class="sourceLine" id="cb28-14" title="14">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-15" title="15">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x55bbeaaba149
Strings: hello world</code></pre>
<h3 id="compound-types-1"><span class="header-section-number">4.2.4</span> Compound types</h3>
<ul>
<li><code>struct</code> - A collection of different values. Example: objects with many different fields.</li>
<li><code>union</code> - <em>One</em> of a set of values. Example: what if you want to represent data for one food item among others.</li>
</ul>
<p>Unions are not very common, but are sometimes useful. The size of a <code>union</code> is the <em>maximum</em> size of its fields. In contrast, the <code>struct</code> is the <em>sum</em> of the sizes of each of its fields.</p>
<h4 id="example-1"><span class="header-section-number">4.2.4.1</span> Example</h4>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb30-2" title="2"></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="kw">struct</span> hamburger {</a>
<a class="sourceLine" id="cb30-4" title="4">    <span class="dt">int</span> num_burgers;</a>
<a class="sourceLine" id="cb30-5" title="5">    <span class="dt">int</span> cheese;</a>
<a class="sourceLine" id="cb30-6" title="6">    <span class="dt">int</span> num_patties;</a>
<a class="sourceLine" id="cb30-7" title="7">};</a>
<a class="sourceLine" id="cb30-8" title="8"></a>
<a class="sourceLine" id="cb30-9" title="9"><span class="kw">union</span> food {</a>
<a class="sourceLine" id="cb30-10" title="10">    <span class="dt">int</span> num_eggs;</a>
<a class="sourceLine" id="cb30-11" title="11">    <span class="kw">struct</span> hamburger burger;</a>
<a class="sourceLine" id="cb30-12" title="12">};</a>
<a class="sourceLine" id="cb30-13" title="13"></a>
<a class="sourceLine" id="cb30-14" title="14"><span class="co">/* Same contents as the union. */</span></a>
<a class="sourceLine" id="cb30-15" title="15"><span class="kw">struct</span> all_food {</a>
<a class="sourceLine" id="cb30-16" title="16">    <span class="dt">int</span> num_eggs;</a>
<a class="sourceLine" id="cb30-17" title="17">    <span class="kw">struct</span> hamburger burger;</a>
<a class="sourceLine" id="cb30-18" title="18">};</a>
<a class="sourceLine" id="cb30-19" title="19"></a>
<a class="sourceLine" id="cb30-20" title="20"><span class="dt">int</span></a>
<a class="sourceLine" id="cb30-21" title="21">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb30-22" title="22">{</a>
<a class="sourceLine" id="cb30-23" title="23">    <span class="kw">union</span> food f_eggs, f_burger;</a>
<a class="sourceLine" id="cb30-24" title="24"></a>
<a class="sourceLine" id="cb30-25" title="25">    <span class="co">/* now I shouldn&#39;t access `.burger` in `f_eggs` */</span></a>
<a class="sourceLine" id="cb30-26" title="26">    f_eggs.num_eggs = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb30-27" title="27">    <span class="co">/* This is just syntax for structure initialization. */</span></a>
<a class="sourceLine" id="cb30-28" title="28">    f_burger.burger = (<span class="kw">struct</span> hamburger) {</a>
<a class="sourceLine" id="cb30-29" title="29">        .num_burgers = <span class="dv">5</span>,</a>
<a class="sourceLine" id="cb30-30" title="30">        .cheese      = <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb30-31" title="31">        .num_patties = <span class="dv">1</span></a>
<a class="sourceLine" id="cb30-32" title="32">    };</a>
<a class="sourceLine" id="cb30-33" title="33">    <span class="co">/* now shouldn&#39;t access `.num_eggs` in `f_burger` */</span></a>
<a class="sourceLine" id="cb30-34" title="34"></a>
<a class="sourceLine" id="cb30-35" title="35">    printf(<span class="st">&quot;Size of union:  %ld</span><span class="sc">\n</span><span class="st">Size of struct: %ld</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb30-36" title="36">           <span class="kw">sizeof</span>(<span class="kw">union</span> food), <span class="kw">sizeof</span>(<span class="kw">struct</span> all_food));</a>
<a class="sourceLine" id="cb30-37" title="37"></a>
<a class="sourceLine" id="cb30-38" title="38">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb30-39" title="39">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Size of union:  12
Size of struct: 16</code></pre>
<p>We can see the effect of the <code>union</code>: The size is <code>max(fields)</code> rather than <code>sum(fields)</code>. What other examples can you think of where you might want <code>union</code>s?</p>
<blockquote>
<p>An aside on syntax: The structure initialization syntax in this example is simply a shorthand. The <code>struct hamburger</code> initialization above is equivalent to:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1">f_burger.burger.num_burgers = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb32-2" title="2">f_burger.burger.cheese      = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb32-3" title="3">f_burger.burger.num_patties = <span class="dv">1</span>;</a></code></pre></div>
<p>Though since there are so many <code>.</code>s, this is a little confusing. We’d typically want to simply as:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">struct</span> hamburger *h = &amp;f_burger.burger;</a>
<a class="sourceLine" id="cb33-2" title="2">h-&gt;num_burgers = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb33-3" title="3">h-&gt;cheese      = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-4" title="4">h-&gt;num_patties = <span class="dv">1</span>;</a></code></pre></div>
<p>More on <code>-&gt;</code> in the next section.</p>
</blockquote>
<h3 id="pointers-arrays"><span class="header-section-number">4.2.5</span> Pointers &amp; Arrays</h3>
<p>Variables can have be pointer types (e.g. <code>int *a</code>). Variables with pointer types are pointers and hold an <em>address</em> to the a variable of the type to which they point, or to <code>NULL</code>. <code>NULL</code> denotes that the pointer is not valid. You want to imagine that variables hold data, for example <code>int a = 6</code>:</p>
<pre><code>a---+
| 6 |
+---+</code></pre>
<p>A pointer, <code>int *b = &amp;a</code> should be imagined as a pointer:</p>
<pre><code>b ---&gt; a---+
       | 6 |
       +---+</code></pre>
<p>Note that the “address of”, <code>&amp;</code> operator takes a variable and returns its address. If you print out the pointer, <code>printf("%p", b)</code>, you’ll get the address (i.e. the arrow) To <em>follow the arrow</em>, you must <em>dereference</em> the pointer: <code>*b == 6</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb36-2" title="2"></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="dt">static</span> <span class="dt">int</span> value;</a>
<a class="sourceLine" id="cb36-4" title="4"></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">/* here, the `*` is part of the type &quot;int *&quot;, i.e. a pointer to an `int` */</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="dt">void</span></a>
<a class="sourceLine" id="cb36-7" title="7">foo(<span class="dt">int</span> *ptr)</a>
<a class="sourceLine" id="cb36-8" title="8">{</a>
<a class="sourceLine" id="cb36-9" title="9">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="co">     * Here, the `*` is the dereference operation, and</span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">     * gives us the value that is pointed to.</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="co">     */</span></a>
<a class="sourceLine" id="cb36-13" title="13">    *ptr = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb36-14" title="14">}</a>
<a class="sourceLine" id="cb36-15" title="15"></a>
<a class="sourceLine" id="cb36-16" title="16"><span class="dt">int</span></a>
<a class="sourceLine" id="cb36-17" title="17">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb36-18" title="18">{</a>
<a class="sourceLine" id="cb36-19" title="19">    printf(<span class="st">&quot;value is initialized to %d</span><span class="sc">\n</span><span class="st">&quot;</span>, value);</a>
<a class="sourceLine" id="cb36-20" title="20"></a>
<a class="sourceLine" id="cb36-21" title="21">    foo(&amp;value); <span class="co">/* `&amp;` gives us the address of the variable `value` */</span></a>
<a class="sourceLine" id="cb36-22" title="22">    printf(<span class="st">&quot;value updated to %d</span><span class="sc">\n</span><span class="st">&quot;</span>, value);</a>
<a class="sourceLine" id="cb36-23" title="23"></a>
<a class="sourceLine" id="cb36-24" title="24">    <span class="cf">return</span> value - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb36-25" title="25">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>value is initialized to 0
value updated to 1</code></pre>
<p>Pointers are <em>necessary</em> as they enable us to build <em>linked</em> data-structures (linked-lists, binary trees, etc…). Languages such as Java assume that <em>every single</em> object variable is a pointer, and since <em>all object variables</em> are pointers, they don’t need special syntax for them.</p>
<p>Arrays are simple contiguous data items, all of the same type. <code>int a[4] = {6, 7, 8, 9}</code> should be imagined as:</p>
<pre><code>a ---&gt; +---+---+---+---+
       | 6 | 7 | 8 | 9 |
       +---+---+---+---+</code></pre>
<p>When you access an array item, <code>a[2] == 8</code>, C is really treating <code>a</code> as a pointer, doing pointer arithmetic, and dereferences to find offset <code>2</code>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb39-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb39-2" title="2"></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb39-4" title="4">    <span class="dt">int</span> a[] = {<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>};</a>
<a class="sourceLine" id="cb39-5" title="5">    <span class="dt">int</span> n = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb39-6" title="6"></a>
<a class="sourceLine" id="cb39-7" title="7">    printf(<span class="st">&quot;0th index: %p == %p; %d == %d</span><span class="sc">\n</span><span class="st">&quot;</span>, a,     &amp;a[<span class="dv">0</span>], *a,       a[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb39-8" title="8">    printf(<span class="st">&quot;nth index: %p == %p; %d == %d</span><span class="sc">\n</span><span class="st">&quot;</span>, a + n, &amp;a[n], *(a + n), a[n]);</a>
<a class="sourceLine" id="cb39-9" title="9"></a>
<a class="sourceLine" id="cb39-10" title="10">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb39-11" title="11">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>0th index: 0x7ffe7125c1f0 == 0x7ffe7125c1f0; 6 == 6
nth index: 0x7ffe7125c1f4 == 0x7ffe7125c1f4; 7 == 7</code></pre>
<p>Making this a little more clear, lets understand how C accesses the <code>n</code>th item. Lets make a pointer <code>int *p = a + 1</code> (we’ll just simply and assume that <code>n == 1</code> here), we should have this:</p>
<pre><code>p ---------+
           |
           V
a ---&gt; +---+---+---+---+
       | 6 | 7 | 8 | 9 |
       +---+---+---+---+</code></pre>
<p>Thus if we dereference <code>p</code>, we access the <code>1</code>st index, and access the value <code>7</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb42-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb42-2" title="2"></a>
<a class="sourceLine" id="cb42-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb42-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb42-5" title="5">{</a>
<a class="sourceLine" id="cb42-6" title="6">    <span class="dt">int</span> a[] = {<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>};</a>
<a class="sourceLine" id="cb42-7" title="7">    <span class="co">/* same thing as the previous example, just making the pointer explicit */</span></a>
<a class="sourceLine" id="cb42-8" title="8">    <span class="dt">int</span> *p = a + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb42-9" title="9"></a>
<a class="sourceLine" id="cb42-10" title="10">    printf(<span class="st">&quot;nth index: %p == %p; %d == %d</span><span class="sc">\n</span><span class="st">&quot;</span>, p, &amp;a[<span class="dv">1</span>], *p, a[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb42-11" title="11"></a>
<a class="sourceLine" id="cb42-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb42-13" title="13">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>nth index: 0x7ffd0db89994 == 0x7ffd0db89994; 7 == 7</code></pre>
<p>We can see that <em>pointer arithmetic</em> (i.e. doing addition/subtraction on pointers) does the same thing as array indexing plus a dereference. That is, <code>*(a + 1) == a[1]</code>. For the most part, arrays and pointers can be viewed as very similar, with only a few exceptions<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>.</p>
<p><em>Pointer arithmetic should generally be avoided in favor of using the array syntax.</em> One complication for pointer arithmetic is that it does not fit our intuition for addition:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb44-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb44-2" title="2"></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb44-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb44-5" title="5">{</a>
<a class="sourceLine" id="cb44-6" title="6">    <span class="dt">int</span> a[] = {<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>};</a>
<a class="sourceLine" id="cb44-7" title="7">    <span class="dt">char</span> b[] = {<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>, <span class="ch">&#39;d&#39;</span>};</a>
<a class="sourceLine" id="cb44-8" title="8">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb44-9" title="9"><span class="co">     * Calculation: How big is the array?</span></a>
<a class="sourceLine" id="cb44-10" title="10"><span class="co">     * How big is each item? The division is the number of items.</span></a>
<a class="sourceLine" id="cb44-11" title="11"><span class="co">     */</span></a>
<a class="sourceLine" id="cb44-12" title="12">    <span class="dt">int</span> num_items = <span class="kw">sizeof</span>(a) / <span class="kw">sizeof</span>(a[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb44-13" title="13">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb44-14" title="14"></a>
<a class="sourceLine" id="cb44-15" title="15">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; num_items; i++) {</a>
<a class="sourceLine" id="cb44-16" title="16">        printf(<span class="st">&quot;idx %d @ %p &amp; %p</span><span class="sc">\n</span><span class="st">&quot;</span>, i, a + i, b + i);</a>
<a class="sourceLine" id="cb44-17" title="17">    }</a>
<a class="sourceLine" id="cb44-18" title="18"></a>
<a class="sourceLine" id="cb44-19" title="19">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb44-20" title="20">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>idx 0 @ 0x7ffe0f32ae70 &amp; 0x7ffe0f32ae84
idx 1 @ 0x7ffe0f32ae74 &amp; 0x7ffe0f32ae85
idx 2 @ 0x7ffe0f32ae78 &amp; 0x7ffe0f32ae86
idx 3 @ 0x7ffe0f32ae7c &amp; 0x7ffe0f32ae87</code></pre>
<p>Note that the pointer for the integer array (<code>a</code>) is being incremented by 4, while the character array (<code>b</code>) by 1. Focusing on the key part:</p>
<pre><code>idx 0 @ ...0 &amp; ...4
idx 1 @ ...4 &amp; ...5
idx 2 @ ...8 &amp; ...6
idx 3 @ ...c &amp; ...7
           ^      ^
           |      |
Adds 4 ----+      |
Adds 1 -----------+</code></pre>
<p>Thus, pointer arithmetic depends on the <em>size of the types within the array</em>. There are types when one wants to iterate through each byte of an array, even if the array contains larger values such as integers. For example, the <code>memset</code> and <code>memcmp</code> functions set each byte in an range of memory, and byte-wise compare two ranges of memory. In such cases, <em>casts</em> can be used to manipulate the pointer type (e.g. <code>(char *)a</code> enables <code>a</code> to not be referenced with pointer arithmetic that iterates through bytes).</p>
<h4 id="example-2"><span class="header-section-number">4.2.5.1</span> Example</h4>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb47-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb47-2" title="2"></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="co">/* a simple linked list */</span></a>
<a class="sourceLine" id="cb47-4" title="4"><span class="kw">struct</span> student {</a>
<a class="sourceLine" id="cb47-5" title="5">    <span class="dt">char</span> *name;</a>
<a class="sourceLine" id="cb47-6" title="6">    <span class="kw">struct</span> student *next;</a>
<a class="sourceLine" id="cb47-7" title="7">};</a>
<a class="sourceLine" id="cb47-8" title="8"></a>
<a class="sourceLine" id="cb47-9" title="9"><span class="kw">struct</span> student students[] = {</a>
<a class="sourceLine" id="cb47-10" title="10">    {.name = <span class="st">&quot;Penny&quot;</span>, .next = &amp;students[<span class="dv">1</span>]}, <span class="co">/* or `students + 1` */</span></a>
<a class="sourceLine" id="cb47-11" title="11">    {.name = <span class="st">&quot;Gabe&quot;</span>,  .next = NULL}</a>
<a class="sourceLine" id="cb47-12" title="12">};</a>
<a class="sourceLine" id="cb47-13" title="13"><span class="kw">struct</span> student *head = students;</a>
<a class="sourceLine" id="cb47-14" title="14"><span class="co">/*</span></a>
<a class="sourceLine" id="cb47-15" title="15"><span class="co"> * head --&gt; students+------+</span></a>
<a class="sourceLine" id="cb47-16" title="16"><span class="co"> *          | Penny | Gabe |</span></a>
<a class="sourceLine" id="cb47-17" title="17"><span class="co"> *          | next  | next |</span></a>
<a class="sourceLine" id="cb47-18" title="18"><span class="co"> *          +-|-----+---|--+</span></a>
<a class="sourceLine" id="cb47-19" title="19"><span class="co"> *            |     ^   +-----&gt;NULL</span></a>
<a class="sourceLine" id="cb47-20" title="20"><span class="co"> *            |     |</span></a>
<a class="sourceLine" id="cb47-21" title="21"><span class="co"> *            +-----+</span></a>
<a class="sourceLine" id="cb47-22" title="22"><span class="co"> */</span></a>
<a class="sourceLine" id="cb47-23" title="23"><span class="dt">int</span></a>
<a class="sourceLine" id="cb47-24" title="24">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb47-25" title="25">{</a>
<a class="sourceLine" id="cb47-26" title="26">    <span class="kw">struct</span> student *i;</a>
<a class="sourceLine" id="cb47-27" title="27"></a>
<a class="sourceLine" id="cb47-28" title="28">    <span class="cf">for</span> (i = head; i != NULL; i = i-&gt;next) {</a>
<a class="sourceLine" id="cb47-29" title="29">        printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, i-&gt;name);</a>
<a class="sourceLine" id="cb47-30" title="30">    }</a>
<a class="sourceLine" id="cb47-31" title="31"></a>
<a class="sourceLine" id="cb47-32" title="32">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb47-33" title="33">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Penny
Gabe</code></pre>
<h4 id="generic-pointer-types"><span class="header-section-number">4.2.5.2</span> Generic Pointer Types</h4>
<p>Generally, if you want to treat a pointer type as another, you need to use a cast. You rarely want to do this (see the <code>memset</code> example below to see an example where you might want it). However, there is a need in C to have a “generic pointer type” that can be implicitly cast into any other pointer type. To get a sense of why this is, two simple examples:</p>
<blockquote>
<ol type="1">
<li>What should the type of <code>NULL</code> be?</li>
</ol>
</blockquote>
<p><code>NULL</code> is used as a valid value for <em>any</em> pointer (of any type), thus <code>NULL</code> must have a generic type that can be used in the code as a value for any pointer. Thus, the type of <code>NULL</code> must be <code>void *</code>.</p>
<blockquote>
<ol start="2" type="1">
<li><code>malloc</code> returns a pointer to newly-allocated memory. What should the type of the return value be?</li>
</ol>
</blockquote>
<p>C solves this with the <code>void *</code> pointer type. Recall that <code>void</code> is not a valid type for a variable, but a <code>void *</code> is different. It is a "generic pointer that cannot be dereferenced*. Note that dereferencing a <code>void *</code> pointer shouldn’t work as <code>void</code> is not a valid variable type (e.g. <code>void *a; *a = 10;</code> doesn’t make much sense because <code>*a</code> is type <code>void</code>).</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb49-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb49-2" title="2"></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb49-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb49-5" title="5">{</a>
<a class="sourceLine" id="cb49-6" title="6">    <span class="dt">int</span> *intptr = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>)); <span class="co">/* malloc returns `void *`! */</span></a>
<a class="sourceLine" id="cb49-7" title="7"></a>
<a class="sourceLine" id="cb49-8" title="8">    *intptr = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb49-9" title="9"></a>
<a class="sourceLine" id="cb49-10" title="10">    <span class="cf">return</span> *intptr;</a>
<a class="sourceLine" id="cb49-11" title="11">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<p>Data-structures often aim to store data of any type (think: a linked list of anything). Thus, in C, you often see <code>void *</code>s to reference the data they store.</p>
<h4 id="relationship-between-pointers-arrays-and-arrows"><span class="header-section-number">4.2.5.3</span> Relationship between Pointers, Arrays, and Arrows</h4>
<p>Indexing into arrays (<code>a[b]</code>) and arrows (<code>a-&gt;b</code>) are redundant syntactic features, but they are very convenient.</p>
<ul>
<li><code>&amp;a[b]</code> is equivalent to <code>a + b</code> where <code>a</code> is a pointer and <code>b</code> is an index.</li>
<li><code>a[b]</code> is equivalent to <code>*(a + b)</code> where <code>a</code> is a pointer and <code>b</code> is an index.</li>
<li><code>a-&gt;b</code> is equivalent to <code>(*a).b</code> where <code>a</code> is a pointer to a variable with a structure type that has <code>b</code> as a field.</li>
</ul>
<p>Generally, you should always try and stick to the array and arrow syntax were possible, as it makes your intention much more clear when coding than the pointer arithmetic and dereferences.</p>
<h2 id="memory-allocation"><span class="header-section-number">4.3</span> Memory Allocation</h2>
<p>Dynamic memory allocations</p>
<ul>
<li><code>void *malloc(size_t size)</code> - allocate <code>size</code> memory, or return <code>NULL</code>.</li>
<li><code>void *calloc(size_t nmemb, size_t size)</code> - allocate <code>nmemb * size</code> bytes, and initialize them to <code>0</code>.</li>
<li><code>void *realloc(void *ptr, size_t size)</code> - pass in a previous allocation, and <em>either</em> grow/shrink it to <code>size</code>, or allocate a new chunk of memory and copy the data in <code>ptr</code> into it. Return the memory of size <code>size</code>, or <code>NULL</code> on error.</li>
<li><code>void free(void *ptr)</code> - deallocate previously allocated memory (returned from any of the above).</li>
</ul>
<p>A few things to keep in mind:</p>
<ol type="1">
<li>If you want to allocate an array, then you have to do the math yourself for the array size. For example, <code>int *arr = malloc(sizeof(int) * n);</code> to allocate an array of <code>int</code>s with a length of <code>n</code>.</li>
<li><code>malloc</code> is not guaranteed to initialize its memory to <code>0</code>. <em>You</em> must make sure that your array gets initialized. It is not uncommon to do a <code>memset(arr, 0, sizeof(int) * n);</code> to set the memory <code>0</code>.</li>
<li><code>calloc</code> is guaranteed to initialize all its allocated memory to <code>0</code>.</li>
</ol>
<h3 id="common-errors"><span class="header-section-number">4.3.1</span> Common Errors</h3>
<ul>
<li><em>Allocation error.</em> You <em>must</em> check the return value of memory allocation functions for <code>NULL</code>, and handle the error appropriately.</li>
</ul>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb51-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb51-2" title="2"></a>
<a class="sourceLine" id="cb51-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb51-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb51-5" title="5">{</a>
<a class="sourceLine" id="cb51-6" title="6">    <span class="dt">int</span> *a = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb51-7" title="7">    <span class="co">/* Error: did not check return value! */</span></a>
<a class="sourceLine" id="cb51-8" title="8">    *a = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb51-9" title="9">    free(a);</a>
<a class="sourceLine" id="cb51-10" title="10"></a>
<a class="sourceLine" id="cb51-11" title="11">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb51-12" title="12">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<ul>
<li><em>Dangling pointer.</em> If you maintain a pointer to a chunk of memory that you <code>free</code>, and then dereference that pointer, bad things can happen. The memory might have already been re-allocated due to another call to <code>malloc</code>, and is used for something completely different in your program. It is up to you as a programmer to avoid <code>free</code>ing memory until all references to it are dropped.</li>
</ul>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb53-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb53-2" title="2"></a>
<a class="sourceLine" id="cb53-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb53-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb53-5" title="5">{</a>
<a class="sourceLine" id="cb53-6" title="6">    <span class="dt">int</span> *a = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb53-7" title="7">    <span class="cf">if</span> (a == NULL) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb53-8" title="8">    free(a);</a>
<a class="sourceLine" id="cb53-9" title="9"></a>
<a class="sourceLine" id="cb53-10" title="10">    <span class="co">/* Error: accessing what `a` points to after `free`! */</span></a>
<a class="sourceLine" id="cb53-11" title="11">    <span class="cf">return</span> *a;</a>
<a class="sourceLine" id="cb53-12" title="12">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<ul>
<li><em>Memory leaks.</em> If you remove all references to memory, but <em>don’t</em> <code>free</code> it, then the memory will <em>never</em> get freed. This is a memory leak.</li>
</ul>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb55-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb55-2" title="2"></a>
<a class="sourceLine" id="cb55-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb55-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb55-5" title="5">{</a>
<a class="sourceLine" id="cb55-6" title="6">    <span class="dt">int</span> *a = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb55-7" title="7">    <span class="cf">if</span> (!a) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb55-8" title="8">    a = NULL;</a>
<a class="sourceLine" id="cb55-9" title="9">    <span class="co">/* Error: never `free`d `a` and no references to it remain! */</span></a>
<a class="sourceLine" id="cb55-10" title="10"></a>
<a class="sourceLine" id="cb55-11" title="11">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb55-12" title="12">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<ul>
<li><em>Double <code>free</code>.</em> If you <code>free</code> the memory twice, bad things can happen. You could confuse the memory allocation logic, or you could accidentally <code>free</code> an allocation made after the first <code>free</code> was called.</li>
</ul>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb57-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb57-2" title="2"></a>
<a class="sourceLine" id="cb57-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb57-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb57-5" title="5">{</a>
<a class="sourceLine" id="cb57-6" title="6">    <span class="dt">int</span> *a = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb57-7" title="7">    <span class="cf">if</span> (!a) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb57-8" title="8">    free(a);</a>
<a class="sourceLine" id="cb57-9" title="9">    free(a);</a>
<a class="sourceLine" id="cb57-10" title="10">    <span class="co">/* Error: yeah, don&#39;t do that! */</span></a>
<a class="sourceLine" id="cb57-11" title="11"></a>
<a class="sourceLine" id="cb57-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb57-13" title="13">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>free(): double free detected in tcache 2
make[1]: *** [Makefile:30: inline_exec] Aborted</code></pre>
<p><code>valgrind</code> will help you debug the last three of these issues, and later in the class, we’ll develop a library to help debug the first.</p>
<h2 id="exercises"><span class="header-section-number">4.4</span> Exercises</h2>
<h3 id="c-is-a-thin-language-layer-on-top-of-memory"><span class="header-section-number">4.4.1</span> C is a Thin Language Layer on Top of Memory</h3>
<p>We’re going to look at a set of variables as memory. When variables are created globally, they are simply allocated into subsequent addresses.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb59-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb59-2" title="2"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb59-3" title="3"></a>
<a class="sourceLine" id="cb59-4" title="4"><span class="dt">void</span> print_values(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb59-5" title="5"></a>
<a class="sourceLine" id="cb59-6" title="6"><span class="dt">unsigned</span> <span class="dt">char</span> a = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb59-7" title="7"><span class="dt">int</span> b = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb59-8" title="8"><span class="kw">struct</span> foo {</a>
<a class="sourceLine" id="cb59-9" title="9">    <span class="dt">long</span> c_a, c_b;</a>
<a class="sourceLine" id="cb59-10" title="10">    <span class="dt">int</span> *c_c;</a>
<a class="sourceLine" id="cb59-11" title="11">};</a>
<a class="sourceLine" id="cb59-12" title="12"><span class="kw">struct</span> foo c = (<span class="kw">struct</span> foo) { .c_a = <span class="dv">3</span>, .c_c = &amp;b };</a>
<a class="sourceLine" id="cb59-13" title="13"><span class="dt">unsigned</span> <span class="dt">char</span> end;</a>
<a class="sourceLine" id="cb59-14" title="14"></a>
<a class="sourceLine" id="cb59-15" title="15"><span class="dt">int</span></a>
<a class="sourceLine" id="cb59-16" title="16">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb59-17" title="17">{</a>
<a class="sourceLine" id="cb59-18" title="18">    <span class="dt">size_t</span> vars_size;</a>
<a class="sourceLine" id="cb59-19" title="19">    <span class="dt">unsigned</span> <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb59-20" title="20">    <span class="dt">unsigned</span> <span class="dt">char</span> *mem;</a>
<a class="sourceLine" id="cb59-21" title="21"></a>
<a class="sourceLine" id="cb59-22" title="22">    <span class="co">/* Q1: What would you predict the output of &amp;end - &amp;a is? */</span></a>
<a class="sourceLine" id="cb59-23" title="23">    printf(<span class="st">&quot;Addresses:</span><span class="sc">\n</span><span class="st">a   @ %p</span><span class="sc">\n</span><span class="st">b   @ %p</span><span class="sc">\n</span><span class="st">c   @ %p</span><span class="sc">\n</span><span class="st">end @ %p</span><span class="sc">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb59-24" title="24">           <span class="st">&quot;&amp;end - &amp;a = %ld</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="co">/* Note: you can split strings! */</span></a>
<a class="sourceLine" id="cb59-25" title="25">           &amp;a, &amp;b, &amp;c, &amp;end, &amp;end - &amp;a);</a>
<a class="sourceLine" id="cb59-26" title="26">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Initial values:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb59-27" title="27">    print_values();</a>
<a class="sourceLine" id="cb59-28" title="28">    <span class="co">/* Q2: Describe what these next two lines are doing. */</span></a>
<a class="sourceLine" id="cb59-29" title="29">    vars_size = &amp;end - &amp;a;</a>
<a class="sourceLine" id="cb59-30" title="30">    mem = &amp;a;</a>
<a class="sourceLine" id="cb59-31" title="31">    <span class="co">/* Q3: What would you expect in the following printout (with the print uncommented)? */</span></a>
<a class="sourceLine" id="cb59-32" title="32">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Print out the variables as raw memory</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb59-33" title="33">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; vars_size; i++) {</a>
<a class="sourceLine" id="cb59-34" title="34">        <span class="dt">unsigned</span> <span class="dt">char</span> c = mem[i];</a>
<a class="sourceLine" id="cb59-35" title="35"><span class="co">//      printf(&quot;%x &quot;, c);</span></a>
<a class="sourceLine" id="cb59-36" title="36">    }</a>
<a class="sourceLine" id="cb59-37" title="37">    <span class="co">/* Q4: What would you expect in the following printout (with the print uncommented)? */</span></a>
<a class="sourceLine" id="cb59-38" title="38">    memset(mem, <span class="dv">0</span>, vars_size);</a>
<a class="sourceLine" id="cb59-39" title="39">    <span class="co">/* memset(a, b, c): set the memory starting at `a` of size `c` equal `b` */</span></a>
<a class="sourceLine" id="cb59-40" title="40">    printf(<span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">Post-`memset` values:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb59-41" title="41"><span class="co">//  print_values();</span></a>
<a class="sourceLine" id="cb59-42" title="42"></a>
<a class="sourceLine" id="cb59-43" title="43">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb59-44" title="44">}</a>
<a class="sourceLine" id="cb59-45" title="45"></a>
<a class="sourceLine" id="cb59-46" title="46"><span class="dt">void</span></a>
<a class="sourceLine" id="cb59-47" title="47">print_values(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb59-48" title="48">{</a>
<a class="sourceLine" id="cb59-49" title="49">    printf(<span class="st">&quot;a     = %d</span><span class="sc">\n</span><span class="st">b     = %d</span><span class="sc">\n</span><span class="st">c.c_a = %ld</span><span class="sc">\n</span><span class="st">c.c_b = %ld</span><span class="sc">\n</span><span class="st">c.c_c = %p</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb59-50" title="50">           a, b, c.c_a, c.c_b, c.c_c);</a>
<a class="sourceLine" id="cb59-51" title="51">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Addresses:
a   @ 0x55c388805010
b   @ 0x55c388805014
c   @ 0x55c388805020
end @ 0x55c388805039
&amp;end - &amp;a = 41

Initial values:
a     = 1
b     = 2
c.c_a = 3
c.c_b = 0
c.c_c = 0x55c388805014

Print out the variables as raw memory


Post-`memset` values:</code></pre>
<p><strong>Question</strong> Answer <em>Q1-4</em> in the code, uncommenting and modifying where appropriate.</p>
<h4 id="takeaways"><span class="header-section-number">4.4.1.1</span> Takeaways</h4>
<ol type="1">
<li>Each variable in C (including fields in structs) want to be aligned on a boundary equal to the variable’s type’s size. This means that a variable (<code>b</code>) with an integer type (<code>sizeof(int) == 4</code>) should always have an address that is a multiple of its size (<code>&amp;b % sizeof(b) == 0</code>, so an <code>int</code>’s address is always divisible by <code>4</code>, a <code>long</code>’s by <code>8</code>).</li>
<li>The operation to figure out the size of all the variables, <code>&amp;end - &amp;a</code>, is <em>crazy</em>. We’re used to performing math operations values on things of the same type, but not on <em>pointers</em>. This is only possible because C sees the variables are chunks of memory that happen to be laid out in memory, one after the other.</li>
<li>The <em>crazy</em> increases with <code>mem = &amp;a</code>, and our iteration through <code>mem[i]</code>. We’re able to completely ignore the types in C, and access memory directly!</li>
</ol>
<p><strong>Question</strong>: What would break if we changed <code>char a;</code> into <code>int a;</code>? C doesn’t let us do math on variables of <em>any type</em>. If you fixed compilation problems, would you still get the same output?</p>
<h3 id="quick-and-dirty-key-value-store"><span class="header-section-number">4.4.2</span> Quick-and-dirty Key-Value Store</h3>
<p>Please read the <code>man</code> pages for <code>lsearch</code> and <code>lfind</code>. <code>man</code> pages can be pretty cryptic, and you are aiming to get <em>some idea</em> where to start with an implementation. An simplistic, and incomplete initial implementation:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb61-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb61-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb61-3" title="3"><span class="pp">#include </span><span class="im">&lt;search.h&gt;</span></a>
<a class="sourceLine" id="cb61-4" title="4"></a>
<a class="sourceLine" id="cb61-5" title="5"><span class="pp">#define NUM_ENTRIES 8</span></a>
<a class="sourceLine" id="cb61-6" title="6"><span class="kw">struct</span> kv_entry {</a>
<a class="sourceLine" id="cb61-7" title="7">    <span class="dt">int</span> key; <span class="co">/* only support keys for now... */</span></a>
<a class="sourceLine" id="cb61-8" title="8">};</a>
<a class="sourceLine" id="cb61-9" title="9"><span class="co">/* global values are initialized to `0` */</span></a>
<a class="sourceLine" id="cb61-10" title="10"><span class="kw">struct</span> kv_entry entries[NUM_ENTRIES];</a>
<a class="sourceLine" id="cb61-11" title="11"><span class="dt">size_t</span> num_items = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-12" title="12"></a>
<a class="sourceLine" id="cb61-13" title="13"><span class="co">/**</span></a>
<a class="sourceLine" id="cb61-14" title="14"><span class="co"> * Insert into the key-value store the `key` and `value`.</span></a>
<a class="sourceLine" id="cb61-15" title="15"><span class="co"> * Return `0` on successful insertion of the value, or `-1`</span></a>
<a class="sourceLine" id="cb61-16" title="16"><span class="co"> * if the value couldn&#39;t be inserted.</span></a>
<a class="sourceLine" id="cb61-17" title="17"><span class="co"> */</span></a>
<a class="sourceLine" id="cb61-18" title="18"><span class="dt">int</span></a>
<a class="sourceLine" id="cb61-19" title="19">put(<span class="dt">int</span> key, <span class="dt">int</span> value)</a>
<a class="sourceLine" id="cb61-20" title="20">{</a>
<a class="sourceLine" id="cb61-21" title="21">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-22" title="22">}</a>
<a class="sourceLine" id="cb61-23" title="23"></a>
<a class="sourceLine" id="cb61-24" title="24"><span class="co">/**</span></a>
<a class="sourceLine" id="cb61-25" title="25"><span class="co"> * Attempt to get a value associated with a `key`.</span></a>
<a class="sourceLine" id="cb61-26" title="26"><span class="co"> * Return the value, or `0` if the `key` isn&#39;t in the store.</span></a>
<a class="sourceLine" id="cb61-27" title="27"><span class="co"> */</span></a>
<a class="sourceLine" id="cb61-28" title="28"><span class="dt">int</span></a>
<a class="sourceLine" id="cb61-29" title="29">get(<span class="dt">int</span> key)</a>
<a class="sourceLine" id="cb61-30" title="30">{</a>
<a class="sourceLine" id="cb61-31" title="31">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-32" title="32">}</a>
<a class="sourceLine" id="cb61-33" title="33"></a>
<a class="sourceLine" id="cb61-34" title="34"><span class="dt">int</span></a>
<a class="sourceLine" id="cb61-35" title="35">compare(<span class="dt">const</span> <span class="dt">void</span> *a, <span class="dt">const</span> <span class="dt">void</span> *b)</a>
<a class="sourceLine" id="cb61-36" title="36">{</a>
<a class="sourceLine" id="cb61-37" title="37">    <span class="co">/* We know these are `int`s, so treat them as such! */</span></a>
<a class="sourceLine" id="cb61-38" title="38">    <span class="dt">const</span> <span class="kw">struct</span> kv_entry *a_ent = a, *b_ent = b;</a>
<a class="sourceLine" id="cb61-39" title="39"></a>
<a class="sourceLine" id="cb61-40" title="40">    <span class="cf">if</span> (a_ent-&gt;key == b_ent-&gt;key) <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-41" title="41"></a>
<a class="sourceLine" id="cb61-42" title="42">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb61-43" title="43">}</a>
<a class="sourceLine" id="cb61-44" title="44"></a>
<a class="sourceLine" id="cb61-45" title="45"><span class="dt">int</span></a>
<a class="sourceLine" id="cb61-46" title="46">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb61-47" title="47">{</a>
<a class="sourceLine" id="cb61-48" title="48">    <span class="kw">struct</span> kv_entry keys[] = {</a>
<a class="sourceLine" id="cb61-49" title="49">        {.key = <span class="dv">1</span>},</a>
<a class="sourceLine" id="cb61-50" title="50">        {.key = <span class="dv">2</span>},</a>
<a class="sourceLine" id="cb61-51" title="51">        {.key = <span class="dv">4</span>},</a>
<a class="sourceLine" id="cb61-52" title="52">        {.key = <span class="dv">3</span>}</a>
<a class="sourceLine" id="cb61-53" title="53">    };</a>
<a class="sourceLine" id="cb61-54" title="54">    <span class="dt">int</span> num_kv = <span class="kw">sizeof</span>(keys) / <span class="kw">sizeof</span>(keys[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb61-55" title="55">    <span class="dt">int</span> queries[] = {<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">5</span>};</a>
<a class="sourceLine" id="cb61-56" title="56">    <span class="dt">int</span> num_queries = <span class="kw">sizeof</span>(queries) / <span class="kw">sizeof</span>(queries[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb61-57" title="57">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb61-58" title="58"></a>
<a class="sourceLine" id="cb61-59" title="59">    <span class="co">/* Insert the keys. */</span></a>
<a class="sourceLine" id="cb61-60" title="60">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; num_kv; i++) {</a>
<a class="sourceLine" id="cb61-61" title="61">        lsearch(&amp;keys[i], entries, &amp;num_items, <span class="kw">sizeof</span>(entries) / <span class="kw">sizeof</span>(entries[<span class="dv">0</span>]), compare);</a>
<a class="sourceLine" id="cb61-62" title="62">    }</a>
<a class="sourceLine" id="cb61-63" title="63"></a>
<a class="sourceLine" id="cb61-64" title="64">    <span class="co">/* Now lets lookup the keys. */</span></a>
<a class="sourceLine" id="cb61-65" title="65">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; num_queries; i++) {</a>
<a class="sourceLine" id="cb61-66" title="66">        <span class="kw">struct</span> kv_entry *ent;</a>
<a class="sourceLine" id="cb61-67" title="67">        <span class="dt">int</span> val = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-68" title="68"></a>
<a class="sourceLine" id="cb61-69" title="69">        ent = lfind(&amp;queries[i], entries, &amp;num_items, <span class="kw">sizeof</span>(entries[<span class="dv">0</span>]), compare);</a>
<a class="sourceLine" id="cb61-70" title="70">        <span class="cf">if</span> (ent != NULL) {</a>
<a class="sourceLine" id="cb61-71" title="71">            val = ent-&gt;key;</a>
<a class="sourceLine" id="cb61-72" title="72">        }</a>
<a class="sourceLine" id="cb61-73" title="73"></a>
<a class="sourceLine" id="cb61-74" title="74">        printf(<span class="st">&quot;%d: %d @ %p</span><span class="sc">\n</span><span class="st">&quot;</span>, i, val, ent);</a>
<a class="sourceLine" id="cb61-75" title="75">    }</a>
<a class="sourceLine" id="cb61-76" title="76"></a>
<a class="sourceLine" id="cb61-77" title="77">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-78" title="78">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>0: 4 @ 0x558a79c7104c
1: 2 @ 0x558a79c71044
2: 0 @ (nil)</code></pre>
<p>You want to implement a simple “key-value” store that is very similar in API to a hash-table (many key-value stores are implemented using hash-tables!).</p>
<p><strong>Questions/Tasks:</strong></p>
<ul>
<li><em>Q1</em>: What is the difference between <code>lsearch</code> and <code>lfind</code>? The <code>man</code>pages should help here (<code>man 3 lsearch</code>) (you can exit from a <code>man</code> page using ‘q’). What operations would you want to perform with each (and why)?</li>
<li><em>Q2</em>: The current implementation doesn’t include <em>values</em> at all. It returns the keys instead of values. Expand the implementation to properly track values.</li>
<li><em>Q3</em>: Encapsulate the key-value store behind the <code>put</code> and <code>get</code> functions.</li>
<li><em>Q4</em>: Add testing into the <code>main</code> for the relevant conditions and failures in <code>get</code> and <code>put</code>. # Pointers | Casting <a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/pointer_casting.html/">Slides</a></li>
</ul>
<h2 id="pointers-and-arrays"><span class="header-section-number">4.5</span> Pointers and Arrays</h2>
<p>..are the same thing!</p>
<ul>
<li>just different conventions to <strong>access memory</strong></li>
<li><em>e.g.,</em> pointer arithmetic over an array of ints</li>
<li>moves addresses by <strong>size of the int</strong> → <code>4</code> bytes</li>
<li><strong>no interaction</strong> with individual bytes
<ul>
<li>only <strong>whole ints</strong></li>
</ul></li>
</ul>
<h2 id="pointer-arithmetic"><span class="header-section-number">4.6</span> Pointer Arithmetic</h2>
<ul>
<li>consider an integer array → <code>int a[5]</code></li>
<li><code>5</code> ints, <strong>each</strong> of <code>4</code> bytes <img src="./figures/07.01.pointer_cast/pointer_cast.1.png" alt="array of integers" /></li>
</ul>
<p><br></p>
<ul>
<li>so <code>a[0]</code> is: <img src="./figures/07.01.pointer_cast/pointer_cast.2.png" alt="array of integers" /></li>
</ul>
<p><br></p>
<ul>
<li>so <code>a[1]</code> is → <strong>same</strong> as <code>++a</code>! <img src="./figures/07.01.pointer_cast/pointer_cast.3.png" alt="array of integers" /></li>
</ul>
<p><br></p>
<ul>
<li>we <strong>cannot</strong> access the individual bytes, i.e., these ones: <img src="./figures/07.01.pointer_cast/pointer_cast.4.png" alt="array of integers" /></li>
</ul>
<p><br></p>
<p>what if we <strong>want</strong> to access the individual bytes?</p>
<h2 id="pointer-casting"><span class="header-section-number">4.7</span> Pointer Casting!</h2>
<ul>
<li>can cast from one pointer type to another!</li>
<li>between <strong>any two pointers</strong>!</li>
<li>a pointer is always the same size, <em>i.e.,</em> <code>4</code> bytes</li>
<li>making it point to something else</li>
<li>doesn’t change the memory underneath
<ul>
<li>but, <strong>changes pointer arithmetic</strong>!</li>
</ul></li>
</ul>
<h3 id="casting-from-int-to-char"><span class="header-section-number">4.7.1</span> Casting from <code>int*</code> to <code>char*</code></h3>
<ul>
<li>now, as before, if we have → <code>int a[5]</code></li>
<li>and we do, <strong><code>char* pc = (char*) a ;</code></strong></li>
<li><code>pc</code> points to the <strong>same</strong> memory region as <code>a</code></li>
<li>but now, can treat it as <strong>characters</strong></li>
<li><p><em>i.e.,</em> <strong>one byte</strong> <br> <br></p></li>
<li><p>so <code>pc[0]</code> is: <img src="./figures/07.01.pointer_cast/pointer_cast.5.png" alt="array of integers" /></p></li>
</ul>
<p><br></p>
<ul>
<li>so <code>pc[1]</code> is → same as <code>++pc</code>! <img src="./figures/07.01.pointer_cast/pointer_cast.6.png" alt="array of integers" /></li>
</ul>
<h3 id="example-3"><span class="header-section-number">4.7.2</span> Example</h3>
<p>Consider the following code:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb63-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb63-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb63-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb63-4" title="4"></a>
<a class="sourceLine" id="cb63-5" title="5"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb63-6" title="6">{</a>
<a class="sourceLine" id="cb63-7" title="7">    <span class="dt">int</span>* a = (<span class="dt">int</span>*)malloc( <span class="kw">sizeof</span>(<span class="dt">int</span>) ) ;</a>
<a class="sourceLine" id="cb63-8" title="8">    assert(a != NULL) ; <span class="co">// SAME as assert (a)</span></a>
<a class="sourceLine" id="cb63-9" title="9"></a>
<a class="sourceLine" id="cb63-10" title="10">    *a = <span class="dv">1145258561</span> ;</a>
<a class="sourceLine" id="cb63-11" title="11"></a>
<a class="sourceLine" id="cb63-12" title="12">    printf( <span class="st">&quot;a = %d</span><span class="sc">\n</span><span class="st">&quot;</span>, *a ) ;</a>
<a class="sourceLine" id="cb63-13" title="13"></a>
<a class="sourceLine" id="cb63-14" title="14">    <span class="dt">char</span>* ppc = (<span class="dt">char</span>*) a ;</a>
<a class="sourceLine" id="cb63-15" title="15">    <span class="cf">for</span>(<span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; <span class="kw">sizeof</span>(a); ++i )</a>
<a class="sourceLine" id="cb63-16" title="16">        printf( <span class="st">&quot;%c &quot;</span>, *pc++ ) ;</a>
<a class="sourceLine" id="cb63-17" title="17"></a>
<a class="sourceLine" id="cb63-18" title="18">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ;</a>
<a class="sourceLine" id="cb63-19" title="19">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb63-20" title="20">}</a></code></pre></div>
<h2 id="pointer-casting-void"><span class="header-section-number">4.8</span> Pointer Casting | <code>void*</code></h2>
<ul>
<li>can cast <strong>any</strong> point to a <code>void*</code></li>
<li>all of these are valid:</li>
</ul>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb64-1" title="1"><span class="dt">void</span>* pv = malloc(<span class="dv">32</span>);</a>
<a class="sourceLine" id="cb64-2" title="2"><span class="dt">int</span>* pi = (<span class="dt">int</span>*) pv ; </a>
<a class="sourceLine" id="cb64-3" title="3"><span class="dt">double</span>* pd = (<span class="dt">double</span>*) pv ;</a>
<a class="sourceLine" id="cb64-4" title="4"><span class="dt">char</span>* pc = (<span class="dt">char</span>*) pi ; </a></code></pre></div>
<ul>
<li>can cast <strong>any</strong> point to a <code>void*</code></li>
<li>all of these are valid:</li>
<li><strong>cannot</strong> dereference a <code>void*</code> directly! compiler does not know the type</li>
</ul>
<h1 id="function-pointers"><span class="header-section-number">5</span> Function Pointers</h1>
<p>Functions have <strong>types</strong> too. E.g.,</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb65-1" title="1"><span class="dt">void</span> foo(<span class="dt">int</span> i, <span class="dt">double</span> d){...}</a></code></pre></div>
<p>The “type” of this function is: * takes as input two arguments → one <code>int</code> and one <code>double</code> * returns nothing, hence return type is <code>void</code> * <strong>note</strong>: this is <strong>not</strong> the same as a return type of <code>void*</code></p>
<p>Sometimes, you need to decide <em>which</em> function to call at <strong>run time</strong>. Why?</p>
<h3 id="example-bubble-sort"><span class="header-section-number">5.0.1</span> Example | Bubble Sort</h3>
<p>[<a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/code/generic_bubble_sort.c">Follow along with the Generic Bubble Sort Code</a>]</p>
<p>How do you write a bubble sort? Say for an array of <code>int</code>s?</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb66-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb66-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb66-4" title="4"></a>
<a class="sourceLine" id="cb66-5" title="5"><span class="co">// Sorting ints</span></a>
<a class="sourceLine" id="cb66-6" title="6"><span class="dt">void</span> bubble_sort_int( <span class="dt">int</span> array[], <span class="dt">int</span> array_size )</a>
<a class="sourceLine" id="cb66-7" title="7">{</a>
<a class="sourceLine" id="cb66-8" title="8">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; array_size-<span class="dv">1</span> ; ++i )</a>
<a class="sourceLine" id="cb66-9" title="9">    {</a>
<a class="sourceLine" id="cb66-10" title="10">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> j = <span class="dv">0</span> ; j &lt; i ; ++j )</a>
<a class="sourceLine" id="cb66-11" title="11">        {</a>
<a class="sourceLine" id="cb66-12" title="12">            <span class="cf">if</span>( array[j] &gt; array[j+<span class="dv">1</span>] )</a>
<a class="sourceLine" id="cb66-13" title="13">            {</a>
<a class="sourceLine" id="cb66-14" title="14">                <span class="dt">int</span> temp = array[j] ;</a>
<a class="sourceLine" id="cb66-15" title="15">                array[j] = array[j+<span class="dv">1</span>] ;</a>
<a class="sourceLine" id="cb66-16" title="16">                array[j+<span class="dv">1</span>] = temp ;</a>
<a class="sourceLine" id="cb66-17" title="17">            }</a>
<a class="sourceLine" id="cb66-18" title="18">        }</a>
<a class="sourceLine" id="cb66-19" title="19">    }</a>
<a class="sourceLine" id="cb66-20" title="20">}</a>
<a class="sourceLine" id="cb66-21" title="21"></a>
<a class="sourceLine" id="cb66-22" title="22"><span class="co">// printing out an array</span></a>
<a class="sourceLine" id="cb66-23" title="23"><span class="dt">void</span> print_array( <span class="dt">int</span> array[], <span class="dt">int</span> array_size )</a>
<a class="sourceLine" id="cb66-24" title="24">{</a>
<a class="sourceLine" id="cb66-25" title="25">    printf( <span class="st">&quot;array = &quot;</span> ) ;</a>
<a class="sourceLine" id="cb66-26" title="26">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; array_size ; ++i )</a>
<a class="sourceLine" id="cb66-27" title="27">        printf( <span class="st">&quot;%d &quot;</span>, array[i] ) ;</a>
<a class="sourceLine" id="cb66-28" title="28">}</a>
<a class="sourceLine" id="cb66-29" title="29"></a>
<a class="sourceLine" id="cb66-30" title="30"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb66-31" title="31">{</a>
<a class="sourceLine" id="cb66-32" title="32">    <span class="dt">int</span> my_array[] = { <span class="dv">2341</span>, <span class="dv">8632</span>, <span class="dv">3</span>, <span class="dv">2344</span>, <span class="dv">747645</span> } ;</a>
<a class="sourceLine" id="cb66-33" title="33">    <span class="dt">int</span> array_size = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb66-34" title="34"></a>
<a class="sourceLine" id="cb66-35" title="35">    <span class="co">// sort the array</span></a>
<a class="sourceLine" id="cb66-36" title="36">    bubble_sort( my_array, array_size ) ;</a>
<a class="sourceLine" id="cb66-37" title="37"></a>
<a class="sourceLine" id="cb66-38" title="38">    print_array( my_array, array_size ) ;</a>
<a class="sourceLine" id="cb66-39" title="39"></a>
<a class="sourceLine" id="cb66-40" title="40">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb66-41" title="41">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb66-42" title="42">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c: In function bubble_sort_int:
inline_exec_tmp.c:8:33: warning: comparison of integer expressions of different signedness: unsigned int and int [-Wsign-compare]
    8 |     for( unsigned int i = 0 ; i &lt; array_size-1 ; ++i )
      |                                 ^
inline_exec_tmp.c: In function print_array:
inline_exec_tmp.c:26:33: warning: comparison of integer expressions of different signedness: unsigned int and int [-Wsign-compare]
   26 |     for( unsigned int i = 0 ; i &lt; array_size ; ++i )
      |                                 ^
inline_exec_tmp.c: In function main:
inline_exec_tmp.c:36:5: warning: implicit declaration of function bubble_sort; did you mean bubble_sort_int? [-Wimplicit-function-declaration]
   36 |     bubble_sort( my_array, array_size ) ;
      |     ^~~~~~~~~~~
      |     bubble_sort_int
/usr/bin/ld: /tmp/ccJP3rA2.o: in function `main&#39;:
/home/sibin/Teaching/CSCI_2401/lectures/inline_exec_tmp.c:36: undefined reference to `bubble_sort&#39;
collect2: error: ld returned 1 exit status
make[1]: *** [Makefile:33: inline_exec_tmp] Error 1</code></pre>
<p>This works for an array of <code>int</code>s. But what if I want to sort an array of <code>double</code>?</p>
<p>Maybe, write a new function to do that?</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb68-1" title="1"><span class="co">// Sorting ints</span></a>
<a class="sourceLine" id="cb68-2" title="2"><span class="dt">void</span> bubble_sort_double( <span class="dt">double</span> array[], <span class="dt">int</span> array_size )</a>
<a class="sourceLine" id="cb68-3" title="3">{</a>
<a class="sourceLine" id="cb68-4" title="4">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; array_size-<span class="dv">1</span> ; ++i )</a>
<a class="sourceLine" id="cb68-5" title="5">    {</a>
<a class="sourceLine" id="cb68-6" title="6">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> j = <span class="dv">0</span> ; j &lt; i ; ++j )</a>
<a class="sourceLine" id="cb68-7" title="7">        {</a>
<a class="sourceLine" id="cb68-8" title="8">            <span class="cf">if</span>( array[j] &gt; array[j+<span class="dv">1</span>] )</a>
<a class="sourceLine" id="cb68-9" title="9">            {</a>
<a class="sourceLine" id="cb68-10" title="10">                <span class="dt">double</span> temp = array[j] ;</a>
<a class="sourceLine" id="cb68-11" title="11">                array[j] = array[j+<span class="dv">1</span>] ;</a>
<a class="sourceLine" id="cb68-12" title="12">                array[j+<span class="dv">1</span>] = temp ;</a>
<a class="sourceLine" id="cb68-13" title="13">            }</a>
<a class="sourceLine" id="cb68-14" title="14">        }</a>
<a class="sourceLine" id="cb68-15" title="15">    }</a>
<a class="sourceLine" id="cb68-16" title="16">}</a></code></pre></div>
<p>But what if I want to sort an array of <code>char</code>? Strings? <code>float</code>s? My custom <code>struct</code>s? Do we write one function for each?</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb69-1" title="1"><span class="dt">void</span> bubble_sort_char( <span class="dt">char</span> array[], <span class="dt">int</span> array_size ){...}</a>
<a class="sourceLine" id="cb69-2" title="2"><span class="dt">void</span> bubble_sort_strings( <span class="dt">char</span>* array[], <span class="dt">int</span> array_size ){...}</a>
<a class="sourceLine" id="cb69-3" title="3"><span class="dt">void</span> bubble_sort_float( <span class="dt">float</span> array[], <span class="dt">int</span> array_size ){...}</a>
<a class="sourceLine" id="cb69-4" title="4"><span class="dt">void</span> bubble_sort_struct_student( <span class="kw">struct</span> student array[], <span class="dt">int</span> array_size ){...}</a></code></pre></div>
<p>But what if <strong>we don’t know which one will be needed until run time?</strong>*</p>
<p>So, depending on the data that we’re given, or some input from the user, we may have to pick one of the above but <em>won’t know of the choice at compile time</em>.</p>
<p>Enter <strong>function pointers</strong>!</p>
<h3 id="example-generic-bubble-sort"><span class="header-section-number">5.0.2</span> Example | Generic Bubble Sort</h3>
<p>A sorting algorithm, at its heart, has two parts:</p>
<ol type="1">
<li><em>compare</em>: given two elements, let us know which is larger/greater</li>
<li><em>swap</em>: given two elements, exchange their values</li>
</ol>
<p>so, in a generic sense, we have:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb70-1" title="1"><span class="cf">if</span>( is_greater(a, b) ) <span class="co">// If a is larger than b</span></a>
<a class="sourceLine" id="cb70-2" title="2">    swap(a, b)         <span class="co">// swap their values</span></a></code></pre></div>
<p>hence, we can rewrite the bubble sort function, in a “generic” form as:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb71-1" title="1"><span class="co">// Sorting | Generic</span></a>
<a class="sourceLine" id="cb71-2" title="2"><span class="dt">void</span> generic_bubble_sort(...)</a>
<a class="sourceLine" id="cb71-3" title="3">{</a>
<a class="sourceLine" id="cb71-4" title="4">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; array_size-<span class="dv">1</span> ; ++i )</a>
<a class="sourceLine" id="cb71-5" title="5">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> j = <span class="dv">0</span> ; j &lt; i ; ++j )</a>
<a class="sourceLine" id="cb71-6" title="6">            <span class="cf">if</span>( is_greater( array[j], array[j+<span class="dv">1</span>]) )</a>
<a class="sourceLine" id="cb71-7" title="7">                swap( array[j], array[j+<span class="dv">1</span>] ) ;</a>
<a class="sourceLine" id="cb71-8" title="8">}</a></code></pre></div>
<p>But, what are the <strong>inputs</strong> to the function?</p>
<p>We first need to define the type of the array. Since we won’t know the type of the data elements in the array, we can’t pick a specific array type.</p>
<p>But, remember: * arrays and pointers are interchangeable * can cast from any pointer type to <code>void*</code> and back</p>
<p>using this, we define the array as a <code>void*</code>:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb72-1" title="1"><span class="dt">void</span> generic_bubble_sort( <span class="dt">void</span>* array, ... )</a></code></pre></div>
<p>As before, we need to know the <em>size</em> of the entire array, so we can now expand the function signature more:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb73-1" title="1"><span class="dt">void</span> generic_bubble_sort( <span class="dt">void</span>* array, <span class="dt">int</span> array_size, ...)</a></code></pre></div>
<p>Remember that a void* pointer is just a pointer to a <em>block</em> of memory. C does not know the <em>type of each element</em> in the array. So, we <strong>cannot</strong> do: * <code>array[i]</code> → since the type is a <code>void*</code></p>
<p>We can use pointer arithmetic with <code>void*</code> so this is possible: * <code>array+i</code> → but that moves the pointer forward by <code>i</code> <strong>bytes</strong></p>
<p>and <strong>not</strong> by the number of bytes of the data type. Recall, * <code>char* pc ; pc+1 ;</code> → advances by <code>1</code> byte * <code>int* pi ; pi+1 ;</code> → advances by <code>4</code> bytes</p>
<p>Hence, we need information about the <em>size of each element</em>, i.e.,</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb74-1" title="1"><span class="dt">void</span> generic_bubble_sort( <span class="dt">void</span>* array, <span class="dt">int</span> array_size, </a>
<a class="sourceLine" id="cb74-2" title="2">                                        <span class="dt">int</span> element_size ) </a></code></pre></div>
<p>So, we can do: <code>array + (i * element_size)</code> to move to the next element in the array</p>
<p>So, for an <code>int</code> array, we get (<code>element_size = 4</code>): <img src="./figures/07.01.pointer_cast/pointer_cast.2.png" alt="array of integers" /> <img src="./figures/07.01.pointer_cast/pointer_cast.3.png" alt="array of integers" /> <br></p>
<p>and for a <code>char</code> array, we get (<code>element_size = 1</code>): <img src="./figures/07.01.pointer_cast/pointer_cast.5.png" alt="array of integers" /> <img src="./figures/07.01.pointer_cast/pointer_cast.6.png" alt="array of integers" /></p>
<p><br></p>
<p>Using this information about <code>element_size</code>, we can rewrite the generic bubble sort function as:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb75-1" title="1"><span class="co">// Sorting | Generic</span></a>
<a class="sourceLine" id="cb75-2" title="2"><span class="dt">void</span> generic_bubble_sort( <span class="dt">void</span>* array, <span class="dt">int</span> array_size, </a>
<a class="sourceLine" id="cb75-3" title="3">                                        <span class="dt">int</span> element_size ) </a>
<a class="sourceLine" id="cb75-4" title="4">{</a>
<a class="sourceLine" id="cb75-5" title="5">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; array_size-<span class="dv">1</span> ; ++i )</a>
<a class="sourceLine" id="cb75-6" title="6">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> j = <span class="dv">0</span> ; j &lt; i ; ++j )</a>
<a class="sourceLine" id="cb75-7" title="7">            <span class="cf">if</span>( is_greater( array + (j * element_size), array + ((j+<span class="dv">1</span>) * element_size )) )</a>
<a class="sourceLine" id="cb75-8" title="8">                swap( array + (j * element_size), array + ((j+<span class="dv">1</span>) * element_size )) ) ;</a>
<a class="sourceLine" id="cb75-9" title="9">}</a></code></pre></div>
<p>Now we see the <em>generic</em> version of bubble sort taking shape.</p>
<h3 id="what-is-generic"><span class="header-section-number">5.0.3</span> What is “<em>generic</em>”?</h3>
<p>But we are still missing critical information, <em>viz.</em>, what are <code>is_greater()</code> and <code>swap()</code>?</p>
<p>Remember that since the <code>generic_bubble_sort()</code> function doesn’t know which <em>exact</em> type it is operating on, we need to <em>somehow</em> provide it with the <strong>actual</strong> functions that will carry out the comparison and swapping, depending on the type of the array being passed in. For instance, if we are comparing integers, we need a comparator and swap that can operate on integers and similarly ones for structs, doubles, <em>etc.</em></p>
<p>Wouldn’t it be great, if we could just <strong>send in the specific functions as arguments to <code>generic_bubble_sort()</code></strong>, say like,</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb76-1" title="1"><span class="dt">void</span> generic_bubble_sort( <span class="dt">void</span>* array, <span class="dt">int</span> array_size, </a>
<a class="sourceLine" id="cb76-2" title="2">                          <span class="dt">int</span> element_size, </a>
<a class="sourceLine" id="cb76-3" title="3">                          &lt;SOME_TYPE&gt; is_greater,</a>
<a class="sourceLine" id="cb76-4" title="4">                          &lt;SOME_TYPE&gt; swap ) </a>
<a class="sourceLine" id="cb76-5" title="5">{</a>
<a class="sourceLine" id="cb76-6" title="6">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; array_size-<span class="dv">1</span> ; ++i )</a>
<a class="sourceLine" id="cb76-7" title="7">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> j = <span class="dv">0</span> ; j &lt; i ; ++j )</a>
<a class="sourceLine" id="cb76-8" title="8">            <span class="cf">if</span>( is_greater( array + (j * element_size), array + ((j+<span class="dv">1</span>) * element_size )) )</a>
<a class="sourceLine" id="cb76-9" title="9">                swap( array + (j * element_size), array + ((j+<span class="dv">1</span>) * element_size )) ) ;</a>
<a class="sourceLine" id="cb76-10" title="10">}</a></code></pre></div>
<p>This is <em>precisely</em> where <strong>function pointers</strong> come in.</p>
<p>We can define <code>is_greater()</code> and <code>swap()</code> to be pointers to functions, <em>i.e.,</em> to a <strong>type</strong> of function (the signatures). Hence, a <em>comparator</em> function pointer would look like:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb77-1" title="1"><span class="kw">typedef</span> <span class="dt">int</span> (*comparator_function_pointer)( <span class="dt">void</span>* l, <span class="dt">void</span>* r ) ;</a></code></pre></div>
<p>Recall that the <code>typedef</code> keyword <em>associates a name with a type</em>. In the above example, we are saying that <code>comparator_function_pointer</code> is now a name that refers to the (function) type, <code>int (*)( void*, void* )</code>, <em>i.e.,</em> a <strong>pointer to a function that takes two arguments, each of type <code>void*</code> and returns and <code>int</code></strong>.</p>
<p>Note, that the job of a comparator function is to take two values and, * return positive (non-zero) values if <code>l &gt; r</code> or * a zero if <code>l &lt;= r</code>.</p>
<p>We can define the <code>swap</code> function pointer in a similar manner:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb78-1" title="1"><span class="kw">typedef</span> <span class="dt">void</span> (*swap_function_pointer)( <span class="dt">void</span>* l, <span class="dt">void</span>* r ) ;</a></code></pre></div>
<p>where, <code>swap_function_pointer</code> is a <strong>name</strong> that refers to the (function) type, <code>void (*)( void*, void* )</code> since such a function doens’t need to return anything, just swap the two elements pointed to by the <code>void*</code> arguments.</p>
<p>Updating our sorting function to use the function pointers,</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb79-1" title="1"><span class="dt">void</span> generic_bubble_sort( <span class="dt">void</span>* array, <span class="dt">int</span> array_size, </a>
<a class="sourceLine" id="cb79-2" title="2">                          <span class="dt">int</span> element_size, </a>
<a class="sourceLine" id="cb79-3" title="3">                          comparator_function_pointer is_greater,</a>
<a class="sourceLine" id="cb79-4" title="4">                          swap_function_pointer swap ) </a>
<a class="sourceLine" id="cb79-5" title="5">{</a>
<a class="sourceLine" id="cb79-6" title="6">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; array_size-<span class="dv">1</span> ; ++i )</a>
<a class="sourceLine" id="cb79-7" title="7">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> j = <span class="dv">0</span> ; j &lt; i ; ++j )</a>
<a class="sourceLine" id="cb79-8" title="8">            <span class="cf">if</span>( is_greater( array + (j * element_size), array + ((j+<span class="dv">1</span>) * element_size )) )</a>
<a class="sourceLine" id="cb79-9" title="9">                swap( array + (j * element_size), array + ((j+<span class="dv">1</span>) * element_size )) ) ;</a>
<a class="sourceLine" id="cb79-10" title="10">}</a></code></pre></div>
<p>So, <code>is_greater</code> is now a function pointer of type, <code>comparator_function_pointer</code> and <code>swap</code> is a function pointer of type, <code>swap_function_pointer</code>.</p>
<p><strong>NOTE:</strong> function pointers are invoked <strong>exactly</strong> like regular functions, <em>i.e.,</em> <code>is_greater(...)</code> and <code>swap(...)</code>. The above code will work without any changes.</p>
<h3 id="generic-to-concrete-functions"><span class="header-section-number">5.0.4</span> Generic to <em>concrete</em> functions</h3>
<p>Eventually, we need to decide what it is that we are sorting. Is it an array of <code>int</code>s, <code>doubles</code>s, <code>struct</code>s, etc. And at that point in time, we will need the actual, **concrete* functions for comparing and swapping <code>int</code>s (or <code>double</code>s or whatever).</p>
<p>We we define the two functions (using <code>int</code> as an example):</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb80-1" title="1"><span class="co">// Compare and Swap functions for integers</span></a>
<a class="sourceLine" id="cb80-2" title="2"><span class="dt">int</span> is_greater_than_int( <span class="dt">void</span>* l, <span class="dt">void</span>* r )</a>
<a class="sourceLine" id="cb80-3" title="3">{</a>
<a class="sourceLine" id="cb80-4" title="4">    <span class="co">// cast it from void* to relevant type, int*</span></a>
<a class="sourceLine" id="cb80-5" title="5">    <span class="co">// since we cannot dereference void*</span></a>
<a class="sourceLine" id="cb80-6" title="6">    <span class="dt">int</span>* left = l ;</a>
<a class="sourceLine" id="cb80-7" title="7">    <span class="dt">int</span>* right = r ;</a>
<a class="sourceLine" id="cb80-8" title="8"></a>
<a class="sourceLine" id="cb80-9" title="9">    <span class="co">// compare and return result</span></a>
<a class="sourceLine" id="cb80-10" title="10">    <span class="cf">if</span>( *left &gt; *right )</a>
<a class="sourceLine" id="cb80-11" title="11">        <span class="cf">return</span> <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb80-12" title="12">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb80-13" title="13">        <span class="cf">return</span> <span class="dv">0</span> ; </a>
<a class="sourceLine" id="cb80-14" title="14"></a>
<a class="sourceLine" id="cb80-15" title="15">   <span class="co">// Can just use this one line instead but not doing so for clarity</span></a>
<a class="sourceLine" id="cb80-16" title="16">   <span class="co">// return ( *l &gt; *r ? 1 : 0 ) ; </span></a>
<a class="sourceLine" id="cb80-17" title="17">}</a>
<a class="sourceLine" id="cb80-18" title="18"></a>
<a class="sourceLine" id="cb80-19" title="19"><span class="dt">void</span> swap_int( <span class="dt">void</span>* l, <span class="dt">void</span>* r )</a>
<a class="sourceLine" id="cb80-20" title="20">{</a>
<a class="sourceLine" id="cb80-21" title="21">    <span class="co">// cast it from void* to relevant type, int*</span></a>
<a class="sourceLine" id="cb80-22" title="22">    <span class="co">// since we cannot dereference void*</span></a>
<a class="sourceLine" id="cb80-23" title="23">    <span class="dt">int</span>* left = l ;</a>
<a class="sourceLine" id="cb80-24" title="24">    <span class="dt">int</span>* right = r ;</a>
<a class="sourceLine" id="cb80-25" title="25">    <span class="dt">int</span> temp = *left ;</a>
<a class="sourceLine" id="cb80-26" title="26"></a>
<a class="sourceLine" id="cb80-27" title="27">    <span class="co">// swap</span></a>
<a class="sourceLine" id="cb80-28" title="28">    *left = *right ;</a>
<a class="sourceLine" id="cb80-29" title="29">    *right = temp ;</a>
<a class="sourceLine" id="cb80-30" title="30">}</a></code></pre></div>
<p>We can define equivalent functions for <code>double</code>,</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb81-1" title="1"><span class="co">// Compare and Swap functions for doubles </span></a>
<a class="sourceLine" id="cb81-2" title="2"><span class="dt">int</span> is_greater_than_double( <span class="dt">void</span>* l, <span class="dt">void</span>* r )</a>
<a class="sourceLine" id="cb81-3" title="3">{</a>
<a class="sourceLine" id="cb81-4" title="4">    <span class="dt">double</span>* left = l ;</a>
<a class="sourceLine" id="cb81-5" title="5">    <span class="dt">double</span>* right = r ;</a>
<a class="sourceLine" id="cb81-6" title="6"></a>
<a class="sourceLine" id="cb81-7" title="7">    <span class="cf">if</span>( *left &gt; *right )</a>
<a class="sourceLine" id="cb81-8" title="8">        <span class="cf">return</span> <span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb81-9" title="9">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb81-10" title="10">        <span class="cf">return</span> <span class="dv">0</span> ; </a>
<a class="sourceLine" id="cb81-11" title="11">}</a>
<a class="sourceLine" id="cb81-12" title="12"></a>
<a class="sourceLine" id="cb81-13" title="13"><span class="dt">void</span> swap_double( <span class="dt">void</span>* l, <span class="dt">void</span>* r )</a>
<a class="sourceLine" id="cb81-14" title="14">{</a>
<a class="sourceLine" id="cb81-15" title="15">    <span class="dt">double</span>* left = l ;</a>
<a class="sourceLine" id="cb81-16" title="16">    <span class="dt">double</span>* right = r ;</a>
<a class="sourceLine" id="cb81-17" title="17">    <span class="dt">double</span> temp = *left ;</a>
<a class="sourceLine" id="cb81-18" title="18"></a>
<a class="sourceLine" id="cb81-19" title="19">    *left = *right ;</a>
<a class="sourceLine" id="cb81-20" title="20">    *right = temp ;</a>
<a class="sourceLine" id="cb81-21" title="21">}</a></code></pre></div>
<p><strong>NOTE:</strong> the type signatures of the concrete functions must <strong>exactly match</strong> that of the corresponding function pointers. Otherwise it will result in compile time errors.</p>
<h3 id="putting-it-all-together-using-function-pointers"><span class="header-section-number">5.0.5</span> Putting it all Together | Using Function Pointers</h3>
<p>Now we are ready to use the concrete functions and the pointers in our code:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb82-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb82-2" title="2">{</a>
<a class="sourceLine" id="cb82-3" title="3">    <span class="dt">int</span> my_array_int[] = { <span class="dv">2341</span>, <span class="dv">8632</span>, <span class="dv">3</span>, <span class="dv">2344</span>, <span class="dv">747645</span> } ;</a>
<a class="sourceLine" id="cb82-4" title="4">    <span class="dt">int</span> array_size = <span class="dv">5</span> ;</a>
<a class="sourceLine" id="cb82-5" title="5"></a>
<a class="sourceLine" id="cb82-6" title="6">    <span class="co">// calling the INTEGER version with the concrete integer comparator and swap</span></a>
<a class="sourceLine" id="cb82-7" title="7">    generic_bubble_sort( my_array_int, array_size, </a>
<a class="sourceLine" id="cb82-8" title="8">                         <span class="kw">sizeof</span>(<span class="dt">int</span>), <span class="co">/*element size*/</span></a>
<a class="sourceLine" id="cb82-9" title="9">                         is_greater_than_int, </a>
<a class="sourceLine" id="cb82-10" title="10">                         swap_int ) ;</a>
<a class="sourceLine" id="cb82-11" title="11"></a>
<a class="sourceLine" id="cb82-12" title="12">    <span class="co">// calling the DOUBLE version with the concrete DOUBLE comparator and swap</span></a>
<a class="sourceLine" id="cb82-13" title="13">    <span class="dt">double</span> my_double_array[] = {<span class="fl">1.0</span>, <span class="fl">9485.2</span>, <span class="fl">34.567</span>, <span class="fl">9383.243</span>, <span class="fl">44.1</span> } ;</a>
<a class="sourceLine" id="cb82-14" title="14">    generic_bubble_sort( my_double_array, array_size, </a>
<a class="sourceLine" id="cb82-15" title="15">                         <span class="kw">sizeof</span>(<span class="dt">double</span>), <span class="co">/*element size*/</span></a>
<a class="sourceLine" id="cb82-16" title="16">                         is_greater_than_double, </a>
<a class="sourceLine" id="cb82-17" title="17">                         swap_double ) ;</a>
<a class="sourceLine" id="cb82-18" title="18"></a>
<a class="sourceLine" id="cb82-19" title="19">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb82-20" title="20">}</a></code></pre></div>
<p>As we see from the above, we are using the <strong>same</strong> <code>generic_bubble_srt</code> function to sort both, arrays of <code>int</code> and <code>double</code>. The only difference is the different <em>concrete</em> versions of the comparator and swap functions that we pass to the sorting function.</p>
<h3 id="why-bother-if-we-need-concrete-functions-anyways"><span class="header-section-number">5.0.6</span> Why bother if we need <code>concrete</code> functions anyways?</h3>
<p>Using function pointers allows us to do a few things well: 1. <strong>code reuse</strong>: the code for sorting doesn’t need to be rewritten each time. In fact, when we have larger, more complex, functions, this will be a lifesaver as we can implement the main “concept” just once and then write “<em>specialized</em>” concrete functions (usually much smaller) as needed. 2. <strong>dynamic dispatch</strong>: oftentimes, it may not be clear <em>which</em> version of the concrete functions are needed, <strong>until runtime</strong>! In our example, what if we don’t know if we’re given arrays of <code>int</code>s or <code>double</code>s until we receive the data at runtime? Then we cannot know which concrete function is to be invoked while writing the code. Hence, we can pick the appropriate function pointer <em>at run time</em> and the code will work correctly! 3. <strong>specialization</strong>: different data types require different handling. The way we sort numbers <em>will not</em> be the same way we sort strings or other, more complex, data types (<em>e.g.,</em> user defined <code>struct</code>s).</p>
<h3 id="in-class-exercise-generic-insertion-sort-for-struct"><span class="header-section-number">5.0.7</span> In-class Exercise | Generic Insertion Sort for <code>struct</code></h3>
<p>Fill out the missing elements in this code:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb83-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb83-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb83-3" title="3"></a>
<a class="sourceLine" id="cb83-4" title="4"><span class="pp">#define NAME_LENGTH 128</span></a>
<a class="sourceLine" id="cb83-5" title="5"></a>
<a class="sourceLine" id="cb83-6" title="6"><span class="kw">struct</span> map{</a>
<a class="sourceLine" id="cb83-7" title="7">    <span class="dt">char</span> _country[NAME_LENGTH] ;</a>
<a class="sourceLine" id="cb83-8" title="8">    <span class="dt">char</span> _capital[NAME_LENGTH] ;</a>
<a class="sourceLine" id="cb83-9" title="9">} ;</a>
<a class="sourceLine" id="cb83-10" title="10"></a>
<a class="sourceLine" id="cb83-11" title="11"></a>
<a class="sourceLine" id="cb83-12" title="12"><span class="co">// DEFINE TWO FUNCTION POINTERS, ONE EACH FOR COMPARE AND SWAP</span></a>
<a class="sourceLine" id="cb83-13" title="13"></a>
<a class="sourceLine" id="cb83-14" title="14"></a>
<a class="sourceLine" id="cb83-15" title="15"><span class="co">// UNCOMMENT THE TWO ARGUMENTS ONCE YOU DEFINE THE FUNCTION POINTERS</span></a>
<a class="sourceLine" id="cb83-16" title="16"><span class="dt">void</span> generic_insertion_sort( <span class="dt">void</span>* array, <span class="dt">int</span> array_size, <span class="dt">int</span> element_size</a>
<a class="sourceLine" id="cb83-17" title="17">                            <span class="co">/*is_greater_than my_comparator,</span></a>
<a class="sourceLine" id="cb83-18" title="18"><span class="co">                            swap my_swap*/</span> )</a>
<a class="sourceLine" id="cb83-19" title="19">{</a>
<a class="sourceLine" id="cb83-20" title="20"></a>
<a class="sourceLine" id="cb83-21" title="21">}</a>
<a class="sourceLine" id="cb83-22" title="22"></a>
<a class="sourceLine" id="cb83-23" title="23"><span class="co">// CREATE A NEW STRUCT AND RETURN A POINTER TO IT</span></a>
<a class="sourceLine" id="cb83-24" title="24"><span class="kw">struct</span> map* create_new_struct(<span class="co">/*...*/</span>)</a>
<a class="sourceLine" id="cb83-25" title="25">{</a>
<a class="sourceLine" id="cb83-26" title="26"></a>
<a class="sourceLine" id="cb83-27" title="27">}</a>
<a class="sourceLine" id="cb83-28" title="28"></a>
<a class="sourceLine" id="cb83-29" title="29"><span class="co">// CREATE THE COMPARATOR AND SWAP FUNCTIONS HERE</span></a>
<a class="sourceLine" id="cb83-30" title="30"></a>
<a class="sourceLine" id="cb83-31" title="31"></a>
<a class="sourceLine" id="cb83-32" title="32"></a>
<a class="sourceLine" id="cb83-33" title="33"></a>
<a class="sourceLine" id="cb83-34" title="34"><span class="co">// FUNCTION TO PRINT THE ARRAY OF STRUCTS AND ITS ELEMENTS</span></a>
<a class="sourceLine" id="cb83-35" title="35"><span class="co">// PRINT EACH RECORD ON A NEW LINE AS FOLLOWS:</span></a>
<a class="sourceLine" id="cb83-36" title="36"><span class="co">// country: USA             capital: Washington D.C.</span></a>
<a class="sourceLine" id="cb83-37" title="37"><span class="co">// country: Sierra Leone    capital: Freetown</span></a>
<a class="sourceLine" id="cb83-38" title="38"><span class="co">// ...</span></a>
<a class="sourceLine" id="cb83-39" title="39"><span class="dt">void</span> print_array_structs(<span class="co">/*...*/</span>)</a>
<a class="sourceLine" id="cb83-40" title="40">{</a>
<a class="sourceLine" id="cb83-41" title="41"></a>
<a class="sourceLine" id="cb83-42" title="42">}</a>
<a class="sourceLine" id="cb83-43" title="43"></a>
<a class="sourceLine" id="cb83-44" title="44"></a>
<a class="sourceLine" id="cb83-45" title="45"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb83-46" title="46">{ </a>
<a class="sourceLine" id="cb83-47" title="47">    <span class="dt">unsigned</span> <span class="dt">int</span> num_countries ;</a>
<a class="sourceLine" id="cb83-48" title="48">    printf( <span class="st">&quot;number of countries: &quot;</span> ) ;</a>
<a class="sourceLine" id="cb83-49" title="49">    scanf( <span class="st">&quot;%d&quot;</span>, &amp;num_countries ) ;</a>
<a class="sourceLine" id="cb83-50" title="50"></a>
<a class="sourceLine" id="cb83-51" title="51">    <span class="co">// CREATE AN ARRAY OF POINTERS TO STRUCTS</span></a>
<a class="sourceLine" id="cb83-52" title="52">    <span class="kw">struct</span> map** array_countries <span class="co">/*= ...*/</span> ;</a>
<a class="sourceLine" id="cb83-53" title="53"></a>
<a class="sourceLine" id="cb83-54" title="54"></a>
<a class="sourceLine" id="cb83-55" title="55"></a>
<a class="sourceLine" id="cb83-56" title="56">    <span class="co">// CREATE num_countries NUMBER OF &quot;COUNTRIES&quot; AND STORE IN THE ARRAY</span></a>
<a class="sourceLine" id="cb83-57" title="57">    <span class="co">// ASK USER FOR INPUT ON COUNTRY/CAPITALS</span></a>
<a class="sourceLine" id="cb83-58" title="58">    <span class="co">// YOU CAN PICK YOUR OWN COUNTRY/CAPITAL COMBINATIONS</span></a>
<a class="sourceLine" id="cb83-59" title="59"></a>
<a class="sourceLine" id="cb83-60" title="60"></a>
<a class="sourceLine" id="cb83-61" title="61">    <span class="co">// PRINT THE ARRAY BEFORE SORT</span></a>
<a class="sourceLine" id="cb83-62" title="62">    print_array_structs( <span class="co">/*...*/</span> ) ;</a>
<a class="sourceLine" id="cb83-63" title="63"></a>
<a class="sourceLine" id="cb83-64" title="64"></a>
<a class="sourceLine" id="cb83-65" title="65">    <span class="co">// SORT THE ARRAY -- FIRST BY COUNTRY NAME</span></a>
<a class="sourceLine" id="cb83-66" title="66">    generic_insertion_sort( array_countries, num_countries, <span class="kw">sizeof</span>(<span class="kw">struct</span> map*) <span class="co">/*,...*/</span>) ; </a>
<a class="sourceLine" id="cb83-67" title="67"></a>
<a class="sourceLine" id="cb83-68" title="68">    <span class="co">// PRINT THE ARRAY AFTER FIRST SORT</span></a>
<a class="sourceLine" id="cb83-69" title="69">    print_array_structs( <span class="co">/*...*/</span> ) ;</a>
<a class="sourceLine" id="cb83-70" title="70"></a>
<a class="sourceLine" id="cb83-71" title="71"></a>
<a class="sourceLine" id="cb83-72" title="72">    <span class="co">// SORT THE ARRAY -- SECOND BY CAPITAL NAME</span></a>
<a class="sourceLine" id="cb83-73" title="73">    generic_insertion_sort( array_countries, num_countries, <span class="kw">sizeof</span>(<span class="kw">struct</span> map*) <span class="co">/*,...*/</span>) ; </a>
<a class="sourceLine" id="cb83-74" title="74"></a>
<a class="sourceLine" id="cb83-75" title="75">    <span class="co">// PRINT THE ARRAY AFTER SECOND SORT</span></a>
<a class="sourceLine" id="cb83-76" title="76">    print_array_structs( <span class="co">/*...*/</span> ) ;</a>
<a class="sourceLine" id="cb83-77" title="77"></a>
<a class="sourceLine" id="cb83-78" title="78">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb83-79" title="79">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb83-80" title="80">}</a></code></pre></div>
<h1 id="c-memory-model-data-structures-and-apis"><span class="header-section-number">6</span> C Memory Model, Data-structures, and APIs</h1>
<p>C presents some unique opportunities for how to structure your code and data-structures, but also requires that you’re careful about how data is passed around a program.</p>
<h2 id="memory-allocation-options"><span class="header-section-number">6.1</span> Memory Allocation Options</h2>
<p>In C, when creating a variable, you have the option of allocating it in one of multiple different types of memory:</p>
<ul>
<li>In another existing structure.</li>
<li>In the heap using <code>malloc</code> or its sibling functions.</li>
<li>In global memory.</li>
<li>On the stack.</li>
</ul>
<p>It might be surprising, but it is quite <em>uncommon</em> in programming languages to have this flexibility.</p>
<h3 id="internal-allocation"><span class="header-section-number">6.1.1</span> Internal Allocation</h3>
<p>What does it look like to do internal allocation of one struct or array inside of another? See the following as an example.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb84-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb84-2" title="2"></a>
<a class="sourceLine" id="cb84-3" title="3"><span class="kw">struct</span> bar {</a>
<a class="sourceLine" id="cb84-4" title="4">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb84-5" title="5"><span class="co">     * `arr` is allocated internally to `bar`, whereas `bytes` is a pointer to</span></a>
<a class="sourceLine" id="cb84-6" title="6"><span class="co">     * a separate allocation. `arr` must have a *fixed size*, and `bytes` does not</span></a>
<a class="sourceLine" id="cb84-7" title="7"><span class="co">     * because its allocation can be as large as you want!</span></a>
<a class="sourceLine" id="cb84-8" title="8"><span class="co">     */</span></a>
<a class="sourceLine" id="cb84-9" title="9">    <span class="dt">int</span> arr[<span class="dv">64</span>];</a>
<a class="sourceLine" id="cb84-10" title="10">    <span class="dt">unsigned</span> <span class="dt">char</span> *bytes;</a>
<a class="sourceLine" id="cb84-11" title="11">};</a>
<a class="sourceLine" id="cb84-12" title="12"></a>
<a class="sourceLine" id="cb84-13" title="13"><span class="kw">struct</span> foo {</a>
<a class="sourceLine" id="cb84-14" title="14">    <span class="co">/* The `bar` structure is allocated as *part of* the `struct foo` in `internal` */</span></a>
<a class="sourceLine" id="cb84-15" title="15">    <span class="kw">struct</span> bar internal;</a>
<a class="sourceLine" id="cb84-16" title="16">    <span class="co">/* But we can *also* allocate another `bar` separately if we&#39;d prefer */</span></a>
<a class="sourceLine" id="cb84-17" title="17">    <span class="kw">struct</span> bar *external;</a>
<a class="sourceLine" id="cb84-18" title="18">};</a>
<a class="sourceLine" id="cb84-19" title="19"></a>
<a class="sourceLine" id="cb84-20" title="20"><span class="dt">int</span></a>
<a class="sourceLine" id="cb84-21" title="21">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb84-22" title="22">{</a>
<a class="sourceLine" id="cb84-23" title="23">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb84-24" title="24"><span class="co">     * We didn&#39;t have to separately allocate the `struct bar internal` as</span></a>
<a class="sourceLine" id="cb84-25" title="25"><span class="co">     * it was allocated with the enclosing `a` allocation. However, we do have to</span></a>
<a class="sourceLine" id="cb84-26" title="26"><span class="co">     * allocate the `external` allocation. In both cases, we have access to a</span></a>
<a class="sourceLine" id="cb84-27" title="27"><span class="co">     * `struct bar` from within `struct foo`.</span></a>
<a class="sourceLine" id="cb84-28" title="28"><span class="co">     */</span></a>
<a class="sourceLine" id="cb84-29" title="29">    <span class="kw">struct</span> foo *a = malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> foo)); <span class="co">/* should check return value */</span></a>
<a class="sourceLine" id="cb84-30" title="30">    a-&gt;external   = malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> bar)); <span class="co">/* and this one ;-( */</span></a>
<a class="sourceLine" id="cb84-31" title="31"></a>
<a class="sourceLine" id="cb84-32" title="32">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb84-33" title="33"><span class="co">     * Note the difference in needing to use `-&gt;` when `external` is a pointer</span></a>
<a class="sourceLine" id="cb84-34" title="34"><span class="co">     * versus simply using `.` with `internal`.</span></a>
<a class="sourceLine" id="cb84-35" title="35"><span class="co">     */</span></a>
<a class="sourceLine" id="cb84-36" title="36">    a-&gt;internal.arr[<span class="dv">0</span>] = a-&gt;external-&gt;arr[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb84-37" title="37"></a>
<a class="sourceLine" id="cb84-38" title="38">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb84-39" title="39">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<p>One of the more interesting uses of internal allocation is in linked data-structures (e.g. like linked lists). It is common in languages like java to implement linked data-structures to have “nodes” that reference the data being tracked.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb86-1" title="1"><span class="co">// This could be made generic across the data types it could store by instead</span></a>
<a class="sourceLine" id="cb86-2" title="2"><span class="co">// using `class LinkedList&lt;T&gt;`, but I&#39;m keeping it simple here.</span></a>
<a class="sourceLine" id="cb86-3" title="3"><span class="kw">class</span> LinkedListOfStudents {</a>
<a class="sourceLine" id="cb86-4" title="4">    <span class="bu">Node</span> head;</a>
<a class="sourceLine" id="cb86-5" title="5"></a>
<a class="sourceLine" id="cb86-6" title="6">    <span class="kw">class</span> <span class="bu">Node</span> {</a>
<a class="sourceLine" id="cb86-7" title="7">        Student s;</a>
<a class="sourceLine" id="cb86-8" title="8">        <span class="bu">Node</span> next;</a>
<a class="sourceLine" id="cb86-9" title="9"></a>
<a class="sourceLine" id="cb86-10" title="10">        <span class="bu">Node</span>(Student s, <span class="bu">Node</span> next) {</a>
<a class="sourceLine" id="cb86-11" title="11">            <span class="kw">this</span>.<span class="fu">s</span>    = s;</a>
<a class="sourceLine" id="cb86-12" title="12">            <span class="kw">this</span>.<span class="fu">next</span> = next;</a>
<a class="sourceLine" id="cb86-13" title="13">        }</a>
<a class="sourceLine" id="cb86-14" title="14">    }</a>
<a class="sourceLine" id="cb86-15" title="15"></a>
<a class="sourceLine" id="cb86-16" title="16">    <span class="dt">void</span> <span class="fu">add</span>(Student s) {</a>
<a class="sourceLine" id="cb86-17" title="17">        <span class="co">// The program has *previously* allocated `data`.</span></a>
<a class="sourceLine" id="cb86-18" title="18">        <span class="co">// Now we have to additionally allocate the `node` separate from the data!</span></a>
<a class="sourceLine" id="cb86-19" title="19">        <span class="bu">Node</span> n = <span class="kw">new</span>(s, <span class="kw">this</span>.<span class="fu">head</span>);</a>
<a class="sourceLine" id="cb86-20" title="20"></a>
<a class="sourceLine" id="cb86-21" title="21">        <span class="kw">this</span>.<span class="fu">head</span> = n;</a>
<a class="sourceLine" id="cb86-22" title="22">    }</a>
<a class="sourceLine" id="cb86-23" title="23"></a>
<a class="sourceLine" id="cb86-24" title="24">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb86-25" title="25">}</a>
<a class="sourceLine" id="cb86-26" title="26"><span class="co">// This looks like the following. Note separate allocations for Node and Student</span></a>
<a class="sourceLine" id="cb86-27" title="27"><span class="co">//</span></a>
<a class="sourceLine" id="cb86-28" title="28"><span class="co">// head --&gt; Node------+    ,--&gt;Node-----+</span></a>
<a class="sourceLine" id="cb86-29" title="29"><span class="co">//          | s  next |---&#39;    | s next |---...</span></a>
<a class="sourceLine" id="cb86-30" title="30"><span class="co">//          +-|-------+        +-|------+</span></a>
<a class="sourceLine" id="cb86-31" title="31"><span class="co">//            v                  V</span></a>
<a class="sourceLine" id="cb86-32" title="32"><span class="co">//          Student-+           Student-+</span></a>
<a class="sourceLine" id="cb86-33" title="33"><span class="co">//          | ...   |           | ...   |</span></a>
<a class="sourceLine" id="cb86-34" title="34"><span class="co">//          +-------+           +-------+</span></a></code></pre></div>
<p>Lets see the same in C.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb87-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb87-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb87-3" title="3"></a>
<a class="sourceLine" id="cb87-4" title="4"><span class="kw">struct</span> linked_list_node {</a>
<a class="sourceLine" id="cb87-5" title="5">    <span class="dt">void</span> *data;</a>
<a class="sourceLine" id="cb87-6" title="6">    <span class="kw">struct</span> linked_list_node *next;</a>
<a class="sourceLine" id="cb87-7" title="7">};</a>
<a class="sourceLine" id="cb87-8" title="8"></a>
<a class="sourceLine" id="cb87-9" title="9"><span class="kw">struct</span> linked_list {</a>
<a class="sourceLine" id="cb87-10" title="10">    <span class="kw">struct</span> linked_list_node *head;</a>
<a class="sourceLine" id="cb87-11" title="11">};</a>
<a class="sourceLine" id="cb87-12" title="12"></a>
<a class="sourceLine" id="cb87-13" title="13"><span class="kw">struct</span> student {</a>
<a class="sourceLine" id="cb87-14" title="14">    <span class="co">// student data here...</span></a>
<a class="sourceLine" id="cb87-15" title="15">    <span class="kw">struct</span> linked_list_node list;</a>
<a class="sourceLine" id="cb87-16" title="16">};</a>
<a class="sourceLine" id="cb87-17" title="17"></a>
<a class="sourceLine" id="cb87-18" title="18"><span class="dt">void</span></a>
<a class="sourceLine" id="cb87-19" title="19">add(<span class="kw">struct</span> linked_list *ll, <span class="kw">struct</span> linked_list_node *n, <span class="dt">void</span> *data)</a>
<a class="sourceLine" id="cb87-20" title="20">{</a>
<a class="sourceLine" id="cb87-21" title="21">    n-&gt;next  = ll-&gt;head;</a>
<a class="sourceLine" id="cb87-22" title="22">    n-&gt;data  = data;</a>
<a class="sourceLine" id="cb87-23" title="23">    ll-&gt;head = n;</a>
<a class="sourceLine" id="cb87-24" title="24">}</a>
<a class="sourceLine" id="cb87-25" title="25"></a>
<a class="sourceLine" id="cb87-26" title="26"><span class="kw">struct</span> linked_list l;</a>
<a class="sourceLine" id="cb87-27" title="27"></a>
<a class="sourceLine" id="cb87-28" title="28"><span class="dt">int</span></a>
<a class="sourceLine" id="cb87-29" title="29">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb87-30" title="30">{</a>
<a class="sourceLine" id="cb87-31" title="31">    <span class="kw">struct</span> student *s = malloc(<span class="kw">sizeof</span>(<span class="kw">struct</span> student));</a>
<a class="sourceLine" id="cb87-32" title="32">    <span class="co">/* Should check that `s != NULL`... */</span></a>
<a class="sourceLine" id="cb87-33" title="33">    add(&amp;l, &amp;s-&gt;list, s); <span class="co">/* note that `&amp;s-&gt;list` is the same as `&amp;(s-&gt;list)` */</span></a>
<a class="sourceLine" id="cb87-34" title="34"></a>
<a class="sourceLine" id="cb87-35" title="35">    printf(<span class="st">&quot;student added to list!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb87-36" title="36"></a>
<a class="sourceLine" id="cb87-37" title="37">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb87-38" title="38">}</a>
<a class="sourceLine" id="cb87-39" title="39"></a>
<a class="sourceLine" id="cb87-40" title="40"><span class="co">/*</span></a>
<a class="sourceLine" id="cb87-41" title="41"><span class="co"> * This looks something like the following. Linked list is *internal* to student.</span></a>
<a class="sourceLine" id="cb87-42" title="42"><span class="co"> *</span></a>
<a class="sourceLine" id="cb87-43" title="43"><span class="co"> * head ----&gt; student-+     ,-&gt; student-+</span></a>
<a class="sourceLine" id="cb87-44" title="44"><span class="co"> *            | ...   |    ,    | ...   |</span></a>
<a class="sourceLine" id="cb87-45" title="45"><span class="co"> *            | next  |---&#39;     | next  |--&gt; NULL</span></a>
<a class="sourceLine" id="cb87-46" title="46"><span class="co"> *            +-------+         +-------+</span></a>
<a class="sourceLine" id="cb87-47" title="47"><span class="co"> */</span></a></code></pre></div>
<p>Program output:</p>
<pre><code>student added to list!</code></pre>
<p>A few interesting things happened here:</p>
<ol type="1">
<li>We’re using <code>void *</code> pointers within the <code>linked_list_node</code> so that the linked list can hold data of <em>any pointer type</em>. You can see that in our list implementation, there is nothing that is <code>student</code>-specific.</li>
<li>The <code>list</code> is inline-allocated inside the <code>student</code> structure, which completely avoids the separate <code>node</code> allocation.</li>
</ol>
<p>Most serious data-structure implementations enable this inlining of data-structure nodes even without requiring the <code>data</code> pointer in the node. We won’t cover that, but you can <a href="https://github.com/gwsystems/ps/blob/master/ps_list.h">see a sample implementation</a>.</p>
<h3 id="heap-allocation"><span class="header-section-number">6.1.2</span> Heap Allocation</h3>
<p>We’ve already seen <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, and <code>free</code> which are our interface to the heap. These provide the most flexibility, but require that you track the memory and <code>free</code> it appropriately<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<h3 id="global-allocation"><span class="header-section-number">6.1.3</span> Global Allocation</h3>
<p>We have already seen global allocations frequently in examples so far.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb89-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb89-2" title="2"></a>
<a class="sourceLine" id="cb89-3" title="3"><span class="co">/* A globally allocated array! No `malloc` needed! */</span></a>
<a class="sourceLine" id="cb89-4" title="4"><span class="dt">int</span> arr[<span class="dv">64</span>];</a>
<a class="sourceLine" id="cb89-5" title="5"><span class="kw">struct</span> foo {</a>
<a class="sourceLine" id="cb89-6" title="6">    <span class="dt">int</span> a, b;</a>
<a class="sourceLine" id="cb89-7" title="7">    <span class="kw">struct</span> foo *next;</a>
<a class="sourceLine" id="cb89-8" title="8">};</a>
<a class="sourceLine" id="cb89-9" title="9"><span class="co">/* A globally allocated structure! */</span></a>
<a class="sourceLine" id="cb89-10" title="10"><span class="kw">struct</span> foo s;</a>
<a class="sourceLine" id="cb89-11" title="11"></a>
<a class="sourceLine" id="cb89-12" title="12"><span class="co">/* Globally allocated *and* initialized integer... */</span></a>
<a class="sourceLine" id="cb89-13" title="13"><span class="dt">int</span> c = <span class="dv">12</span>;</a>
<a class="sourceLine" id="cb89-14" title="14"><span class="co">/* ...and array. */</span></a>
<a class="sourceLine" id="cb89-15" title="15"><span class="dt">long</span> d[] = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>};</a>
<a class="sourceLine" id="cb89-16" title="16"></a>
<a class="sourceLine" id="cb89-17" title="17"><span class="dt">int</span></a>
<a class="sourceLine" id="cb89-18" title="18">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb89-19" title="19">{</a>
<a class="sourceLine" id="cb89-20" title="20">    printf(<span class="st">&quot;What is uninitialized global memory set to?</span><span class="sc">\n</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb89-21" title="21">           <span class="st">&quot;Integer: %d</span><span class="sc">\n</span><span class="st">Pointer: %p (as hex: %lx)</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb89-22" title="22">           arr[<span class="dv">0</span>], s.next, (<span class="dt">unsigned</span> <span class="dt">long</span>)s.next);</a>
<a class="sourceLine" id="cb89-23" title="23">    <span class="co">/* Note that we use `.` to access the fields because `s` is not a pointer! */</span></a>
<a class="sourceLine" id="cb89-24" title="24"></a>
<a class="sourceLine" id="cb89-25" title="25">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb89-26" title="26">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>What is uninitialized global memory set to?
Integer: 0
Pointer: (nil) (as hex: 0)</code></pre>
<p>Global variables are either initialized where they are defined, or are initialized to <code>0</code>. Note that they are intialized to all <code>0</code>s regardless their type. This makes more sense than it sounds because pointers set to <code>0</code> are <code>NULL</code> (because, recall, <code>NULL</code> is just <code>(void *)0</code> – see the “hex” output above), and because strings (see later) are terminated by <code>\0</code> which is also <code>0</code>! Thus, this policy initializes all numerical data to <code>0</code>, all pointers to <code>NULL</code>, and all strings to <code>""</code>.</p>
<h3 id="stack-allocation"><span class="header-section-number">6.1.4</span> Stack Allocation</h3>
<p>Variables can also be allocated <em>on the stack</em>. This effectively means that as you’re executing in a function, variables can be allocated within the context/memory of that function. An example that allocates a structure and an array on the stack:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb91-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb91-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb91-3" title="3"></a>
<a class="sourceLine" id="cb91-4" title="4"><span class="pp">#define ARR_SZ 12</span></a>
<a class="sourceLine" id="cb91-5" title="5"></a>
<a class="sourceLine" id="cb91-6" title="6"><span class="co">/*</span></a>
<a class="sourceLine" id="cb91-7" title="7"><span class="co"> * Find an integer in the array, reset it to `0`, and return its offset.</span></a>
<a class="sourceLine" id="cb91-8" title="8"><span class="co"> * Nothing very interesting here.</span></a>
<a class="sourceLine" id="cb91-9" title="9"><span class="co"> */</span></a>
<a class="sourceLine" id="cb91-10" title="10"><span class="dt">int</span></a>
<a class="sourceLine" id="cb91-11" title="11">find_and_reset(<span class="dt">int</span> *arr, <span class="dt">int</span> val)</a>
<a class="sourceLine" id="cb91-12" title="12">{</a>
<a class="sourceLine" id="cb91-13" title="13">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb91-14" title="14"></a>
<a class="sourceLine" id="cb91-15" title="15">    <span class="co">/* find the value */</span></a>
<a class="sourceLine" id="cb91-16" title="16">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; ARR_SZ; i++) {</a>
<a class="sourceLine" id="cb91-17" title="17">        <span class="cf">if</span> (arr[i] == val) {</a>
<a class="sourceLine" id="cb91-18" title="18">            arr[i] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb91-19" title="19">            <span class="cf">return</span> i;</a>
<a class="sourceLine" id="cb91-20" title="20">        }</a>
<a class="sourceLine" id="cb91-21" title="21">    }</a>
<a class="sourceLine" id="cb91-22" title="22">    <span class="co">/* Couldn&#39;t find it! */</span></a>
<a class="sourceLine" id="cb91-23" title="23">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb91-24" title="24">}</a>
<a class="sourceLine" id="cb91-25" title="25"></a>
<a class="sourceLine" id="cb91-26" title="26"><span class="dt">int</span></a>
<a class="sourceLine" id="cb91-27" title="27">fib(<span class="dt">int</span> v)</a>
<a class="sourceLine" id="cb91-28" title="28">{</a>
<a class="sourceLine" id="cb91-29" title="29">    <span class="co">/* Allocate an array onto the stack */</span></a>
<a class="sourceLine" id="cb91-30" title="30">    <span class="dt">int</span> fibs[ARR_SZ] = {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">13</span>, <span class="dv">21</span>, <span class="dv">34</span>, <span class="dv">55</span>, <span class="dv">89</span>}; <span class="co">/* looks like a suspicious sequence... */</span></a>
<a class="sourceLine" id="cb91-31" title="31">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb91-32" title="32"></a>
<a class="sourceLine" id="cb91-33" title="33">    ret = find_and_reset(fibs, v);</a>
<a class="sourceLine" id="cb91-34" title="34">    <span class="co">/* should have been set to `0`, so this should return `-1` */</span></a>
<a class="sourceLine" id="cb91-35" title="35">    assert(find_and_reset(fibs, v) == -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb91-36" title="36"></a>
<a class="sourceLine" id="cb91-37" title="37">    <span class="cf">return</span> ret;</a>
<a class="sourceLine" id="cb91-38" title="38">}</a>
<a class="sourceLine" id="cb91-39" title="39"></a>
<a class="sourceLine" id="cb91-40" title="40"><span class="dt">int</span></a>
<a class="sourceLine" id="cb91-41" title="41">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb91-42" title="42">{</a>
<a class="sourceLine" id="cb91-43" title="43">    printf(<span class="st">&quot;Should find 8 @ 6: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, fib(<span class="dv">8</span>));</a>
<a class="sourceLine" id="cb91-44" title="44">    <span class="co">/* if the array was the same array for these two calls, it would be found at offset -1 (error) */</span></a>
<a class="sourceLine" id="cb91-45" title="45">    printf(<span class="st">&quot;Should find 8 @ 6: %d (-1 is wrong here)</span><span class="sc">\n</span><span class="st">&quot;</span>, fib(<span class="dv">8</span>));</a>
<a class="sourceLine" id="cb91-46" title="46"></a>
<a class="sourceLine" id="cb91-47" title="47">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb91-48" title="48">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Should find 8 @ 6: 6
Should find 8 @ 6: 6 (-1 is wrong here)</code></pre>
<p>Key points to realize:</p>
<ul>
<li><code>fibs</code> in <code>fib</code> is allocated <em>on the stack</em> and is initialized in <code>fib</code>!</li>
<li>We are passing the array into <code>find_and_reset</code> which modifies the array directly as it is passed as a pointer.</li>
<li>The first time that <code>fib</code> is called, it creates the <code>arr</code>. After we <em>return</em> from <code>fib</code>, the <code>fibs</code> goes away (strictly: its memory is reclaimed as part of returning from <code>fib</code>).</li>
<li>The second time we call <code>fib</code>, it effectively is a <em>new</em> execution of <code>fib</code>, thus a <em>new</em> allocation of <code>fibs</code> that is now initialized a second time.</li>
</ul>
<h4 id="stack-usage-example"><span class="header-section-number">6.1.4.1</span> Stack Usage Example</h4>
<p>How do we think about this? The stack starts out in <code>main</code>:</p>
<pre><code>stack          |
|              |
+-main---------+
|              | &lt;--- main&#39;s local data (note: no local variables)
+--------------+</code></pre>
<p>What we’re drawing here is a “<em>stack frame</em>” for the <code>main</code> function. This includes all of the local data allocated within the function, and (at least conceptually) also includes the arguments passed into the function (<code>main</code> has none). When it calls <code>fib</code>, a stack frame is allocated for <code>fib</code>, the argument is passed in, and <code>fib</code>s variables are allocated:</p>
<pre><code>stack          |
|              |
+-main---------+
|              |
+-fib----------+
| arg: v       | &lt;--- argument to fib
| fibs[ARR_SZ] | &lt;-+- local variables, allocated here!
| ret          | &lt;-&#39;
+--------------+</code></pre>
<p><code>fib</code> calls <code>find_and_reset</code>:</p>
<pre><code>stack          |
|              |
+-main---------+
|              |
+-fib----------+
| v            |
| fibs[ARR_SZ] |&lt;--+
| ret          |   | pointer to fibs passed as argument, and used to update arr[v]
+find_and_reset+   |
| arg: arr     |---+
| arg: val     |
| i            |
+--------------+</code></pre>
<p>Since <code>find_and_reset</code> updates the array in <code>fib</code>’s stack frame, when it returns, the array is still properly updated. Importantly, once we return to <code>main</code>, we have deallocated all of the variables from the previous call to <code>fib</code>…</p>
<pre><code>stack          |
|              |
+-main---------+
|              | &lt;--- returning to main, deallocates the fibs array in fib
+--------------+</code></pre>
<p>…thus the next call to <code>fib</code> allocates a <em>new</em> set of local variables including <code>fibs</code>.</p>
<pre><code>stack          |
|              |
+-main---------+
|              |
+-fib----------+
| arg: v       |
| fibs[ARR_SZ] | &lt;--- new version of fibs, re-initialized when we fib is called
| ret          |
+--------------+</code></pre>
<h4 id="common-errors-in-stack-allocation"><span class="header-section-number">6.1.4.2</span> Common Errors in Stack Allocation</h4>
<p>A few common errors with stack allocation include:</p>
<ul>
<li><em>Uninitialized variables.</em> You must <em>always</em> initialize all variables allocated on the stack, otherwise they can contain seemingly random values (see below).</li>
<li><em>Pointers to stack allocated variables after return.</em> After a function returns, its stack allocated variables are no longer valid (they were deallocated upon <code>return</code>). Any pointers that remain to any of those variables are no longer pointing to valid memory!</li>
</ul>
<p>We discuss these next.</p>
<p><strong>Initializing stack-allocated variables.</strong> For global memory, we saw that variables, if not intentionally initialized, would be set to <code>0</code>. This is <em>not</em> the case with stack allocated variables. In fact, the answer is “it depends”. If you compile your code without optimizations, stack allocated variables will be initialized to <code>0</code>; if you compile with optimizations, they are <em>not</em> initialized. Yikes. Thus, we must assume that they are not automatically initialized (similar to the memory returned from <code>malloc</code>). An example:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb98-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb98-2" title="2"></a>
<a class="sourceLine" id="cb98-3" title="3"><span class="dt">void</span></a>
<a class="sourceLine" id="cb98-4" title="4">foo(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb98-5" title="5">{</a>
<a class="sourceLine" id="cb98-6" title="6">    <span class="co">/* don&#39;t manually initialize anything here */</span></a>
<a class="sourceLine" id="cb98-7" title="7">    <span class="dt">int</span> arr[<span class="dv">12</span>];</a>
<a class="sourceLine" id="cb98-8" title="8">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb98-9" title="9"></a>
<a class="sourceLine" id="cb98-10" title="10">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">12</span>; i++) {</a>
<a class="sourceLine" id="cb98-11" title="11">        printf(<span class="st">&quot;%d: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, i, arr[i]);</a>
<a class="sourceLine" id="cb98-12" title="12">    }</a>
<a class="sourceLine" id="cb98-13" title="13">}</a>
<a class="sourceLine" id="cb98-14" title="14"></a>
<a class="sourceLine" id="cb98-15" title="15"><span class="dt">int</span></a>
<a class="sourceLine" id="cb98-16" title="16">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb98-17" title="17">{</a>
<a class="sourceLine" id="cb98-18" title="18">    foo();</a>
<a class="sourceLine" id="cb98-19" title="19"></a>
<a class="sourceLine" id="cb98-20" title="20">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb98-21" title="21">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>0: 194
1: 0
2: -1713494585
3: 32766
4: -1713494586
5: 32766
6: 947651133
7: 22019
8: 310096616
9: 32754
10: 947651056
11: 22019</code></pre>
<p>Yikes. We’re getting random values in the array! Where do you think these values came from?</p>
<p><strong>References to stack variables after function return.</strong></p>
<div class="sourceCode" id="cb100"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb100-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb100-2" title="2"></a>
<a class="sourceLine" id="cb100-3" title="3"><span class="dt">unsigned</span> <span class="dt">long</span> *ptr;</a>
<a class="sourceLine" id="cb100-4" title="4"></a>
<a class="sourceLine" id="cb100-5" title="5"><span class="dt">unsigned</span> <span class="dt">long</span> *</a>
<a class="sourceLine" id="cb100-6" title="6">bar(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb100-7" title="7">{</a>
<a class="sourceLine" id="cb100-8" title="8">    <span class="dt">unsigned</span> <span class="dt">long</span> a = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb100-9" title="9"></a>
<a class="sourceLine" id="cb100-10" title="10">    <span class="cf">return</span> &amp;a;            <span class="co">/* Return the address of a local variable. */</span></a>
<a class="sourceLine" id="cb100-11" title="11">}</a>
<a class="sourceLine" id="cb100-12" title="12"></a>
<a class="sourceLine" id="cb100-13" title="13"><span class="dt">void</span></a>
<a class="sourceLine" id="cb100-14" title="14">foo(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb100-15" title="15">{</a>
<a class="sourceLine" id="cb100-16" title="16">    <span class="dt">unsigned</span> <span class="dt">long</span> a = <span class="dv">42</span>; <span class="co">/* Allocate `a` on the stack here... */</span></a>
<a class="sourceLine" id="cb100-17" title="17"></a>
<a class="sourceLine" id="cb100-18" title="18">    ptr = &amp;a;             <span class="co">/* ...and set the global pointer to point to it... */</span></a>
<a class="sourceLine" id="cb100-19" title="19"></a>
<a class="sourceLine" id="cb100-20" title="20">    <span class="cf">return</span>;               <span class="co">/* ...but then we deallocate `a` when we return. */</span></a>
<a class="sourceLine" id="cb100-21" title="21">}</a>
<a class="sourceLine" id="cb100-22" title="22"></a>
<a class="sourceLine" id="cb100-23" title="23"><span class="dt">int</span></a>
<a class="sourceLine" id="cb100-24" title="24">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb100-25" title="25">{</a>
<a class="sourceLine" id="cb100-26" title="26">    <span class="dt">unsigned</span> <span class="dt">long</span> val;</a>
<a class="sourceLine" id="cb100-27" title="27"></a>
<a class="sourceLine" id="cb100-28" title="28">    foo();</a>
<a class="sourceLine" id="cb100-29" title="29">    printf(<span class="st">&quot;Save address of local variable, and dereference it: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, *ptr);</a>
<a class="sourceLine" id="cb100-30" title="30">    fflush(stdout); <span class="co">/* ignore this ;-) magic sprinkles here */</span></a>
<a class="sourceLine" id="cb100-31" title="31">    ptr = bar();</a>
<a class="sourceLine" id="cb100-32" title="32">    printf(<span class="st">&quot;Return address of local variable, and dereference it: %lu</span><span class="sc">\n</span><span class="st">&quot;</span>, *ptr);</a>
<a class="sourceLine" id="cb100-33" title="33"></a>
<a class="sourceLine" id="cb100-34" title="34">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb100-35" title="35">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c: In function bar:
inline_exec_tmp.c:10:9: warning: function returns address of local variable [-Wreturn-local-addr]
   10 |  return &amp;a;            /* Return the address of a local variable. */
      |         ^~
Save address of local variable, and dereference it: 42
make[1]: *** [Makefile:30: inline_exec] Segmentation fault</code></pre>
<p>You can see a few interesting facts from the output.</p>
<ol type="1">
<li>The value referenced by <code>*ptr</code> after <code>foo</code> is a random value, and dereferencing the return value from<code>bar</code> causes a segmentation fault.</li>
<li><code>foo</code> and <code>bar</code> contain logic that feels pretty identical. In either case, they are taking a local variable, and passing its address to <code>main</code> where it is used. <code>foo</code> passed it through a global variable, and <code>bar</code> simply returns the address. Despite this, one of them causes a segmentation fault, and the other seems to return a nonsensical value! When you try and use stack allocated variables after they are been freed (by their function returning), you get <em>unpredictable</em> results.</li>
<li>The C compiler is aggressive about issuing warnings as it can tell that bad things are afoot. Warnings are your friend and you <em>must</em> do your development with them enabled.</li>
</ol>
<p>Stack allocation is powerful, can be quite useful. However, you have to always be careful that stack allocated variables are never added into global data-structures, and are never returned.</p>
<h3 id="putting-it-all-together"><span class="header-section-number">6.1.5</span> Putting it all Together</h3>
<p>Lets look at an example that uses inlined, global, and stack allocation. We’ll avoid heap-based allocation to demonstrate the less normal memory allocation options in C.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb102-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb102-2" title="2"><span class="pp">#include </span><span class="im">&lt;search.h&gt;</span></a>
<a class="sourceLine" id="cb102-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb102-4" title="4"></a>
<a class="sourceLine" id="cb102-5" title="5"><span class="kw">struct</span> kv_entry {</a>
<a class="sourceLine" id="cb102-6" title="6">    <span class="dt">unsigned</span> <span class="dt">long</span> key;</a>
<a class="sourceLine" id="cb102-7" title="7">    <span class="dt">char</span> *value;</a>
<a class="sourceLine" id="cb102-8" title="8">};</a>
<a class="sourceLine" id="cb102-9" title="9"></a>
<a class="sourceLine" id="cb102-10" title="10"><span class="kw">struct</span> kv_store {</a>
<a class="sourceLine" id="cb102-11" title="11">    <span class="co">/* internal allocation of the key-value store&#39;s entries */</span></a>
<a class="sourceLine" id="cb102-12" title="12">    <span class="kw">struct</span> kv_entry entries[<span class="dv">16</span>];</a>
<a class="sourceLine" id="cb102-13" title="13">    <span class="dt">size_t</span> num_entries;</a>
<a class="sourceLine" id="cb102-14" title="14">};</a>
<a class="sourceLine" id="cb102-15" title="15"></a>
<a class="sourceLine" id="cb102-16" title="16"><span class="dt">int</span></a>
<a class="sourceLine" id="cb102-17" title="17">kv_comp(<span class="dt">const</span> <span class="dt">void</span> *a, <span class="dt">const</span> <span class="dt">void</span> *b)</a>
<a class="sourceLine" id="cb102-18" title="18">{</a>
<a class="sourceLine" id="cb102-19" title="19">    <span class="dt">const</span> <span class="kw">struct</span> kv_entry *a_ent = a;</a>
<a class="sourceLine" id="cb102-20" title="20">    <span class="dt">const</span> <span class="kw">struct</span> kv_entry *b_ent = b;</a>
<a class="sourceLine" id="cb102-21" title="21"></a>
<a class="sourceLine" id="cb102-22" title="22">    <span class="co">/* Compare keys, and return `0` if they are the same */</span></a>
<a class="sourceLine" id="cb102-23" title="23">    <span class="cf">return</span> !(a_ent-&gt;key == b_ent-&gt;key);</a>
<a class="sourceLine" id="cb102-24" title="24">}</a>
<a class="sourceLine" id="cb102-25" title="25"></a>
<a class="sourceLine" id="cb102-26" title="26"><span class="dt">int</span></a>
<a class="sourceLine" id="cb102-27" title="27">put(<span class="kw">struct</span> kv_store *store, <span class="dt">unsigned</span> <span class="dt">long</span> key, <span class="dt">char</span> *value)</a>
<a class="sourceLine" id="cb102-28" title="28">{</a>
<a class="sourceLine" id="cb102-29" title="29">    <span class="co">/* Allocate a structure on the stack! */</span></a>
<a class="sourceLine" id="cb102-30" title="30">    <span class="kw">struct</span> kv_entry ent = {</a>
<a class="sourceLine" id="cb102-31" title="31">        .key = key,</a>
<a class="sourceLine" id="cb102-32" title="32">        .value = value</a>
<a class="sourceLine" id="cb102-33" title="33">    };</a>
<a class="sourceLine" id="cb102-34" title="34">    <span class="kw">struct</span> kv_entry *new_ent;</a>
<a class="sourceLine" id="cb102-35" title="35">    <span class="co">/* Should check if the kv_store has open entries. */</span></a>
<a class="sourceLine" id="cb102-36" title="36"></a>
<a class="sourceLine" id="cb102-37" title="37">    <span class="co">/* Notice we have to pass the `&amp;ent` as a pointer is expected */</span></a>
<a class="sourceLine" id="cb102-38" title="38">    new_ent = lsearch(&amp;ent, store-&gt;entries, &amp;store-&gt;num_entries, <span class="kw">sizeof</span>(<span class="kw">struct</span> kv_entry), kv_comp);</a>
<a class="sourceLine" id="cb102-39" title="39">    <span class="co">/* Should check if we found an old entry, and we need to update its value. */</span></a>
<a class="sourceLine" id="cb102-40" title="40"></a>
<a class="sourceLine" id="cb102-41" title="41">    <span class="cf">if</span> (new_ent == NULL) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb102-42" title="42"></a>
<a class="sourceLine" id="cb102-43" title="43">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb102-44" title="44">}</a>
<a class="sourceLine" id="cb102-45" title="45"></a>
<a class="sourceLine" id="cb102-46" title="46"><span class="dt">int</span></a>
<a class="sourceLine" id="cb102-47" title="47">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb102-48" title="48">{</a>
<a class="sourceLine" id="cb102-49" title="49">    <span class="co">/* Allocated the data-store on the stack, including the array! */</span></a>
<a class="sourceLine" id="cb102-50" title="50">    <span class="kw">struct</span> kv_store store = { .num_entries = <span class="dv">0</span> };</a>
<a class="sourceLine" id="cb102-51" title="51"></a>
<a class="sourceLine" id="cb102-52" title="52">    <span class="dt">unsigned</span> <span class="dt">long</span> key = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb102-53" title="53">    <span class="dt">char</span> *value = <span class="st">&quot;secret to everything&quot;</span>;</a>
<a class="sourceLine" id="cb102-54" title="54">    put(&amp;store, key, value);</a>
<a class="sourceLine" id="cb102-55" title="55"></a>
<a class="sourceLine" id="cb102-56" title="56">    <span class="co">/* Validate that the store got modified in the appropriate way */</span></a>
<a class="sourceLine" id="cb102-57" title="57">    assert(store.num_entries == <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb102-58" title="58">    assert(store.entries[<span class="dv">0</span>].key == key);</a>
<a class="sourceLine" id="cb102-59" title="59"></a>
<a class="sourceLine" id="cb102-60" title="60">    printf(<span class="st">&quot;%ld is the %s</span><span class="sc">\n</span><span class="st">&quot;</span>, store.entries[<span class="dv">0</span>].key, store.entries[<span class="dv">0</span>].value);</a>
<a class="sourceLine" id="cb102-61" title="61"></a>
<a class="sourceLine" id="cb102-62" title="62">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb102-63" title="63">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>42 is the secret to everything</code></pre>
<p>In this program you might notice that we’ve used <em>no dynamic memory allocation at all</em>! The cost of this is that we had to create a key-value store of only a fixed size (<code>16</code> items, here).</p>
<h3 id="comparing-c-to-java"><span class="header-section-number">6.1.6</span> Comparing C to Java</h3>
<p>C enables a high-degree of control in which memory different variables should be placed. Java traditionally has simple rules for which memory is used for variables:</p>
<ul>
<li><em><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive types</a></em> are stored in objects and on the stack.</li>
<li><em>Objects</em> are always allocated using <code>new</code> in the heap, and references to objects are always pointers.</li>
<li>The heap is managed by the garbage collector, thus avoiding the need for <code>free</code>.</li>
</ul>
<p>Many aspects of this are absolutely fantastic:</p>
<ul>
<li>The programmer doesn’t need to think about how long the memory for an object needs to stick around – the garbage collector instead manages deallocation.</li>
<li>The syntax for accessing fields in objects is uniform and simple: always use a <code>.</code> to access a field (e.g. <code>obj.a</code>) – all object references are pointers, so instead of having <code>-&gt;</code> everywhere, just replace it with the uniform <code>.</code>.</li>
</ul>
<p>However, there are significant downsides when the goal is to write systems code:</p>
<ul>
<li>Some systems don’t have a heap! Many embedded (small) systems don’t support dynamic allocation.</li>
<li>Garbage collection (GC) isn’t free! It has some overhead for some applications, can result in larger memory consumption (as garbage is waiting to be collected), and can causes delays in processing when GC happens. That said, modern GC is pretty amazing and does a pretty good job at minimizing all of these factors.</li>
<li>Many data-structures that might be allocated globally or on the stack, instead must be allocated on the heap, which is slower. Similarly, many objects might want other objects to be part of their allocation, but that isn’t possible as each must be a separate heap allocation, which adds overhead.</li>
</ul>
<h2 id="strings"><span class="header-section-number">6.2</span> Strings</h2>
<p>String don’t have a dedicated type in C – there is no <code>String</code> type. Strings are</p>
<ol type="1">
<li>arrays of <code>char</code>s,</li>
<li>with a null-terminator (<code>\0</code>) character in the last array position to denote the termination of the string.</li>
</ol>
<p>In memory, a simple string has this representation:</p>
<pre><code>char *str = &quot;hi!&quot;

str ---&gt; +---+---+---+---+
         | h | i | ! |\0 |
         +---+---+---+---+</code></pre>
<p>Note that <code>\0</code> is a single character even though it looks like two. We can see this:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb105-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb105-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb105-3" title="3"></a>
<a class="sourceLine" id="cb105-4" title="4"><span class="dt">int</span></a>
<a class="sourceLine" id="cb105-5" title="5">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb105-6" title="6">{</a>
<a class="sourceLine" id="cb105-7" title="7">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb105-8" title="8">    <span class="dt">char</span> *str = <span class="st">&quot;hi!&quot;</span>;</a>
<a class="sourceLine" id="cb105-9" title="9">    <span class="dt">char</span> str2[<span class="dv">4</span>] = {<span class="ch">&#39;h&#39;</span>, <span class="ch">&#39;i&#39;</span>, <span class="ch">&#39;!&#39;</span>, &#39;\<span class="dv">0</span><span class="er">&#39;</span>};        <span class="co">/* We can allocate strings on the stack! */</span></a>
<a class="sourceLine" id="cb105-10" title="10"></a>
<a class="sourceLine" id="cb105-11" title="11">    <span class="cf">for</span> (i = <span class="dv">0</span>; str[i] != &#39;\<span class="dv">0</span><span class="er">&#39;</span>; i++) {           <span class="co">/* Loop till we find the null-terminator */</span></a>
<a class="sourceLine" id="cb105-12" title="12">        assert(str[i] == str2[i]);               <span class="co">/* Verify the strings are the same. */</span></a>
<a class="sourceLine" id="cb105-13" title="13">        printf(<span class="st">&quot;%c&quot;</span>, str[i]);</a>
<a class="sourceLine" id="cb105-14" title="14">    }</a>
<a class="sourceLine" id="cb105-15" title="15">    assert(str[<span class="dv">3</span>] == str2[<span class="dv">3</span>] &amp;&amp; str[<span class="dv">3</span>] == &#39;\<span class="dv">0</span><span class="er">&#39;</span>); <span class="co">/* Explicitly check that the null-terminator is there */</span></a>
<a class="sourceLine" id="cb105-16" title="16">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb105-17" title="17">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>hi!</code></pre>
<p>So strings aren’t really all that special in C. They’re just arrays with a special terminating character, and a little bit of syntax support to construct them (i.e. <code>"this syntax"</code>). So what’s there to know about strings in C?</p>
<h3 id="string.h-functions"><span class="header-section-number">6.2.1</span> <code>string.h</code> Functions</h3>
<p>Working with strings is <em>not</em> C’s strong point. However, you have to handle strings in every language, and C provides a number of functions to do so. You can read about each of these <code>function</code>s with <code>man 3 &lt;function&gt;</code>.</p>
<h4 id="core-string-operations"><span class="header-section-number">6.2.1.1</span> Core String Operations</h4>
<ul>
<li><code>strlen</code> - How many characters is a string (not including the null-terminator)?</li>
<li><code>strcmp</code> - Compare two strings, return <code>0</code> if they are the same, or <code>-1</code> or <code>1</code>, depending on which is <a href="https://en.wikipedia.org/wiki/Lexicographic_order">lexographically less than the other</a>. Similar in purpose to <code>equals</code> in Java.</li>
<li><code>strcpy</code> - Copy into a string the contents of another string.</li>
<li><code>strcat</code> - Concatenate, or append onto the end of a string, another string.</li>
<li><code>strdup</code> - Duplicate a string by <code>malloc</code>ing a new string, and copying the string into it (you have to <code>free</code> the string later!).</li>
<li><code>snprintf</code> - You’re familiar with <code>printf</code>, but <code>snprintf</code> enables you to “print” into a string! This gives you a lot of flexibility in easily constructing strings. A downside is that you don’t really know how big the resulting string is, so the <code>n</code> in the name is the maximum length of the string you’re creating.</li>
</ul>
<div class="sourceCode" id="cb107"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb107-1" title="1"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb107-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb107-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb107-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb107-5" title="5"></a>
<a class="sourceLine" id="cb107-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb107-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb107-8" title="8">{</a>
<a class="sourceLine" id="cb107-9" title="9">    <span class="dt">char</span> result[<span class="dv">256</span>] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>, };                <span class="co">/* initialize string to be &quot;&quot; */</span></a>
<a class="sourceLine" id="cb107-10" title="10">    <span class="dt">char</span> *a = <span class="st">&quot;hello&quot;</span>, *b = <span class="st">&quot;world&quot;</span>;</a>
<a class="sourceLine" id="cb107-11" title="11">    <span class="dt">int</span> c = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb107-12" title="12">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb107-13" title="13">    <span class="dt">char</span> *d;</a>
<a class="sourceLine" id="cb107-14" title="14"></a>
<a class="sourceLine" id="cb107-15" title="15">    assert(strcmp(a, b) != <span class="dv">0</span>);                  <span class="co">/* these strings are different */</span></a>
<a class="sourceLine" id="cb107-16" title="16"></a>
<a class="sourceLine" id="cb107-17" title="17">    strcat(result, a);</a>
<a class="sourceLine" id="cb107-18" title="18">    strcat(result, <span class="st">&quot; &quot;</span>);</a>
<a class="sourceLine" id="cb107-19" title="19">    strcat(result, b);</a>
<a class="sourceLine" id="cb107-20" title="20">    assert(strcmp(result, <span class="st">&quot;hello world&quot;</span>) == <span class="dv">0</span>); <span class="co">/* should have constructed this string properly */</span></a>
<a class="sourceLine" id="cb107-21" title="21"></a>
<a class="sourceLine" id="cb107-22" title="22">    d = strdup(result);</a>
<a class="sourceLine" id="cb107-23" title="23">    assert(strcmp(d, result) == <span class="dv">0</span>);             <span class="co">/* a duplicate should be equal */</span></a>
<a class="sourceLine" id="cb107-24" title="24">    free(d);</a>
<a class="sourceLine" id="cb107-25" title="25"></a>
<a class="sourceLine" id="cb107-26" title="26">    strcpy(result, <span class="st">&quot;&quot;</span>);                         <span class="co">/* reset the `result` to an empty string */</span></a>
<a class="sourceLine" id="cb107-27" title="27"></a>
<a class="sourceLine" id="cb107-28" title="28">    ret = snprintf(result, <span class="dv">255</span>, <span class="st">&quot;%s %s and also %d&quot;</span>, a, b, c);</a>
<a class="sourceLine" id="cb107-29" title="29">    printf(<span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st"> has length %d</span><span class="sc">\n</span><span class="st">&quot;</span>, result, ret);</a>
<a class="sourceLine" id="cb107-30" title="30">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>&quot;hello world and also 42&quot; has length 23</code></pre>
<p>Many of these functions raise an important question: What happens if one of the strings is not large enough to hold the data being put into it? If you want to <code>strcat</code> a long string into a small character array, what happens? This leads us to a simple fact…</p>
<p><strong>It is <em>easy</em> to use the string functions incorrectly.</strong> Many of these functions also have a <code>strnX</code> variant where <code>X</code> is the operation (<code>strnlen</code>, <code>strncmp</code>, etc..). These are safer variants of the string functions. The key insight here is that if a string is derived from a user, it might not actually be a proper string! It might not, for example, have a null-terminator – uh oh! In that case, many of the above functions will keep on iterating <em>past</em> the end of the buffer</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb109-1" title="1"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb109-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb109-3" title="3"></a>
<a class="sourceLine" id="cb109-4" title="4"><span class="dt">char</span> usr_str[<span class="dv">8</span>];</a>
<a class="sourceLine" id="cb109-5" title="5"></a>
<a class="sourceLine" id="cb109-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb109-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb109-8" title="8">{</a>
<a class="sourceLine" id="cb109-9" title="9">    <span class="dt">char</span> my_str[<span class="dv">4</span>];</a>
<a class="sourceLine" id="cb109-10" title="10"></a>
<a class="sourceLine" id="cb109-11" title="11">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb109-12" title="12"><span class="co">     * This use of `strcpy` isn&#39;t bugged as we know the explicit string is 7 zs,</span></a>
<a class="sourceLine" id="cb109-13" title="13"><span class="co">     * and 1 null-terminator, which can fit in `usr_str`.</span></a>
<a class="sourceLine" id="cb109-14" title="14"><span class="co">     */</span></a>
<a class="sourceLine" id="cb109-15" title="15">    strcpy(usr_str, <span class="st">&quot;zzzzzzz&quot;</span>);</a>
<a class="sourceLine" id="cb109-16" title="16"></a>
<a class="sourceLine" id="cb109-17" title="17">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb109-18" title="18"><span class="co">     * Also fine: lets limit the copy to 3 bytes, then add a null-terminator ourself</span></a>
<a class="sourceLine" id="cb109-19" title="19"><span class="co">     * (`strlcpy` would do this for us)</span></a>
<a class="sourceLine" id="cb109-20" title="20"><span class="co">     */</span></a>
<a class="sourceLine" id="cb109-21" title="21">    strncpy(my_str, usr_str, <span class="dv">3</span>);</a>
<a class="sourceLine" id="cb109-22" title="22">    my_str[<span class="dv">3</span>] = &#39;\<span class="dv">0</span><span class="er">&#39;</span>;</a>
<a class="sourceLine" id="cb109-23" title="23"></a>
<a class="sourceLine" id="cb109-24" title="24">    printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, my_str);</a>
<a class="sourceLine" id="cb109-25" title="25">    fflush(stdout);  <span class="co">/* don&#39;t mind me, making sure that your print outs happen */</span></a>
<a class="sourceLine" id="cb109-26" title="26"></a>
<a class="sourceLine" id="cb109-27" title="27">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb109-28" title="28"><span class="co">     * However, note that `strlen(usr_str)` is larger than the size of `my_str` (4),</span></a>
<a class="sourceLine" id="cb109-29" title="29"><span class="co">     * so we copy *past* the buffer size of `my_str`. This is called a &quot;buffer overflow&quot;.</span></a>
<a class="sourceLine" id="cb109-30" title="30"><span class="co">     */</span></a>
<a class="sourceLine" id="cb109-31" title="31">    strcpy(my_str, usr_str);</a>
<a class="sourceLine" id="cb109-32" title="32"></a>
<a class="sourceLine" id="cb109-33" title="33">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb109-34" title="34">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>zzz
*** stack smashing detected ***: terminated
make[1]: *** [Makefile:30: inline_exec] Aborted</code></pre>
<h4 id="parsing-strings"><span class="header-section-number">6.2.1.2</span> Parsing Strings</h4>
<p>While many of the previous functions have to do with creating and modifying strings, computers frequently need to “parse”, or try to understand the different parts of, a string. Some examples:</p>
<ul>
<li>The code we write in <code>.c</code> or <code>.java</code> files is just a long string, and the programming language needs to <em>parse</em> the string to understand what commands you’re trying to issue to the computer.</li>
<li>The shell must <em>parse</em> your commands to determine which actions to perform.</li>
<li>Webpages are simply a collection of <code>html</code> code (along with other assets), and a browser needs to <em>parse</em> it to determine what to display.</li>
<li>The markdown text for this lecture is <em>parsed</em> by <code>pandoc</code> to generate a <code>pdf</code> and <code>html</code>.</li>
</ul>
<p>Some of the core functions that help us parse strings include:</p>
<ul>
<li><code>strtol</code> - Pull an integer out of a string. Converts the first part of a string into a <code>long int</code>, and also returns an <code>endptr</code> which points to the character <em>in</em> the string where the conversion into a number stopped. If it cannot find an integer, it will return <code>0</code>, and <code>endptr</code> is set to point to the start of the string.</li>
<li><code>strtok</code> - Iterate through a string, and find the first instance of one of a number of specific characters, and return the string leading up to that character. This is called multiple times to iterate through the string, each time extracting the substring up to the specific characters. See the example in the <code>man</code> page for <code>strtok</code> for an example.</li>
<li><code>strstr</code> - Try and find a string (the “needle”) in another string (the “haystack”), and return a pointer to it (or <code>NULL</code> if you don’t find it). As such, it finds a string in another string (thus <code>strstr</code>).</li>
<li><code>sscanf</code> - A versatile function will enables a format string (e.g. as used in <code>printf</code>) to specify the format of the string, and extract out digits and substrings.</li>
</ul>
<p>Some examples:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb111-1" title="1"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb111-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb111-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb111-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb111-5" title="5"></a>
<a class="sourceLine" id="cb111-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb111-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb111-8" title="8">{</a>
<a class="sourceLine" id="cb111-9" title="9">    <span class="dt">char</span> *input = <span class="st">&quot;1 42 the secret to everything&quot;</span>;</a>
<a class="sourceLine" id="cb111-10" title="10">    <span class="dt">char</span> *inputdup;</a>
<a class="sourceLine" id="cb111-11" title="11">    <span class="dt">char</span> *substr;</a>
<a class="sourceLine" id="cb111-12" title="12">    <span class="dt">char</span> *substr_saved;</a>
<a class="sourceLine" id="cb111-13" title="13">    <span class="dt">long</span> <span class="dt">int</span> extracted;</a>
<a class="sourceLine" id="cb111-14" title="14">    <span class="dt">char</span> sec[<span class="dv">32</span>];</a>
<a class="sourceLine" id="cb111-15" title="15"></a>
<a class="sourceLine" id="cb111-16" title="16">    extracted = strtol(input, &amp;substr, <span class="dv">10</span>);                               <span class="co">/* pull out the first two integers */</span></a>
<a class="sourceLine" id="cb111-17" title="17">    printf(<span class="st">&quot;extracted %ld, remaining string: </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;\n</span><span class="st">&quot;</span>, extracted, substr);</a>
<a class="sourceLine" id="cb111-18" title="18">    extracted = strtol(substr, &amp;substr, <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb111-19" title="19">    printf(<span class="st">&quot;extracted %ld, remaining string: </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;\n</span><span class="st">&quot;</span>, extracted, substr);</a>
<a class="sourceLine" id="cb111-20" title="20">    substr_saved = substr;</a>
<a class="sourceLine" id="cb111-21" title="21"></a>
<a class="sourceLine" id="cb111-22" title="22">    <span class="co">/* what happens when we cannot extract a long? */</span></a>
<a class="sourceLine" id="cb111-23" title="23">    extracted = strtol(substr_saved, &amp;substr, <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb111-24" title="24">    assert(extracted == <span class="dv">0</span> &amp;&amp; substr_saved == substr);                     <span class="co">/* verify that we couldn&#39;t extract an integer */</span></a>
<a class="sourceLine" id="cb111-25" title="25"></a>
<a class="sourceLine" id="cb111-26" title="26">    assert(strcmp(strstr(input, <span class="st">&quot;secret&quot;</span>), <span class="st">&quot;secret to everything&quot;</span>) == <span class="dv">0</span>); <span class="co">/* find secret substring */</span></a>
<a class="sourceLine" id="cb111-27" title="27"></a>
<a class="sourceLine" id="cb111-28" title="28">    sscanf(input, <span class="st">&quot;1 %ld the %s to everything&quot;</span>, &amp;extracted, sec);         <span class="co">/* extract out the number and the secret */</span></a>
<a class="sourceLine" id="cb111-29" title="29">    printf(<span class="st">&quot;%ld and </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;\n</span><span class="st">&quot;</span>, extracted, sec);</a>
<a class="sourceLine" id="cb111-30" title="30"></a>
<a class="sourceLine" id="cb111-31" title="31">    printf(<span class="st">&quot;Using strtok to parse through a string finding substrings separated by &#39;h&#39; or &#39;t&#39;:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb111-32" title="32">    inputdup = strdup(input);                                            <span class="co">/* strtok will modify the string, lets copy it */</span></a>
<a class="sourceLine" id="cb111-33" title="33">    <span class="cf">for</span> (substr = strtok(inputdup, <span class="st">&quot;ht&quot;</span>); substr != NULL; substr = strtok(NULL, <span class="st">&quot;ht&quot;</span>)) {</a>
<a class="sourceLine" id="cb111-34" title="34">        printf(<span class="st">&quot;[%s]</span><span class="sc">\n</span><span class="st">&quot;</span>, substr);</a>
<a class="sourceLine" id="cb111-35" title="35">    }</a>
<a class="sourceLine" id="cb111-36" title="36"></a>
<a class="sourceLine" id="cb111-37" title="37">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb111-38" title="38">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>extracted 1, remaining string: &quot; 42 the secret to everything&quot;
extracted 42, remaining string: &quot; the secret to everything&quot;
42 and &quot;secret&quot;
Using strtok to parse through a string finding substrings separated by &#39;h&#39; or &#39;t&#39;:
[1 42 ]
[e secre]
[ ]
[o every]
[ing]</code></pre>
<h3 id="bonus-explicit-strings"><span class="header-section-number">6.2.2</span> Bonus: Explicit Strings</h3>
<p>When you use an explicit string (e.g. <code>"imma string"</code>) in your code, you’re actually asking C to allocate the string in global memory. This has some strange side-effects:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb113-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb113-2" title="2"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb113-3" title="3"></a>
<a class="sourceLine" id="cb113-4" title="4"><span class="dt">char</span> c[<span class="dv">5</span>];</a>
<a class="sourceLine" id="cb113-5" title="5"></a>
<a class="sourceLine" id="cb113-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb113-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb113-8" title="8">{</a>
<a class="sourceLine" id="cb113-9" title="9">    <span class="dt">char</span> *a = <span class="st">&quot;blah&quot;</span>;</a>
<a class="sourceLine" id="cb113-10" title="10">    <span class="dt">char</span> *b = <span class="st">&quot;blah&quot;</span>;</a>
<a class="sourceLine" id="cb113-11" title="11"></a>
<a class="sourceLine" id="cb113-12" title="12">    strncpy(c, a, <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb113-13" title="13"></a>
<a class="sourceLine" id="cb113-14" title="14">    printf(<span class="st">&quot;%s%s%s</span><span class="sc">\n</span><span class="st">&quot;</span>, a, b, c);</a>
<a class="sourceLine" id="cb113-15" title="15">    <span class="co">/* compare the three pointers */</span></a>
<a class="sourceLine" id="cb113-16" title="16">    printf(<span class="st">&quot;%p == %p != %p</span><span class="sc">\n</span><span class="st">&quot;</span>, a, b, c);</a>
<a class="sourceLine" id="cb113-17" title="17"></a>
<a class="sourceLine" id="cb113-18" title="18">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb113-19" title="19">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>blahblahblah
0x561f11337004 == 0x561f11337004 != 0x561f11339011</code></pre>
<p>The C compiler and linker are smart enough to see that if you have already used a string with a specific value (in this case <code>"clone"</code>), it will avoid allocating a copy of that string, and will just reuse the previous value. Generally, it doesn’t make much sense to look at the address of strings, and certainly you should not compare them. You can see in this example how you must compare strings for equality using <code>strncmp</code>, and <em>not</em> to compare pointers.</p>
<h2 id="api-design-and-concerns"><span class="header-section-number">6.3</span> API Design and Concerns</h2>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/api_design.html#/">Slides</a></p>
<p>When programming in C, you’ll see quite a few APIs. Throughout the class, we’ll see quite a few APIs, most documented in <code>man</code> pages. It takes some practice in reading <code>man</code> pages to get what you need from them. One of the things that helps the most is to understand a few common <em>patterns</em> and <em>requirements</em> that you find these APIs, and in C programming in general.</p>
<h3 id="return-values"><span class="header-section-number">6.3.1</span> Return Values</h3>
<p>Functions often need to return multiple values. C does not provide a means to return more than one value, thus is forced to use pointers. To understand this, lets look at the multiple ways that pointers can be used as function arguments.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb115-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb115-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb115-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb115-4" title="4"></a>
<a class="sourceLine" id="cb115-5" title="5"><span class="co">/*</span></a>
<a class="sourceLine" id="cb115-6" title="6"><span class="co"> * `arg` is used to pass an argument that happens to be an array here. In contrast,</span></a>
<a class="sourceLine" id="cb115-7" title="7"><span class="co"> * `ret` is a *second return value*. This function will set the value that `ret` points</span></a>
<a class="sourceLine" id="cb115-8" title="8"><span class="co"> * to -- which happens to be `retval` in the `main` stack frame -- to the value we are</span></a>
<a class="sourceLine" id="cb115-9" title="9"><span class="co"> * getting from the array.</span></a>
<a class="sourceLine" id="cb115-10" title="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb115-11" title="11"><span class="dt">int</span></a>
<a class="sourceLine" id="cb115-12" title="12">get(<span class="dt">int</span> *arg, <span class="dt">int</span> offset, <span class="dt">int</span> *ret)</a>
<a class="sourceLine" id="cb115-13" title="13">{</a>
<a class="sourceLine" id="cb115-14" title="14">    <span class="cf">if</span> (arg == NULL) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb115-15" title="15"></a>
<a class="sourceLine" id="cb115-16" title="16">    *ret = arg[offset];</a>
<a class="sourceLine" id="cb115-17" title="17"></a>
<a class="sourceLine" id="cb115-18" title="18">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb115-19" title="19">}</a>
<a class="sourceLine" id="cb115-20" title="20"></a>
<a class="sourceLine" id="cb115-21" title="21"><span class="co">/*</span></a>
<a class="sourceLine" id="cb115-22" title="22"><span class="co"> * Again, the array is passed in as the first argument, but this time it is used to</span></a>
<a class="sourceLine" id="cb115-23" title="23"><span class="co"> * store the new value.</span></a>
<a class="sourceLine" id="cb115-24" title="24"><span class="co"> */</span></a>
<a class="sourceLine" id="cb115-25" title="25"><span class="dt">int</span></a>
<a class="sourceLine" id="cb115-26" title="26">set(<span class="dt">int</span> *ret_val, <span class="dt">int</span> offset, <span class="dt">int</span> value)</a>
<a class="sourceLine" id="cb115-27" title="27">{</a>
<a class="sourceLine" id="cb115-28" title="28">    <span class="cf">if</span> (ret_val == NULL) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb115-29" title="29"></a>
<a class="sourceLine" id="cb115-30" title="30">    ret_val[offset] = value;</a>
<a class="sourceLine" id="cb115-31" title="31"></a>
<a class="sourceLine" id="cb115-32" title="32">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb115-33" title="33">}</a>
<a class="sourceLine" id="cb115-34" title="34"></a>
<a class="sourceLine" id="cb115-35" title="35"><span class="co">/*</span></a>
<a class="sourceLine" id="cb115-36" title="36"><span class="co"> * `arrdup`&#39;s job is to duplicate an array by allocating and populating</span></a>
<a class="sourceLine" id="cb115-37" title="37"><span class="co"> * a new array. It will return `0` or not `0` on success/failure. Thus</span></a>
<a class="sourceLine" id="cb115-38" title="38"><span class="co"> * the new array must be returned using pointer arguments. `ret_allocated`</span></a>
<a class="sourceLine" id="cb115-39" title="39"><span class="co"> * is a pointer to a pointer to an array in the calling function, and it</span></a>
<a class="sourceLine" id="cb115-40" title="40"><span class="co"> * is used to return the new array.</span></a>
<a class="sourceLine" id="cb115-41" title="41"><span class="co"> */</span></a>
<a class="sourceLine" id="cb115-42" title="42"><span class="dt">int</span></a>
<a class="sourceLine" id="cb115-43" title="43">arrdup(<span class="dt">int</span> **ret_allocated, <span class="dt">int</span> *args, <span class="dt">size_t</span> args_size)</a>
<a class="sourceLine" id="cb115-44" title="44">{</a>
<a class="sourceLine" id="cb115-45" title="45">    <span class="dt">size_t</span> i;</a>
<a class="sourceLine" id="cb115-46" title="46">    <span class="dt">int</span> *newarr;</a>
<a class="sourceLine" id="cb115-47" title="47"></a>
<a class="sourceLine" id="cb115-48" title="48">    <span class="cf">if</span> (ret_allocated == NULL) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb115-49" title="49"></a>
<a class="sourceLine" id="cb115-50" title="50">    newarr = calloc(args_size, <span class="kw">sizeof</span>(<span class="dt">int</span>)); <span class="co">/* 1 below */</span></a>
<a class="sourceLine" id="cb115-51" title="51">    <span class="cf">if</span> (newarr == NULL) <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb115-52" title="52"></a>
<a class="sourceLine" id="cb115-53" title="53">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; args_size; i++) {</a>
<a class="sourceLine" id="cb115-54" title="54">        newarr[i] = args[i];</a>
<a class="sourceLine" id="cb115-55" title="55">    }</a>
<a class="sourceLine" id="cb115-56" title="56">    *ret_allocated = newarr; <span class="co">/* 2 and 3 below */</span></a>
<a class="sourceLine" id="cb115-57" title="57"></a>
<a class="sourceLine" id="cb115-58" title="58">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb115-59" title="59">}</a>
<a class="sourceLine" id="cb115-60" title="60"><span class="co">/*</span></a>
<a class="sourceLine" id="cb115-61" title="61"><span class="co"> * Lets draw this one. The stack setup when we call `arrdup`:</span></a>
<a class="sourceLine" id="cb115-62" title="62"><span class="co"> *</span></a>
<a class="sourceLine" id="cb115-63" title="63"><span class="co"> * |               |</span></a>
<a class="sourceLine" id="cb115-64" title="64"><span class="co"> * +-main----------+</span></a>
<a class="sourceLine" id="cb115-65" title="65"><span class="co"> * | arr           |&lt;---+</span></a>
<a class="sourceLine" id="cb115-66" title="66"><span class="co"> * | dup           |&lt;-+ |</span></a>
<a class="sourceLine" id="cb115-67" title="67"><span class="co"> * | ...           |  | |</span></a>
<a class="sourceLine" id="cb115-68" title="68"><span class="co"> * +-arrdup--------+  | |</span></a>
<a class="sourceLine" id="cb115-69" title="69"><span class="co"> * | ret_allocated |--+ |</span></a>
<a class="sourceLine" id="cb115-70" title="70"><span class="co"> * | args          |----+</span></a>
<a class="sourceLine" id="cb115-71" title="71"><span class="co"> * | ...           |</span></a>
<a class="sourceLine" id="cb115-72" title="72"><span class="co"> * +---------------+</span></a>
<a class="sourceLine" id="cb115-73" title="73"><span class="co"> *</span></a>
<a class="sourceLine" id="cb115-74" title="74"><span class="co"> * `ret_allocated` points to `dup` in `main`.</span></a>
<a class="sourceLine" id="cb115-75" title="75"><span class="co"> *</span></a>
<a class="sourceLine" id="cb115-76" title="76"><span class="co"> *</span></a>
<a class="sourceLine" id="cb115-77" title="77"><span class="co"> *    3. *ret_allocated = newarr</span></a>
<a class="sourceLine" id="cb115-78" title="78"><span class="co"> *                          ^</span></a>
<a class="sourceLine" id="cb115-79" title="79"><span class="co"> *                          |</span></a>
<a class="sourceLine" id="cb115-80" title="80"><span class="co"> *            ,-------------&#39;</span></a>
<a class="sourceLine" id="cb115-81" title="81"><span class="co"> *           |</span></a>
<a class="sourceLine" id="cb115-82" title="82"><span class="co"> * |         |     |</span></a>
<a class="sourceLine" id="cb115-83" title="83"><span class="co"> * +-main----|-----+</span></a>
<a class="sourceLine" id="cb115-84" title="84"><span class="co"> * | arr     |     |</span></a>
<a class="sourceLine" id="cb115-85" title="85"><span class="co"> * | dup ---&#39;  &lt;------+</span></a>
<a class="sourceLine" id="cb115-86" title="86"><span class="co"> * | ...           |  | -- 2. *ret_allocated</span></a>
<a class="sourceLine" id="cb115-87" title="87"><span class="co"> * +-arrdup--------+  |</span></a>
<a class="sourceLine" id="cb115-88" title="88"><span class="co"> * | ret_allocated ---+</span></a>
<a class="sourceLine" id="cb115-89" title="89"><span class="co"> * | args          |</span></a>
<a class="sourceLine" id="cb115-90" title="90"><span class="co"> * | newarr --------------&gt; 1. calloc(...)</span></a>
<a class="sourceLine" id="cb115-91" title="91"><span class="co"> * +---------------+</span></a>
<a class="sourceLine" id="cb115-92" title="92"><span class="co"> *</span></a>
<a class="sourceLine" id="cb115-93" title="93"><span class="co"> * 1. `arrdup` calls `calloc` to allocate on the heap</span></a>
<a class="sourceLine" id="cb115-94" title="94"><span class="co"> * 2. Dereferencing `ret_allocated` gives us access to `dup`</span></a>
<a class="sourceLine" id="cb115-95" title="95"><span class="co"> * 3. thus we can set dup equal to the new heap memory</span></a>
<a class="sourceLine" id="cb115-96" title="96"><span class="co"> *</span></a>
<a class="sourceLine" id="cb115-97" title="97"><span class="co"> * This effectively enables us to return the new memory into the</span></a>
<a class="sourceLine" id="cb115-98" title="98"><span class="co"> * `dup` variable in main.</span></a>
<a class="sourceLine" id="cb115-99" title="99"><span class="co"> */</span></a>
<a class="sourceLine" id="cb115-100" title="100"></a>
<a class="sourceLine" id="cb115-101" title="101"></a>
<a class="sourceLine" id="cb115-102" title="102"></a>
<a class="sourceLine" id="cb115-103" title="103"><span class="dt">int</span></a>
<a class="sourceLine" id="cb115-104" title="104">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb115-105" title="105">{</a>
<a class="sourceLine" id="cb115-106" title="106">    <span class="dt">int</span> arr[] = {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>};</a>
<a class="sourceLine" id="cb115-107" title="107">    <span class="dt">int</span> *dup;</a>
<a class="sourceLine" id="cb115-108" title="108">    <span class="dt">int</span> retval;</a>
<a class="sourceLine" id="cb115-109" title="109"></a>
<a class="sourceLine" id="cb115-110" title="110">    assert(get(arr, <span class="dv">2</span>, &amp;retval) == <span class="dv">0</span> &amp;&amp; retval == <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb115-111" title="111">    assert(set(arr, <span class="dv">2</span>, <span class="dv">4</span>) == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb115-112" title="112">    assert(get(arr, <span class="dv">2</span>, &amp;retval) == <span class="dv">0</span> &amp;&amp; retval == <span class="dv">4</span>);</a>
<a class="sourceLine" id="cb115-113" title="113">    assert(arrdup(&amp;dup, arr, <span class="dv">4</span>) == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb115-114" title="114">    assert(get(dup, <span class="dv">2</span>, &amp;retval) == <span class="dv">0</span> &amp;&amp; retval == <span class="dv">4</span>);</a>
<a class="sourceLine" id="cb115-115" title="115">    free(dup);</a>
<a class="sourceLine" id="cb115-116" title="116"></a>
<a class="sourceLine" id="cb115-117" title="117">    printf(<span class="st">&quot;no errors!&quot;</span>);</a>
<a class="sourceLine" id="cb115-118" title="118"></a>
<a class="sourceLine" id="cb115-119" title="119">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb115-120" title="120">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>no errors!</code></pre>
<!-- COMBINED ERROR NOTES WITH NEW MATERIAL IN ANOTHER FILE BY SIBIN in OCT 2023!

### Errors

The first question is how we can detect that some error occurred within a function we have called?
We'll separate functions into two different classes:

1. *Functions that return pointers.*
    Functions that return pointers (e.g. that have declarations of the form `type *fn(...)`) are often relatively straightforward.
    If they return `NULL`, then an error occurred; otherwise the returned pointer can be used.
    `malloc` is an example here.
2. *Functions that return integers.*
    Integers are used as a relatively flexible indication of the output of a function.
    Is it common for a `-1` to indicate an error.
    Sometimes *any* negative value indicates an error, each negative value designating that a different error occurred.
    Non-negative values indicate success.
    If a function wishes to return a binary success or failure, you'll see that many APIs (counter-intuitively) return `0` for success, and `-1` for failure.

It is common that you want more information than the return value can give you.
You want more information about *why* the failure happened so that you can debug more easily.
The `errno` variable is UNIX's solution to this (see its `man` page), and can be referenced if you include `errno.h`.
`errno` is simply an integer where specific values represent specific errors.
You can view these values by looking them up in the source^[For example, in `/usr/include/asm/errno.h`.] or, you can ask the `errno` *program*^[You might need to do `apt-get install moreutils` if you're using your own system.].
For example:

```
$ errno -l
EPERM 1 Operation not permitted
ENOENT 2 No such file or directory
ESRCH 3 No such process
EINTR 4 Interrupted system call
EIO 5 Input/output error
...
```

You can look up specific values:

```
$ errno 28
ENOSPC 28 No space left on device
```

You can imagine how that error might occur.
What if you're trying to add files on disk, and the disk runs out of room!?

If you want your program to print a useful error when you encounter such a problem, you can use the `perror` function (see its `man` page for documentation) to print out an error, or `strerror` (via `string.h`) if you just want a string corresponding to the error.

```c
#include <stdlib.h>
#include <limits.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

int
main(void)
{
    char *ret;

    printf("Lets get greedy: allocate %ld bytes!\n", LONG_MAX);
    ret = malloc(LONG_MAX);
    if (ret == NULL) {
        printf("Error: errno value %d and description: %s\n", errno, strerror(errno));
        fflush(stdout);
        perror("Error allocating memory");

        return -1;
    }

    return 0;
}
```

Program output:
```
Lets get greedy: allocate 9223372036854775807 bytes!
Error: errno value 12 and description: Cannot allocate memory
Error allocating memory: Cannot allocate memory
make[1]: *** [Makefile:30: inline_exec] Error 255
```

(Note: when you return from a program with a non-zero value, it designates that your *program* had an error.
This is why we see the `make` error when it runs your program.)

To understand the return value of UNIX library functions:

- look at the function return values to understand the type (and identify if it is returning an `int` or a pointer)
```
SYNOPSIS
       #include <stdlib.h>

       void *malloc(size_t size);
       ...
```
- Read through the description of the function(s).
- Read through the `RETURN VALUE` and `ERRORS` sections of the man page.
```
RETURN VALUE
       The malloc() and calloc() functions return a pointer to the allocated memory, which is  suitably  aligned  for
       any  built-in type.  On error, these functions return NULL.  NULL may also be returned by a successful call to
       malloc() with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero.
...
ERRORS
       calloc(), malloc(), realloc(), and reallocarray() can fail with the following error:

       ENOMEM Out  of  memory.
       ...

```

This explains why we got the error we did.
-->
<h3 id="memory-ownership"><span class="header-section-number">6.3.2</span> Memory Ownership</h3>
<p>One of the last, but most challenging aspects of APIs in C is that of memory ownership. The big question is: when a pointer passed into a function, or returned from a function, who is responsible for <code>free</code>ing the memory? This is due to a combination of factors, mainly:</p>
<ol type="1">
<li>C requires that memory is explicitly <code>free</code>d, so someone has to do it, and it should be <code>free</code>d <em>only once</em>, and</li>
<li>pointers are passed around freely and frequently in C, so somehow the function caller and callee have to understand who “owns” each of those pointers.</li>
</ol>
<p>It is easiest to understand this issue through the concept of <em>ownership</em>: simply put, the owner of a piece of memory is the one that should either free it, or pass it to another part of the code that becomes the owner. In contrast, a caller can pass a pointer to memory into a function allowing it to <em>borrow</em> that memory, but the function does <em>not</em> free it, and after it returns it should not further access the memory. There are three general patterns:</p>
<ul>
<li><p>A caller <em>passes a pointer</em> into a function, and <em>passes the ownership</em> of that data to the function. This is common for data-structures whose job is to take a pointer of data to store, and at that point, they own the memory. Think: if we <code>enqueue</code> data into a queue.</p>
<p><strong>Examples</strong>: The key-value store’s <code>put</code> function owns the passed in data (assuming it takes a <code>void *</code>.</p></li>
<li><p>A function <em>returns a pointer</em> to the function caller and <em>passes the ownership</em> to the caller. The caller must later <code>free</code> the data. This is also common in data-structures when we wish to retrieve the data. Think: if we <code>dequeue</code> data from a queue.</p>
<p><strong>Examples</strong>: <code>strdup</code> creates a new string, expecting the caller to free it.</p></li>
<li><p>A caller <em>passes a pointer</em> into a function, but only allows the function to <em>borrow</em> the data. Thus the caller still owns the memory (thus is still responsible to <code>free</code> the data) after the function returns, and the function should <em>not</em> maintain any references to the data. Think: most of the string functions that take a string as an argument, perform some operation on it, and return expecting the caller to still <code>free</code> the string.</p>
<p><strong>Examples</strong>: Most other functions we’ve seen borrow pointers, perform operations, and then don’t maintain references to them.</p></li>
<li><p>A function <em>returns a pointer</em> to the function caller that enables the caller to <em>borrow</em> the data. This requires a difficult constraint: the caller can access the data, but must not maintain a pointer to it after the function or API (that still owns the data) <code>free</code>s it.</p>
<p><strong>Examples</strong>: The key-value store’s <code>get</code> function transfers ownership to the caller.</p></li>
</ul>
<p>The memory ownership constraints are an agreement between the calling function, and a function being called.</p>
<h2 id="exercises-1"><span class="header-section-number">6.4</span> Exercises</h2>
<h3 id="stack-allocation-1"><span class="header-section-number">6.4.1</span> Stack Allocation</h3>
<p>An old interview question:</p>
<blockquote>
<p>How can you write a function that determines if the execution stack grows upwards (from lower addresses to higher), or downwards?</p>
</blockquote>
<p>Write this function!</p>
<h3 id="understanding-memory-ownership"><span class="header-section-number">6.4.2</span> Understanding Memory Ownership</h3>
<p>Lets look at a simple key-value store that needs to learn to be more careful about memory. Above each function, we specify the ownership of pointers being passed – either passing ownership, or borrowing the memory. The current implementations do <em>not</em> adhere to these specifications.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb117-1" title="1"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb117-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb117-3" title="3"></a>
<a class="sourceLine" id="cb117-4" title="4"><span class="co">/*</span></a>
<a class="sourceLine" id="cb117-5" title="5"><span class="co"> * Lets just use a single key/value as a proxy for an entire kv/store.</span></a>
<a class="sourceLine" id="cb117-6" title="6"><span class="co"> * You can assume that the stored values are strings, so `strdup` can</span></a>
<a class="sourceLine" id="cb117-7" title="7"><span class="co"> * allocate the memory for and copy the values. You absolutely will</span></a>
<a class="sourceLine" id="cb117-8" title="8"><span class="co"> * have to use `strdup` in some of the functions.</span></a>
<a class="sourceLine" id="cb117-9" title="9"><span class="co"> */</span></a>
<a class="sourceLine" id="cb117-10" title="10"><span class="dt">static</span> <span class="dt">int</span>   kv_key;</a>
<a class="sourceLine" id="cb117-11" title="11"><span class="dt">static</span> <span class="dt">char</span> *kv_value;</a>
<a class="sourceLine" id="cb117-12" title="12"></a>
<a class="sourceLine" id="cb117-13" title="13"><span class="co">/**</span></a>
<a class="sourceLine" id="cb117-14" title="14"><span class="co"> * The returned value should not be maintained in the data-structure</span></a>
<a class="sourceLine" id="cb117-15" title="15"><span class="co"> * and should be `free`d by the caller.</span></a>
<a class="sourceLine" id="cb117-16" title="16"><span class="co"> */</span></a>
<a class="sourceLine" id="cb117-17" title="17"><span class="dt">char</span> *</a>
<a class="sourceLine" id="cb117-18" title="18">get_pass_ownership(<span class="dt">int</span> key)</a>
<a class="sourceLine" id="cb117-19" title="19">{</a>
<a class="sourceLine" id="cb117-20" title="20">    <span class="cf">if</span> (key != kv_key) <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb117-21" title="21"></a>
<a class="sourceLine" id="cb117-22" title="22">    <span class="cf">return</span> kv_value;</a>
<a class="sourceLine" id="cb117-23" title="23">}</a>
<a class="sourceLine" id="cb117-24" title="24"></a>
<a class="sourceLine" id="cb117-25" title="25"><span class="co">/**</span></a>
<a class="sourceLine" id="cb117-26" title="26"><span class="co"> * Pointers to the returned value are maintained in this data-structure</span></a>
<a class="sourceLine" id="cb117-27" title="27"><span class="co"> * and it will be `free`d by the data-structure, not by the caller</span></a>
<a class="sourceLine" id="cb117-28" title="28"><span class="co"> */</span></a>
<a class="sourceLine" id="cb117-29" title="29"><span class="dt">char</span> *</a>
<a class="sourceLine" id="cb117-30" title="30">get_borrow(<span class="dt">int</span> key)</a>
<a class="sourceLine" id="cb117-31" title="31">{</a>
<a class="sourceLine" id="cb117-32" title="32">    <span class="cf">if</span> (key != kv_key) <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb117-33" title="33"></a>
<a class="sourceLine" id="cb117-34" title="34">    <span class="cf">return</span> kv_value;</a>
<a class="sourceLine" id="cb117-35" title="35">}</a>
<a class="sourceLine" id="cb117-36" title="36"></a>
<a class="sourceLine" id="cb117-37" title="37"><span class="co">/**</span></a>
<a class="sourceLine" id="cb117-38" title="38"><span class="co"> * Pointers to the `value` passed as the second argument are maintained by</span></a>
<a class="sourceLine" id="cb117-39" title="39"><span class="co"> * the caller, thus the `value` is borrowed here. The `value` will be `free`d</span></a>
<a class="sourceLine" id="cb117-40" title="40"><span class="co"> * by the caller.</span></a>
<a class="sourceLine" id="cb117-41" title="41"><span class="co"> */</span></a>
<a class="sourceLine" id="cb117-42" title="42"><span class="dt">void</span></a>
<a class="sourceLine" id="cb117-43" title="43">set_borrow(<span class="dt">int</span> key, <span class="dt">char</span> *value)</a>
<a class="sourceLine" id="cb117-44" title="44">{</a>
<a class="sourceLine" id="cb117-45" title="45">    <span class="co">/* What do we do with `kv_value`? Do we `strdup` anything? */</span></a>
<a class="sourceLine" id="cb117-46" title="46">    kv_key   = key;</a>
<a class="sourceLine" id="cb117-47" title="47">    kv_value = value;</a>
<a class="sourceLine" id="cb117-48" title="48"></a>
<a class="sourceLine" id="cb117-49" title="49">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb117-50" title="50">}</a>
<a class="sourceLine" id="cb117-51" title="51"></a>
<a class="sourceLine" id="cb117-52" title="52"><span class="co">/**</span></a>
<a class="sourceLine" id="cb117-53" title="53"><span class="co"> * Pointers to the `value` passed as the second argument are not maintained by</span></a>
<a class="sourceLine" id="cb117-54" title="54"><span class="co"> * the caller, thus the `value` should be `free`d by this data-structure.</span></a>
<a class="sourceLine" id="cb117-55" title="55"><span class="co"> */</span></a>
<a class="sourceLine" id="cb117-56" title="56"><span class="dt">void</span></a>
<a class="sourceLine" id="cb117-57" title="57">set_pass_ownership(<span class="dt">int</span> key, <span class="dt">char</span> *value)</a>
<a class="sourceLine" id="cb117-58" title="58">{</a>
<a class="sourceLine" id="cb117-59" title="59">    <span class="co">/* What do we do with `kv_value`? Do we `strdup` anything? */</span></a>
<a class="sourceLine" id="cb117-60" title="60">    kv_key   = key;</a>
<a class="sourceLine" id="cb117-61" title="61">    kv_value = value;</a>
<a class="sourceLine" id="cb117-62" title="62"></a>
<a class="sourceLine" id="cb117-63" title="63">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb117-64" title="64">}</a>
<a class="sourceLine" id="cb117-65" title="65"></a>
<a class="sourceLine" id="cb117-66" title="66"><span class="dt">int</span></a>
<a class="sourceLine" id="cb117-67" title="67">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb117-68" title="68">{</a>
<a class="sourceLine" id="cb117-69" title="69">    <span class="co">/* The values we pass in. */</span></a>
<a class="sourceLine" id="cb117-70" title="70">    <span class="dt">char</span> *v_p2p = strdup(<span class="st">&quot;value1&quot;</span>); <span class="co">/* calls `malloc` ! */</span></a>
<a class="sourceLine" id="cb117-71" title="71">    <span class="dt">char</span> *v_p2b = strdup(<span class="st">&quot;value2&quot;</span>);</a>
<a class="sourceLine" id="cb117-72" title="72">    <span class="dt">char</span> *v_b2p = strdup(<span class="st">&quot;value3&quot;</span>);</a>
<a class="sourceLine" id="cb117-73" title="73">    <span class="dt">char</span> *v_b2b = strdup(<span class="st">&quot;value4&quot;</span>);</a>
<a class="sourceLine" id="cb117-74" title="74"></a>
<a class="sourceLine" id="cb117-75" title="75">    <span class="co">/* The return values */</span></a>
<a class="sourceLine" id="cb117-76" title="76">    <span class="dt">char</span> *r_p2p, *r_p2b, *r_b2p, *r_b2b;</a>
<a class="sourceLine" id="cb117-77" title="77"></a>
<a class="sourceLine" id="cb117-78" title="78">    <span class="co">/* p2p: passing ownership on set, passing ownership on get */</span></a>
<a class="sourceLine" id="cb117-79" title="79">    set_pass_ownership(<span class="dv">0</span>, v_p2p);</a>
<a class="sourceLine" id="cb117-80" title="80">    r_p2p = get_pass_ownership(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb117-81" title="81">    <span class="co">/* The question: should we `free(v_p2p)`?, `free(r_p2p)`? */</span></a>
<a class="sourceLine" id="cb117-82" title="82"></a>
<a class="sourceLine" id="cb117-83" title="83">    <span class="co">/* p2b: passing ownership on set, borrowing memory for get */</span></a>
<a class="sourceLine" id="cb117-84" title="84">    set_pass_ownership(<span class="dv">0</span>, v_p2b);</a>
<a class="sourceLine" id="cb117-85" title="85">    r_p2b = get_borrow(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb117-86" title="86">    <span class="co">/* The question: should we `free(v_p2b)`?, `free(r_p2b)`? */</span></a>
<a class="sourceLine" id="cb117-87" title="87"></a>
<a class="sourceLine" id="cb117-88" title="88">    <span class="co">/* b2p: borrowing ownership on set, passing ownership on get */</span></a>
<a class="sourceLine" id="cb117-89" title="89">    set_borrow(<span class="dv">0</span>, v_b2p);</a>
<a class="sourceLine" id="cb117-90" title="90">    r_b2p = get_pass_ownership(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb117-91" title="91">    <span class="co">/* The question: should we `free(v_b2p)`?, `free(r_b2p)`? */</span></a>
<a class="sourceLine" id="cb117-92" title="92"></a>
<a class="sourceLine" id="cb117-93" title="93">    <span class="co">/* b2b: borrowing ownership on set, borrowing on get */</span></a>
<a class="sourceLine" id="cb117-94" title="94">    set_borrow(<span class="dv">0</span>, v_b2b);</a>
<a class="sourceLine" id="cb117-95" title="95">    r_b2b = get_borrow(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb117-96" title="96">    <span class="co">/* The question: should we `free(v_b2b)`?, `free(r_b2b)`? */</span></a>
<a class="sourceLine" id="cb117-97" title="97"></a>
<a class="sourceLine" id="cb117-98" title="98">    <span class="cf">if</span> (kv_value) free(kv_value);</a>
<a class="sourceLine" id="cb117-99" title="99"></a>
<a class="sourceLine" id="cb117-100" title="100">    printf(<span class="st">&quot;Looks like success!...but wait till we valgrind; then ;-(</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb117-101" title="101"></a>
<a class="sourceLine" id="cb117-102" title="102">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb117-103" title="103">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c: In function main:
inline_exec_tmp.c:100:2: warning: implicit declaration of function printf [-Wimplicit-function-declaration]
  100 |  printf(&quot;Looks like success!...but wait till we valgrind; then ;-(\n&quot;);
      |  ^~~~~~
inline_exec_tmp.c:100:2: warning: incompatible implicit declaration of built-in function printf
inline_exec_tmp.c:3:1: note: include &lt;stdio.h&gt; or provide a declaration of printf
    2 | #include &lt;stdlib.h&gt;
  +++ |+#include &lt;stdio.h&gt;
    3 | 
Looks like success!...but wait till we valgrind; then ;-(</code></pre>
<p>The above code is hopelessly broken. Run it in valgrind to see.</p>
<p><strong>Tasks:</strong></p>
<ul>
<li>In the above code, implement the <code>malloc</code>/<code>free</code>/<code>strdup</code> operations that are necessary both in the key-value implementation, and in the client (<code>main</code>) to make both the caller and callee abide by the memory ownership constraints.</li>
<li>In which cases can <em>stack allocation</em> of the values be used in <code>main</code>? Why?</li>
<li>In which cases can <em>stack allocation</em> of the values in the key-value store (i.e. in <code>get</code>/<code>set</code>) be used? Why?</li>
</ul>
<h2 id="errors"><span class="header-section-number">6.5</span> Errors</h2>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/errors.html#/">Slides</a></p>
<p>Sometimes, errors happen…</p>
<ul>
<li><em>e.g.,</em> system is out of memory</li>
<li>when we call <sc>malloc</sc></li>
</ul>
<p>The first question is how we can detect that some error occurred within a function we have called?</p>
<p><strong>When errors occur</strong></p>
<ul>
<li>we want more <strong>context</strong>
<ul>
<li>what was the <em>exact</em> error?</li>
<li><em>where</em> did the error occur?</li>
</ul></li>
<li>programmers can make <em>informed</em> choices
<ul>
<li>on how to respond</li>
</ul></li>
</ul>
<h3 id="return-vals-indicate-errors"><span class="header-section-number">6.5.1</span> <strong>return</strong> vals → indicate errors</h3>
<table>
<thead>
<tr class="header">
<th>functions return</th>
<th>error indicator</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>integers</td>
<td>negative values</td>
<td><sc>printf()*</sc></td>
</tr>
<tr class="even">
<td>pointers</td>
<td><sc>NULL</sc></td>
<td><sc>malloc()</sc></td>
</tr>
<tr class="odd">
<td>structs</td>
<td>fields in struct</td>
<td>user defined</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>[*check out the return value of <code>printf()</code>]</p>
<p>As seen above, we separate functions into two different classes:</p>
<ol type="1">
<li><em>Functions that return pointers.</em> Functions that return pointers (e.g. that have declarations of the form <code>type *fn(...)</code>) are often relatively straightforward. If they return <code>NULL</code>, then an error occurred; otherwise the returned pointer can be used. <code>malloc</code> is an example here.</li>
<li><em>Functions that return integers.</em> Integers are used as a relatively flexible indication of the output of a function. Is it common for a <code>-1</code> to indicate an error. Sometimes <em>any</em> negative value indicates an error, each negative value designating that a different error occurred. Non-negative values indicate success. If a function wishes to return a binary success or failure, you’ll see that many APIs (counter-intuitively) return <code>0</code> for success, and <code>-1</code> for failure.</li>
</ol>
<p>It is common that you want more information than a <em>single</em> return value can give you. So, we can define our own struct,</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb119-1" title="1"><span class="kw">struct</span> ret_type{</a>
<a class="sourceLine" id="cb119-2" title="2">    <span class="dt">int</span> a;</a>
<a class="sourceLine" id="cb119-3" title="3">    <span class="dt">char</span>* carray ;</a>
<a class="sourceLine" id="cb119-4" title="4">    <span class="dt">unsigned</span> <span class="dt">int</span> error_number ;</a>
<a class="sourceLine" id="cb119-5" title="5">    <span class="dt">char</span> error_name[<span class="dv">255</span>] ;</a>
<a class="sourceLine" id="cb119-6" title="6">} ;</a></code></pre></div>
<h3 id="errno-variable-and-command"><span class="header-section-number">6.5.2</span> <code>errno</code> variable and command</h3>
<p>UNIX/C have some mechanisms that actually help (instead of defining our own structs). They define a <strong>variable</strong>, <code>errno</code>, defined in <code>&lt;error.h&gt;</code>.</p>
<p><code>errno</code> is simply an integer where specific values represent specific errors. You can view these values by looking them up in the source<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>.</p>
<p>Or, you can ask the <code>errno</code> <em>program</em>^ (yes, the same name, confusing!), the command line utility (you might need to do <code>apt-get install moreutils</code> to get the <code>errno</code> program to work if you’re using your own system) used as follows:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb120-1" title="1">$ errno <span class="dv">12</span> </a></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb121-1" title="1">ENOMEM <span class="dv">12</span> Cannot allocate memory</a></code></pre></div>
<p>You can imagine why this error might occur – your system ran out of memory or you asked for too much!</p>
<p>If we want to see a <strong>full</strong> list of all possible <code>errno</code> values and their meanings, we do:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb122-1" title="1">$ errno -l</a></code></pre></div>
<p>Output (prints <strong>all</strong> of the error numbers and codes):</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb123-1" title="1">EPERM <span class="dv">1</span> Operation not permitted</a>
<a class="sourceLine" id="cb123-2" title="2">ENOENT <span class="dv">2</span> No such file or directory</a>
<a class="sourceLine" id="cb123-3" title="3">ESRCH <span class="dv">3</span> No such process</a>
<a class="sourceLine" id="cb123-4" title="4">EINTR <span class="dv">4</span> Interrupted system call</a>
<a class="sourceLine" id="cb123-5" title="5">EIO <span class="dv">5</span> Input/output error</a>
<a class="sourceLine" id="cb123-6" title="6">ENXIO <span class="dv">6</span> No such device or address</a>
<a class="sourceLine" id="cb123-7" title="7">E2BIG <span class="dv">7</span> Argument list too <span class="dt">long</span></a>
<a class="sourceLine" id="cb123-8" title="8">ENOEXEC <span class="dv">8</span> Exec format error</a>
<a class="sourceLine" id="cb123-9" title="9">EBADF <span class="dv">9</span> Bad file descriptor</a>
<a class="sourceLine" id="cb123-10" title="10">ECHILD <span class="dv">10</span> No child processes</a>
<a class="sourceLine" id="cb123-11" title="11">EAGAIN <span class="dv">11</span> Resource temporarily unavailable</a>
<a class="sourceLine" id="cb123-12" title="12">ENOMEM <span class="dv">12</span> Cannot allocate memory</a>
<a class="sourceLine" id="cb123-13" title="13">EACCES <span class="dv">13</span> Permission denied</a>
<a class="sourceLine" id="cb123-14" title="14">EFAULT <span class="dv">14</span> Bad address</a>
<a class="sourceLine" id="cb123-15" title="15">ENOTBLK <span class="dv">15</span> Block device required</a>
<a class="sourceLine" id="cb123-16" title="16">EBUSY <span class="dv">16</span> Device or resource busy</a>
<a class="sourceLine" id="cb123-17" title="17">EEXIST <span class="dv">17</span> File exists</a>
<a class="sourceLine" id="cb123-18" title="18">EXDEV <span class="dv">18</span> Invalid cross-device link</a>
<a class="sourceLine" id="cb123-19" title="19">ENODEV <span class="dv">19</span> No such device</a>
<a class="sourceLine" id="cb123-20" title="20">ENOTDIR <span class="dv">20</span> Not a directory</a>
<a class="sourceLine" id="cb123-21" title="21">EISDIR <span class="dv">21</span> Is a directory</a>
<a class="sourceLine" id="cb123-22" title="22">EINVAL <span class="dv">22</span> Invalid argument</a>
<a class="sourceLine" id="cb123-23" title="23">ENFILE <span class="dv">23</span> Too many open files in system</a>
<a class="sourceLine" id="cb123-24" title="24">EMFILE <span class="dv">24</span> Too many open files</a>
<a class="sourceLine" id="cb123-25" title="25">ENOTTY <span class="dv">25</span> Inappropriate ioctl <span class="cf">for</span> device</a>
<a class="sourceLine" id="cb123-26" title="26">ETXTBSY <span class="dv">26</span> Text file busy</a>
<a class="sourceLine" id="cb123-27" title="27">EFBIG <span class="dv">27</span> File too large</a>
<a class="sourceLine" id="cb123-28" title="28">ENOSPC <span class="dv">28</span> No space left on device</a>
<a class="sourceLine" id="cb123-29" title="29">ESPIPE <span class="dv">29</span> Illegal seek</a>
<a class="sourceLine" id="cb123-30" title="30">EROFS <span class="dv">30</span> Read-only file system</a>
<a class="sourceLine" id="cb123-31" title="31">EMLINK <span class="dv">31</span> Too many links</a>
<a class="sourceLine" id="cb123-32" title="32">EPIPE <span class="dv">32</span> Broken pipe</a>
<a class="sourceLine" id="cb123-33" title="33">EDOM <span class="dv">33</span> Numerical argument out of domain</a>
<a class="sourceLine" id="cb123-34" title="34">ERANGE <span class="dv">34</span> Numerical result out of range</a>
<a class="sourceLine" id="cb123-35" title="35">EDEADLK <span class="dv">35</span> Resource deadlock avoided</a>
<a class="sourceLine" id="cb123-36" title="36">ENAMETOOLONG <span class="dv">36</span> File name too <span class="dt">long</span></a>
<a class="sourceLine" id="cb123-37" title="37">ENOLCK <span class="dv">37</span> No locks available</a>
<a class="sourceLine" id="cb123-38" title="38">ENOSYS <span class="dv">38</span> Function not implemented</a>
<a class="sourceLine" id="cb123-39" title="39">ENOTEMPTY <span class="dv">39</span> Directory not empty</a>
<a class="sourceLine" id="cb123-40" title="40">ELOOP <span class="dv">40</span> Too many levels of symbolic links</a>
<a class="sourceLine" id="cb123-41" title="41">EWOULDBLOCK <span class="dv">11</span> Resource temporarily unavailable</a>
<a class="sourceLine" id="cb123-42" title="42">ENOMSG <span class="dv">42</span> No message of desired type</a>
<a class="sourceLine" id="cb123-43" title="43">EIDRM <span class="dv">43</span> Identifier removed</a>
<a class="sourceLine" id="cb123-44" title="44">ECHRNG <span class="dv">44</span> Channel number out of range</a>
<a class="sourceLine" id="cb123-45" title="45">EL2NSYNC <span class="dv">45</span> Level <span class="dv">2</span> not synchronized</a>
<a class="sourceLine" id="cb123-46" title="46">EL3HLT <span class="dv">46</span> Level <span class="dv">3</span> halted</a>
<a class="sourceLine" id="cb123-47" title="47">EL3RST <span class="dv">47</span> Level <span class="dv">3</span> reset</a>
<a class="sourceLine" id="cb123-48" title="48">ELNRNG <span class="dv">48</span> Link number out of range</a>
<a class="sourceLine" id="cb123-49" title="49">EUNATCH <span class="dv">49</span> Protocol driver not attached</a>
<a class="sourceLine" id="cb123-50" title="50">ENOCSI <span class="dv">50</span> No CSI structure available</a>
<a class="sourceLine" id="cb123-51" title="51">EL2HLT <span class="dv">51</span> Level <span class="dv">2</span> halted</a>
<a class="sourceLine" id="cb123-52" title="52">EBADE <span class="dv">52</span> Invalid exchange</a>
<a class="sourceLine" id="cb123-53" title="53">EBADR <span class="dv">53</span> Invalid request descriptor</a>
<a class="sourceLine" id="cb123-54" title="54">EXFULL <span class="dv">54</span> Exchange full</a>
<a class="sourceLine" id="cb123-55" title="55">ENOANO <span class="dv">55</span> No anode</a>
<a class="sourceLine" id="cb123-56" title="56">EBADRQC <span class="dv">56</span> Invalid request code</a>
<a class="sourceLine" id="cb123-57" title="57">EBADSLT <span class="dv">57</span> Invalid slot</a>
<a class="sourceLine" id="cb123-58" title="58">EDEADLOCK <span class="dv">35</span> Resource deadlock avoided</a>
<a class="sourceLine" id="cb123-59" title="59">EBFONT <span class="dv">59</span> Bad font file format</a>
<a class="sourceLine" id="cb123-60" title="60">ENOSTR <span class="dv">60</span> Device not a stream</a>
<a class="sourceLine" id="cb123-61" title="61">ENODATA <span class="dv">61</span> No data available</a>
<a class="sourceLine" id="cb123-62" title="62">ETIME <span class="dv">62</span> Timer expired</a>
<a class="sourceLine" id="cb123-63" title="63">ENOSR <span class="dv">63</span> Out of streams resources</a>
<a class="sourceLine" id="cb123-64" title="64">ENONET <span class="dv">64</span> Machine is not on the network</a>
<a class="sourceLine" id="cb123-65" title="65">ENOPKG <span class="dv">65</span> Package not installed</a>
<a class="sourceLine" id="cb123-66" title="66">EREMOTE <span class="dv">66</span> Object is remote</a>
<a class="sourceLine" id="cb123-67" title="67">ENOLINK <span class="dv">67</span> Link has been severed</a>
<a class="sourceLine" id="cb123-68" title="68">EADV <span class="dv">68</span> Advertise error</a>
<a class="sourceLine" id="cb123-69" title="69">ESRMNT <span class="dv">69</span> Srmount error</a>
<a class="sourceLine" id="cb123-70" title="70">ECOMM <span class="dv">70</span> Communication error on send</a>
<a class="sourceLine" id="cb123-71" title="71">EPROTO <span class="dv">71</span> Protocol error</a>
<a class="sourceLine" id="cb123-72" title="72">EMULTIHOP <span class="dv">72</span> Multihop attempted</a>
<a class="sourceLine" id="cb123-73" title="73">EDOTDOT <span class="dv">73</span> RFS specific error</a>
<a class="sourceLine" id="cb123-74" title="74">EBADMSG <span class="dv">74</span> Bad message</a>
<a class="sourceLine" id="cb123-75" title="75">EOVERFLOW <span class="dv">75</span> Value too large <span class="cf">for</span> defined data type</a>
<a class="sourceLine" id="cb123-76" title="76">ENOTUNIQ <span class="dv">76</span> Name not unique on network</a>
<a class="sourceLine" id="cb123-77" title="77">EBADFD <span class="dv">77</span> File descriptor in bad state</a>
<a class="sourceLine" id="cb123-78" title="78">EREMCHG <span class="dv">78</span> Remote address changed</a>
<a class="sourceLine" id="cb123-79" title="79">ELIBACC <span class="dv">79</span> Can not access a needed shared library</a>
<a class="sourceLine" id="cb123-80" title="80">ELIBBAD <span class="dv">80</span> Accessing a corrupted shared library</a>
<a class="sourceLine" id="cb123-81" title="81">ELIBSCN <span class="dv">81</span> .lib section in a.out corrupted</a>
<a class="sourceLine" id="cb123-82" title="82">ELIBMAX <span class="dv">82</span> Attempting to link in too many shared libraries</a>
<a class="sourceLine" id="cb123-83" title="83">ELIBEXEC <span class="dv">83</span> Cannot exec a shared library directly</a>
<a class="sourceLine" id="cb123-84" title="84">EILSEQ <span class="dv">84</span> Invalid or incomplete multibyte or wide character</a>
<a class="sourceLine" id="cb123-85" title="85">ERESTART <span class="dv">85</span> Interrupted system call should be restarted</a>
<a class="sourceLine" id="cb123-86" title="86">ESTRPIPE <span class="dv">86</span> Streams pipe error</a>
<a class="sourceLine" id="cb123-87" title="87">EUSERS <span class="dv">87</span> Too many users</a>
<a class="sourceLine" id="cb123-88" title="88">ENOTSOCK <span class="dv">88</span> Socket operation on non-socket</a>
<a class="sourceLine" id="cb123-89" title="89">EDESTADDRREQ <span class="dv">89</span> Destination address required</a>
<a class="sourceLine" id="cb123-90" title="90">EMSGSIZE <span class="dv">90</span> Message too <span class="dt">long</span></a>
<a class="sourceLine" id="cb123-91" title="91">EPROTOTYPE <span class="dv">91</span> Protocol wrong type <span class="cf">for</span> socket</a>
<a class="sourceLine" id="cb123-92" title="92">ENOPROTOOPT <span class="dv">92</span> Protocol not available</a>
<a class="sourceLine" id="cb123-93" title="93">EPROTONOSUPPORT <span class="dv">93</span> Protocol not supported</a>
<a class="sourceLine" id="cb123-94" title="94">ESOCKTNOSUPPORT <span class="dv">94</span> Socket type not supported</a>
<a class="sourceLine" id="cb123-95" title="95">EOPNOTSUPP <span class="dv">95</span> Operation not supported</a>
<a class="sourceLine" id="cb123-96" title="96">EPFNOSUPPORT <span class="dv">96</span> Protocol family not supported</a>
<a class="sourceLine" id="cb123-97" title="97">EAFNOSUPPORT <span class="dv">97</span> Address family not supported by protocol</a>
<a class="sourceLine" id="cb123-98" title="98">EADDRINUSE <span class="dv">98</span> Address already in use</a>
<a class="sourceLine" id="cb123-99" title="99">EADDRNOTAVAIL <span class="dv">99</span> Cannot assign requested address</a>
<a class="sourceLine" id="cb123-100" title="100">ENETDOWN <span class="dv">100</span> Network is down</a>
<a class="sourceLine" id="cb123-101" title="101">ENETUNREACH <span class="dv">101</span> Network is unreachable</a>
<a class="sourceLine" id="cb123-102" title="102">ENETRESET <span class="dv">102</span> Network dropped connection on reset</a>
<a class="sourceLine" id="cb123-103" title="103">ECONNABORTED <span class="dv">103</span> Software caused connection abort</a>
<a class="sourceLine" id="cb123-104" title="104">ECONNRESET <span class="dv">104</span> Connection reset by peer</a>
<a class="sourceLine" id="cb123-105" title="105">ENOBUFS <span class="dv">105</span> No buffer space available</a>
<a class="sourceLine" id="cb123-106" title="106">EISCONN <span class="dv">106</span> Transport endpoint is already connected</a>
<a class="sourceLine" id="cb123-107" title="107">ENOTCONN <span class="dv">107</span> Transport endpoint is not connected</a>
<a class="sourceLine" id="cb123-108" title="108">ESHUTDOWN <span class="dv">108</span> Cannot send after transport endpoint shutdown</a>
<a class="sourceLine" id="cb123-109" title="109">ETOOMANYREFS <span class="dv">109</span> Too many references: cannot splice</a>
<a class="sourceLine" id="cb123-110" title="110">ETIMEDOUT <span class="dv">110</span> Connection timed out</a>
<a class="sourceLine" id="cb123-111" title="111">ECONNREFUSED <span class="dv">111</span> Connection refused</a>
<a class="sourceLine" id="cb123-112" title="112">EHOSTDOWN <span class="dv">112</span> Host is down</a>
<a class="sourceLine" id="cb123-113" title="113">EHOSTUNREACH <span class="dv">113</span> No route to host</a>
<a class="sourceLine" id="cb123-114" title="114">EALREADY <span class="dv">114</span> Operation already in progress</a>
<a class="sourceLine" id="cb123-115" title="115">EINPROGRESS <span class="dv">115</span> Operation now in progress</a>
<a class="sourceLine" id="cb123-116" title="116">ESTALE <span class="dv">116</span> Stale file handle</a>
<a class="sourceLine" id="cb123-117" title="117">EUCLEAN <span class="dv">117</span> Structure needs cleaning</a>
<a class="sourceLine" id="cb123-118" title="118">ENOTNAM <span class="dv">118</span> Not a XENIX named type file</a>
<a class="sourceLine" id="cb123-119" title="119">ENAVAIL <span class="dv">119</span> No XENIX semaphores available</a>
<a class="sourceLine" id="cb123-120" title="120">EISNAM <span class="dv">120</span> Is a named type file</a>
<a class="sourceLine" id="cb123-121" title="121">EREMOTEIO <span class="dv">121</span> Remote I/O error</a>
<a class="sourceLine" id="cb123-122" title="122">EDQUOT <span class="dv">122</span> Disk quota exceeded</a>
<a class="sourceLine" id="cb123-123" title="123">ENOMEDIUM <span class="dv">123</span> No medium found</a>
<a class="sourceLine" id="cb123-124" title="124">EMEDIUMTYPE <span class="dv">124</span> Wrong medium type</a>
<a class="sourceLine" id="cb123-125" title="125">ECANCELED <span class="dv">125</span> Operation canceled</a>
<a class="sourceLine" id="cb123-126" title="126">ENOKEY <span class="dv">126</span> Required key not available</a>
<a class="sourceLine" id="cb123-127" title="127">EKEYEXPIRED <span class="dv">127</span> Key has expired</a>
<a class="sourceLine" id="cb123-128" title="128">EKEYREVOKED <span class="dv">128</span> Key has been revoked</a>
<a class="sourceLine" id="cb123-129" title="129">EKEYREJECTED <span class="dv">129</span> Key was rejected by service</a>
<a class="sourceLine" id="cb123-130" title="130">EOWNERDEAD <span class="dv">130</span> Owner died</a>
<a class="sourceLine" id="cb123-131" title="131">ENOTRECOVERABLE <span class="dv">131</span> State not recoverable</a>
<a class="sourceLine" id="cb123-132" title="132">ERFKILL <span class="dv">132</span> Operation not possible due to RF-kill</a>
<a class="sourceLine" id="cb123-133" title="133">EHWPOISON <span class="dv">133</span> Memory page has hardware error</a>
<a class="sourceLine" id="cb123-134" title="134">ENOTSUP <span class="dv">95</span> Operation not supported</a></code></pre></div>
<h3 id="additional-helper-functions"><span class="header-section-number">6.5.3</span> Additional Helper Functions</h3>
<p>The C standard library includes two additional helper functions for dealing with errors:</p>
<table>
<thead>
<tr class="header">
<th>function</th>
<th>operation</th>
<th>defined in</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>perror()</code></td>
<td><strong>print</strong> an error to the console, corresponding to <sc>errno</sc></td>
<td><code>error.h</code></td>
</tr>
<tr class="even">
<td><code>strerror()</code></td>
<td><strong>return</strong> a <strong>string</strong> corresponding to <sc>errno</sc></td>
<td><code>string.h</code></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Check out their <code>man</code> pages for more information.</p>
<p>Consider the following example for understanding the use of <code>perror()</code> and <code>strerror()</code>:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb124-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb124-2" title="2"><span class="co"> * intro to error handling in C</span></a>
<a class="sourceLine" id="cb124-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb124-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb124-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb124-6" title="6"></a>
<a class="sourceLine" id="cb124-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb124-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb124-9" title="9"><span class="pp">#include </span><span class="im">&lt;error.h&gt;</span></a>
<a class="sourceLine" id="cb124-10" title="10"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb124-11" title="11"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb124-12" title="12"><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></a>
<a class="sourceLine" id="cb124-13" title="13"></a>
<a class="sourceLine" id="cb124-14" title="14"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb124-15" title="15">{</a>
<a class="sourceLine" id="cb124-16" title="16">    <span class="co">// try to create an array of LONG_MAX size, </span></a>
<a class="sourceLine" id="cb124-17" title="17">    <span class="co">// i.e. 9223372036854775807 bytes!</span></a>
<a class="sourceLine" id="cb124-18" title="18">    <span class="dt">char</span>* massive_array = (<span class="dt">char</span>*) malloc(LONG_MAX) ;</a>
<a class="sourceLine" id="cb124-19" title="19"></a>
<a class="sourceLine" id="cb124-20" title="20">    <span class="co">// Check if array was created</span></a>
<a class="sourceLine" id="cb124-21" title="21">    <span class="cf">if</span>( !massive_array )</a>
<a class="sourceLine" id="cb124-22" title="22">    {</a>
<a class="sourceLine" id="cb124-23" title="23">        <span class="co">// Uh oh! Looks like Array creation failed. </span></a>
<a class="sourceLine" id="cb124-24" title="24">        <span class="co">// print the errno</span></a>
<a class="sourceLine" id="cb124-25" title="25">        printf( <span class="st">&quot;errno = %d</span><span class="sc">\n</span><span class="st">&quot;</span>, errno ) ;</a>
<a class="sourceLine" id="cb124-26" title="26"></a>
<a class="sourceLine" id="cb124-27" title="27">        <span class="co">// Send custom error message and also print system message</span></a>
<a class="sourceLine" id="cb124-28" title="28">        perror( <span class="st">&quot;My Massive Array creation failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb124-29" title="29">    }</a>
<a class="sourceLine" id="cb124-30" title="30"></a>
<a class="sourceLine" id="cb124-31" title="31">    <span class="co">// can set errno explicitly</span></a>
<a class="sourceLine" id="cb124-32" title="32">    errno = <span class="dv">100</span> ;</a>
<a class="sourceLine" id="cb124-33" title="33">    <span class="dt">char</span>* error_string = strerror(errno) ;</a>
<a class="sourceLine" id="cb124-34" title="34">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">errno = %d</span><span class="sc">\t</span><span class="st"> (standard) String = %s</span><span class="sc">\n</span><span class="st">&quot;</span>, errno, error_string ) ;</a>
<a class="sourceLine" id="cb124-35" title="35"></a>
<a class="sourceLine" id="cb124-36" title="36">    <span class="co">// can give it any input, really</span></a>
<a class="sourceLine" id="cb124-37" title="37">    <span class="dt">unsigned</span> <span class="dt">int</span> my_errno = <span class="dv">9999</span> ;</a>
<a class="sourceLine" id="cb124-38" title="38">    error_string = strerror( my_errno ) ;</a>
<a class="sourceLine" id="cb124-39" title="39">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">my_errno = %d</span><span class="sc">\t</span><span class="st"> (custom) String = %s</span><span class="sc">\n</span><span class="st">&quot;</span>, my_errno, error_string ) ;</a>
<a class="sourceLine" id="cb124-40" title="40"></a>
<a class="sourceLine" id="cb124-41" title="41">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>) ;</a>
<a class="sourceLine" id="cb124-42" title="42">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb124-43" title="43">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>My Massive Array creation failed!: Cannot allocate memory
errno = 12

errno = 100  (standard) String = Network is down

my_errno = 9999  (custom) String = Unknown error 9999
</code></pre>
<p><strong>Note:</strong> look up <a href="https://www.tutorialspoint.com/c_standard_library/limits_h.htm"><code>&lt;limits.h&gt;</code></a> that defines some useful constants such as <code>INT_MAX</code>, <code>INT_MIN</code>, <code>LONG_MAX</code>, <em>etc.</em></p>
<p><strong>Note:</strong> when you return from a program with a non-zero value, it designates that your <em>program</em> had an error. This is why we see the <code>make</code> error when it runs your program.</p>
<h3 id="understand-return-values-of-unix-library-functions"><span class="header-section-number">6.5.4</span> Understand Return Values of UNIX library functions:</h3>
<p>Look at the function return values to understand the type (and identify if it is returning an <code>int</code> or a pointer).</p>
<pre><code>SYNOPSIS
       #include &lt;stdlib.h&gt;

       void *malloc(size_t size);
       ...</code></pre>
<ul>
<li>Read through the description of the function(s).</li>
<li>Read through the <code>RETURN VALUE</code> and <code>ERRORS</code> sections of the man page.</li>
</ul>
<pre><code>RETURN VALUE
       The malloc() and calloc() functions return a pointer to the allocated memory, which is  suitably  aligned  for
       any  built-in type.  On error, these functions return NULL.  NULL may also be returned by a successful call to
       malloc() with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero.
...
ERRORS
       calloc(), malloc(), realloc(), and reallocarray() can fail with the following error:

       ENOMEM Out  of  memory.
       ...
</code></pre>
<p>This explains why we got the error we did.</p>
<h3 id="in-class-exercise-printing-all-error-codesstrings-in-sequence"><span class="header-section-number">6.5.5</span> In-class Exercise | Printing <strong>all</strong> error codes/strings in sequence</h3>
<p>Write a <em>function</em> named, <code>print_error_codes()</code>, to print <em>all</em> the error codes and their corresponding strings <em>in sequence</em>, in the following format:</p>
<pre><code>Error No     String
-------------------
1            Operation not permitted
2            No such file or directory
...</code></pre>
<h1 id="processes"><span class="header-section-number">7</span> Processes</h1>
<p>Programming is hard. Really hard. When you write a program, you have to consider complex logic and the design of esoteric data-structures, all while desperately trying to avoid errors. It is an exercise that challenges all of our logical, creative, and risk management facilities. As such, programming is the act of <em>methodically conquering complexity</em> with our <em>ability to abstract</em>. We walk on the knives-edge of our own abstractions where we can barely, just barely, make progress and engineer amazing systems.</p>
<p>Imagine if when programming and debugging, we had to consider the actions and faults of <em>all other</em> programs running in the system? If your program crashed because one of your colleagues’ program had a bug, how could you make progress?</p>
<p>Luckily, we stand on the abstractions of those that came before us. A key abstraction provided by systems is that of <em>isolation</em> - that one program cannot arbitrarily interfere with the execution of another. This isolation is a core provision of Operating Systems (OSes), and a core abstraction they provide is the <strong>process</strong>. At the highest-level, each process can only corrupt its own memory, and a process that goes into an infinite loop cannot prevent another process for executing.</p>
<p>A process has a number of properties including:</p>
<ul>
<li>It contains the set of memory that is only accessible to that process. This memory includes the code, global data, stack, and dynamically allocated memory in the <em>heap</em>. Different processes have <em>disjoint</em> sets of memory, thus no matter how one process alters its own memory, it won’t interfere with the data-structures of another.</li>
<li>A number of <em>descriptors</em> identified by integers that enable the process to access the “resources” of the surrounding system including the file system, networking, and communication with other processes. When we <code>printf</code>, we interact with the descriptor to output to the terminal. The OS prevents processes from accessing and changing resources they shouldn’t have access to.</li>
<li>A set of unique identifiers including a process identifier (<code>pid</code>).</li>
<li>The “current working directory” for the process, analogous to <code>pwd</code>.</li>
<li>A owning user (e.g. <code>sibin</code>) for whom the process executes on the behalf of.</li>
<li>Each process has a <em>parent</em> - the process that created it, and that has the ability and responsibility oversee it (like a normal, human parent).</li>
<li>Arguments to the process often passed on the command line.</li>
<li>Environment variables that give the process information about the system’s configuration.</li>
</ul>
<p>Throughout the class we’ll uncover more and more of these properties, but in this lecture, we’ll focus on the lifecycle of a process, and its relationship to its parent. Processes are the abstraction that provide isolation between users, and between computations, thus it is the core of the <em>security</em> of the system.</p>
<h2 id="history-unix-posix-and-linux"><span class="header-section-number">7.1</span> History: UNIX, POSIX, and Linux</h2>
<p>UNIX is an old system, having its origins in 1969 at Bell Labs when it was created by Ken Thompson and Dennis Ritchie<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>. Time has shown it is an “oldie but goodie” – as most popular OSes are derived from it (OSX, Linux, Android, …). In the OS class, you’ll dive into an implementation of UNIX very close to what it was in those early years! The <a href="figures/unix.pdf">original paper</a> is striking in how uninteresting it is to most modern readers. UNIX is so profound that it has defined what is “normal” in most OSes.</p>
<blockquote>
<p>UNIX Philosophy: A core philosophy of UNIX is that applications should not be written as huge monolithic collections of millions of lines of code, and should instead be <em>composed</em> of smaller programs, each focusing on “doing one thing well”. Programs focus on inputting text, and outputting text. <em>Pipelines</em> of processes take a stream of text, and process on it, process after process to get an output. The final program is a composition of these processes composed to together using pipelines.</p>
</blockquote>
<p>In the early years, many different UNIX variants were competing for market-share along-side the likes of DOS, Windows, OS2, etc… This led to differences between the UNIX variants which prevented programmers from effectively writing programs that would work across the variants. In response to this, in the late 1980s, POSIX standardized many aspects of UNIX including command-line programs and the standard library APIs. <code>man</code> pages are documentation for what is often part of the POSIX specification. I’ll use the term UNIX throughout the class, but often mean POSIX. You can think of Linux as an implementation of POSIX and as a variant of UNIX.</p>
<p>UNIX has been taken into many different directions. Android and iOS layer a mobile runtime on top of UNIX; OSX and Ubuntu layer modern graphics and system management on top of UNIX, and even Windows Subsystem for Linux (WSL) enables you to run a POSIX environment inside of Windows. In many ways, UNIX has won. However, it has won be being adapted to different domains – you might be a little hard-pressed looking at the APIs for some of those systems to understand that it is UNIX under the hood. Regardless, in this class, we’ll be diving into UNIX and its APIs to better understand the core technology underlying most systems we use.</p>
<p>The core UNIX philosophy endures, but has changed shape. In addition to the pervasive deployment of UNIX, Python is popular as it is has good support to compose together disparate services and libraries, and applications are frequently compositions of various REST/CRUD webservice APIs, and <code>json</code> is the unified language in which data is shared. # Processes</p>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/processes.html#/">Slides</a></p>
<h3 id="tackling-complexity"><span class="header-section-number">7.1.1</span> tackling complexity</h3>
<span class="fragment fade-in">
<ul>
<li>
modern computers → 100s of programs
</li>
<li>
programs can <b>interfere</b> with each other
</li>
<li>
complex!
</li>
</ul>
<p></span></p>
<p>Consider the following UNIX/Linux command:</p>
<pre><code>$ ps</code></pre>
<p>The output looks like:</p>
<pre><code>    PID TTY          TIME CMD
2384593 pts/15   00:00:00 bash
2384610 pts/15   00:00:00 ps</code></pre>
<p>This shows that two processes are running, <em>for the current user</em>: - <code>bash</code>: the shell/terminal that is running (where you are typing yoru commands) - <code>ps</code>: the command we just ran to see the lis of processes</p>
<p>We can expand this by providing some <strong>flags</strong> to <code>ps</code>, <em>e.g.,</em></p>
<pre><code>$ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0 170060 14172 ?        Ss   Oct17   2:48 /sbin/init
root           2  0.0  0.0      0     0 ?        S    Oct17   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [rcu_gp]
root           4  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [rcu_par_gp]
root           6  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [kworker/0:0H-kblockd]
root           9  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [mm_percpu_wq]
root          10  0.0  0.0      0     0 ?        S    Oct17   0:05 [ksoftirqd/0]
root          11  0.1  0.0      0     0 ?        I    Oct17  13:03 [rcu_sched]
root          12  0.0  0.0      0     0 ?        S    Oct17   0:01 [migration/0]
root          13  0.0  0.0      0     0 ?        S    Oct17   0:00 [idle_inject/0]
root          15  0.0  0.0      0     0 ?        S    Oct17   0:00 [cpuhp/0]
root          16  0.0  0.0      0     0 ?        S    Oct17   0:00 [cpuhp/1]
root          17  0.0  0.0      0     0 ?        S    Oct17   0:00 [idle_inject/1]
root          18  0.0  0.0      0     0 ?        S    Oct17   0:03 [migration/1]
root          19  0.0  0.0      0     0 ?        S    Oct17   0:01 [ksoftirqd/1]
root          21  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [kworker/1:0H-kblockd]
root          23  0.0  0.0      0     0 ?        S    Oct17   0:00 [cpuhp/2]
root          24  0.0  0.0      0     0 ?        S    Oct17   0:00 [idle_inject/2]
root          25  0.0  0.0      0     0 ?        S    Oct17   0:04 [migration/2]
root          26  0.0  0.0      0     0 ?        S    Oct17   0:01 [ksoftirqd/2]
root          28  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [kworker/2:0H-kblockd]
root          29  0.0  0.0      0     0 ?        S    Oct17   0:00 [cpuhp/3]
root          30  0.0  0.0      0     0 ?        S    Oct17   0:00 [idle_inject/3]
root          31  0.0  0.0      0     0 ?        S    Oct17   0:04 [migration/3]
root          32  0.0  0.0      0     0 ?        S    Oct17   0:01 [ksoftirqd/3]
root          34  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [kworker/3:0H]
root          35  0.0  0.0      0     0 ?        S    Oct17   0:00 [cpuhp/4]
root          36  0.0  0.0      0     0 ?        S    Oct17   0:00 [idle_inject/4]
root          37  0.0  0.0      0     0 ?        S    Oct17   0:04 [migration/4]
root          38  0.0  0.0      0     0 ?        S    Oct17   0:01 [ksoftirqd/4]
root          40  0.0  0.0      0     0 ?        I&lt;   Oct17   0:00 [kworker/4:0H-kblockd]
root          41  0.0  0.0      0     0 ?        S    Oct17   0:00 [cpuhp/5]
...</code></pre>
<p><strong>Note:</strong> we see the list of processes for <strong>all</strong> users. The above is not a complete list, as it would have been really long.</p>
<p>We can <em>filter</em> out results too…</p>
<pre><code>[sibin@ubuntu-vlab01 ~] ps aux | grep sibin
root     2384373  0.0  0.0  14984  9936 ?        Ss   17:14   0:00 sshd: sibin [priv]
sibin    2384387  0.0  0.0  18744  9960 ?        Ss   17:14   0:00 /lib/systemd/systemd --user
sibin    2384388  0.0  0.0 172308  6144 ?        S    17:14   0:00 (sd-pam)
sibin    2384397  0.0  0.0 277760 14352 ?        Ssl  17:14   0:00 /usr/bin/pulseaudio --daemonize=no --log-target=journal
sibin    2384399  0.0  0.0 508784 24620 ?        SNsl 17:14   0:00 /usr/libexec/tracker-miner-fs
sibin    2384407  0.0  0.0   8248  5228 ?        Ss   17:14   0:00 /usr/bin/dbus-daemon --session --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
sibin    2384426  0.0  0.0 237112  7560 ?        Ssl  17:14   0:00 /usr/libexec/gvfsd
sibin    2384431  0.0  0.0 312808  6600 ?        Sl   17:14   0:00 /usr/libexec/gvfsd-fuse /run/user/1003/gvfs -f -o big_writes
sibin    2384439  0.0  0.0 312076  9944 ?        Ssl  17:14   0:00 /usr/libexec/gvfs-udisks2-volume-monitor
sibin    2384450  0.0  0.0 314124  9044 ?        Ssl  17:14   0:00 /usr/libexec/gvfs-afc-volume-monitor
sibin    2384455  0.0  0.0 235512  7096 ?        Ssl  17:14   0:00 /usr/libexec/gvfs-gphoto2-volume-monitor
sibin    2384460  0.0  0.0 233276  6140 ?        Ssl  17:14   0:00 /usr/libexec/gvfs-goa-volume-monitor
sibin    2384464  0.0  0.0 550560 34816 ?        Sl   17:14   0:00 /usr/libexec/goa-daemon
sibin    2384471  0.0  0.0 312152  9144 ?        Sl   17:14   0:00 /usr/libexec/goa-identity-service
sibin    2384477  0.0  0.0 233100  6288 ?        Ssl  17:14   0:00 /usr/libexec/gvfs-mtp-volume-monitor
sibin    2384592  0.0  0.0  15136  6736 ?        S    17:14   0:00 sshd: sibin@pts/15
sibin    2384593  0.0  0.0   9420  6088 pts/15   Ss   17:14   0:00 -bash
sibin    2385179  0.0  0.0   9760  3996 pts/15   R+   17:19   0:00 ps aux
sibin    2385180  0.0  0.0   6432  2620 pts/15   S+   17:19   0:00 grep --color sibin</code></pre>
<p>The above command (<code>ps aux | grep sibin</code>) is sending the output of one command, <code>ps aux</code> to the input of another command, <code>grep sibin</code> (using a “<em>pipe</em>”). Hence, we are only listing those lines from the output of <code>ps aux</code> that has a string that matches the word, <code>sibin</code>.</p>
<p><strong>Note:</strong> neither command/process (<code>ps</code>/<code>grep</code>) needs to be aware of each other. hey both carry out their normal functionality. It if the beauty and elgance of the UNIX design that allows this chaining of processes to work as well as it does. Technically <em>most</em> UNIX commands/processes can be chained together to get very advance functionality from very simple components.</p>
<h2 id="process"><span class="header-section-number">7.2</span> process</h2>
<ul>
<li>process ID <code>pid</code></li>
<li>memory acessible only to process
<ul>
<li>code, global data, stack, heap]</li>
</ul></li>
<li>integer descriptors that identify resources
<ul>
<li>[file system, networking, communication]</li>
</ul></li>
<li>current working directory <code>pwd</code></li>
<li>owner <code>sibin</code></li>
<li>parent → creator, responsible for it</li>
<li>arguments passed from command line</li>
<li>environment variables → system config information</li>
</ul>
<p><img src="./figures/process.png" width="400">``</p>
<h2 id="fork"><span class="header-section-number">7.3</span> <code>fork()</code></h2>
<p>Create a new, child, process → from the <strong>state of the calling process</strong></p>
<p>Defined in <code>&lt;unistd.h&gt;</code>.</p>
<h3 id="after-fork"><span class="header-section-number">7.3.1</span> after <code>fork()</code></h3>
<p><img src="./figures/process.png" width="200"> <img src="./figures/process.png" width="200"></p>
<h3 id="process-creationterminationcoordination-api"><span class="header-section-number">7.3.2</span> process creation/termination/coordination API</h3>
<p>Let’s take a look at all the function available in <code>C</code> for dealing with processes.</p>
<table>
<thead>
<tr class="header">
<th>name</th>
<th>action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fork</code></td>
<td>create process</td>
</tr>
<tr class="even">
<td><code>getpid</code></td>
<td>get ID of process</td>
</tr>
<tr class="odd">
<td><code>getppid</code></td>
<td>get ID of parent</td>
</tr>
<tr class="even">
<td><code>exit</code></td>
<td>terminate a process</td>
</tr>
<tr class="odd">
<td><code>wait</code></td>
<td>parent waiting for child to exit</td>
</tr>
<tr class="even">
<td><code>exec</code></td>
<td>new program from <em>current process</em> <a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>.</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="process-vs-program"><span class="header-section-number">7.3.2.1</span> process vs program</h4>
<ul>
<li>program → <strong>compiled</strong> version of code</li>
<li>process → program <strong>executing</strong> in memory</li>
</ul>
<h3 id="pdt_t"><span class="header-section-number">7.3.3</span> <code>pdt_t</code></h3>
<ul>
<li>process identifier defined in <code>&lt;sys/types.h&gt;</code></li>
<li>same as a (signed) <code>int</code></li>
</ul>
<h3 id="lets-revisit-fork"><span class="header-section-number">7.3.4</span> let’s revisit <code>fork()</code></h3>
<p>A very <em>simple</em> interface, for a very <em>complex</em> mechanism!</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb133-1" title="1">pid_t fork(<span class="dt">void</span>);</a></code></pre></div>
<p>The new (“child”) process get a copy of the resources as shown before:</p>
<p><img src="./figures/process.png" width="200"> <img src="./figures/process.png" width="200"> <br> <br></p>
<p><strong>Note:</strong> some important nuances: - the child starting executing <strong>from the <code>fork()</code> instruction onwards</strong>! - all previous instructions don’t matter for the child - the parent, on the other hand, will <strong>also continue to execute</strong>, in <strong>parallel</strong> with the child.</p>
<p><br></p>
<div class="sourceCode" id="cb134"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb134-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb134-2" title="2"><span class="co"> * intro to fork</span></a>
<a class="sourceLine" id="cb134-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb134-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb134-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb134-6" title="6"></a>
<a class="sourceLine" id="cb134-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb134-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb134-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb134-10" title="10"></a>
<a class="sourceLine" id="cb134-11" title="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb134-12" title="12">{</a>
<a class="sourceLine" id="cb134-13" title="13">    printf( <span class="st">&quot;BEFORE calling fork()&quot;</span> ) ;</a>
<a class="sourceLine" id="cb134-14" title="14"></a>
<a class="sourceLine" id="cb134-15" title="15">    pid_t pid = fork() ;</a>
<a class="sourceLine" id="cb134-16" title="16"></a>
<a class="sourceLine" id="cb134-17" title="17">    printf( <span class="st">&quot;AFTER calling fork()&quot;</span> ) ;</a>
<a class="sourceLine" id="cb134-18" title="18"></a>
<a class="sourceLine" id="cb134-19" title="19">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb134-20" title="20">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb134-21" title="21">}</a></code></pre></div>
<p>The output from the above code:</p>
<pre><code>BEFORE calling fork()AFTER calling fork()

BEFORE calling fork()AFTER calling fork()</code></pre>
<p>Hold on a second! We said that the child starts executing <strong>from the <code>fork()</code> instruction</strong> and not before. So, why is the <code>BEFORE calling fork()</code> being printed <em>twice</em>? We should, ideally, see the following behavior: - <em>one</em> instance of <code>BEFORE calling fork()</code> → parent only - <em>two</em> instances of <code>AFTER calling fork()</code> → parent and child</p>
<blockquote>
<p>We are seeing a side-effect/vagary of the implementation of <code>printf()</code> and really any function that outputs to a standard destination <em>e.g.</em>, <code>stdio</code> (standard input/output), <code>stderr</code> (standard error), <em>etc.</em> These output “locations” (rather called, <em>"streams</em>) are <strong>buffered</strong>, <em>i.e.,</em> instead of immediately writing to the screen (in the case of <code>stdio</code>), the string/data are written to temporary inernal buffer that is then <em>periodically cleansed</em> (<em>i.e.,</em> written out to the screen). The buffers are cleared out in the following situations: - when the buffer gets full (different systems have varied sizes, <em>e.g.,</em> <code>64k</code>) - when the buffer is explicitly flushed, <em>e.g.</em>, using <code>stdout</code> - when a newline character (<code>\n</code>) is printed</p>
</blockquote>
<p>So, in the above code example, while the first <code>printf()</code> is written only <em>once</em> (by the parent), the <code>printf("\n")</code> statement is present in both, parent and child. Remember that when a fork happens, the child gets a copy of <em>all</em> resources of the parent and that include the output buffer – which, at that point, includes the <code>BEFORE calling fork()</code> text. After the <code>fork()</code>, there are <em>two</em> processes with unflushed output buffers, the parent and the child. Hence, the <code>\n</code> causes <em>both</em> buffers to be flushed thus resulting in the above output.</p>
<p>There are two ways to fix this problem and get the desired behavior: 1. add <code>\n</code> to the end of <em>Every</em> <code>printf()</code> 2. force a flush after every <code>printf()</code> or perhaps just before every <code>fork()</code></p>
<p>The call to flush a stream is:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb136-1" title="1"><span class="dt">int</span> fflush( <span class="dt">FILE</span>* stream ) ; </a></code></pre></div>
<p>defined in <code>&lt;stdio.h&gt;</code>.</p>
<p>So, we let’s look at the above code again, this time with <code>fflush</code> (since the <code>\n</code> method is trivial and is left as an exercise):</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb137-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb137-2" title="2"><span class="co"> * intro to fork</span></a>
<a class="sourceLine" id="cb137-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb137-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb137-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb137-6" title="6"></a>
<a class="sourceLine" id="cb137-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb137-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb137-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb137-10" title="10"></a>
<a class="sourceLine" id="cb137-11" title="11"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb137-12" title="12">{</a>
<a class="sourceLine" id="cb137-13" title="13">    printf( <span class="st">&quot;BEFORE calling fork()&quot;</span> ) ;</a>
<a class="sourceLine" id="cb137-14" title="14">    fflush(stdout) ; <span class="co">// to flush the standard output</span></a>
<a class="sourceLine" id="cb137-15" title="15"></a>
<a class="sourceLine" id="cb137-16" title="16">    pid_t pid = fork() ;</a>
<a class="sourceLine" id="cb137-17" title="17"></a>
<a class="sourceLine" id="cb137-18" title="18">    printf( <span class="st">&quot;AFTER calling fork()&quot;</span> ) ;</a>
<a class="sourceLine" id="cb137-19" title="19"></a>
<a class="sourceLine" id="cb137-20" title="20">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb137-21" title="21">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb137-22" title="22">}</a></code></pre></div>
<p>The output is:</p>
<pre><code>BEFORE calling fork()AFTER calling fork()

AFTER calling fork()</code></pre>
<p>See <code>man fflush</code> for more information.</p>
<h3 id="fork-return-values"><span class="header-section-number">7.3.5</span> <code>fork()</code> return values</h3>
<p>Now, let’s look back at the interface for:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb139-1" title="1">pid_t fork(<span class="dt">void</span>);</a></code></pre></div>
<p>We see that is returns a <code>pid_t</code>. <code>fork()</code> returns <em>two distinct values</em>, depending on which process the call is returning to:</p>
<table>
<thead>
<tr class="header">
<th>return value</th>
<th>called from</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>actual pid</td>
<td>parent</td>
<td>child created</td>
</tr>
<tr class="even">
<td><code>0</code></td>
<td>child</td>
<td>inside child</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="fork-questions"><span class="header-section-number">7.3.6</span> <code>fork</code> Questions</h3>
<ol type="1">
<li><p>How many processes (not including the initial one) are created in the following?</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb140-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb140-2" title="2"></a>
<a class="sourceLine" id="cb140-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb140-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb140-5" title="5">{</a>
<a class="sourceLine" id="cb140-6" title="6">    fork();</a>
<a class="sourceLine" id="cb140-7" title="7">    fork();</a>
<a class="sourceLine" id="cb140-8" title="8"></a>
<a class="sourceLine" id="cb140-9" title="9">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb140-10" title="10">}</a></code></pre></div></li>
<li><p>What are the <em>possible outputs</em> for:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb141-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb141-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb141-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb141-4" title="4"></a>
<a class="sourceLine" id="cb141-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb141-6" title="6">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb141-7" title="7">{</a>
<a class="sourceLine" id="cb141-8" title="8">    pid_t parent = getpid();</a>
<a class="sourceLine" id="cb141-9" title="9">    pid_t child;</a>
<a class="sourceLine" id="cb141-10" title="10"></a>
<a class="sourceLine" id="cb141-11" title="11">    child = fork();</a>
<a class="sourceLine" id="cb141-12" title="12">    <span class="cf">if</span> (getpid() == parent) {</a>
<a class="sourceLine" id="cb141-13" title="13">        printf(<span class="st">&quot;p&quot;</span>);</a>
<a class="sourceLine" id="cb141-14" title="14">        wait(NULL); <span class="co">/* why is `NULL` OK here? */</span></a>
<a class="sourceLine" id="cb141-15" title="15">        printf(<span class="st">&quot;w&quot;</span>);</a>
<a class="sourceLine" id="cb141-16" title="16">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb141-17" title="17">        printf(<span class="st">&quot;c&quot;</span>);</a>
<a class="sourceLine" id="cb141-18" title="18">    }</a>
<a class="sourceLine" id="cb141-19" title="19"></a>
<a class="sourceLine" id="cb141-20" title="20">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb141-21" title="21">}</a></code></pre></div></li>
</ol>
<h2 id="wait"><span class="header-section-number">7.4</span> <code>wait()</code></h2>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/processes.html#/42">Slides</a></p>
<p>Parents are responsible for managing their children!</p>
<p><img src="./figures/jackjack.gif" width="400"></p>
<p>so, they…<code>wait()</code>!</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb142-1" title="1">pid_t wait(<span class="dt">int</span> *wstatus)</a></code></pre></div>
<ul>
<li>wait for state changes in a <strong>child</strong></li>
<li>called by a <strong>parent</strong></li>
<li>parents can wait for,</li>
<li><em>all</em> children</li>
<li><em>specific</em> child</li>
<li>a <em>subset</em> of children</li>
</ul>
<p>defined in <code>&lt;sys/wait.h&gt;</code></p>
<p>A child changes “<em>state</em>” if one of following happens: - child <strong>terminated/exited</strong> - child was <strong>stopped by a signal</strong> * - child was <strong>resumed</strong> by a signal</p>
<p>[* will discuss signals later]</p>
<table>
<thead>
<tr class="header">
<th>child status</th>
<th>action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>already changed</td>
<td><strong>return immediately</strong> to parent</td>
</tr>
<tr class="even">
<td>executing normally</td>
<td>parent <strong>waits</strong>/<strong>blocks</strong> for child</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="wait-return-value"><span class="header-section-number">7.4.0.1</span> <code>wait()</code> return value</h4>
<table>
<thead>
<tr class="header">
<th>return value</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pid via <code>pid_t</code></td>
<td>pid of terminated child</td>
</tr>
<tr class="even">
<td><code>-1</code></td>
<td>error</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb143"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb143-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb143-2" title="2"><span class="co"> * intro to fork() and wait()</span></a>
<a class="sourceLine" id="cb143-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb143-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb143-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb143-6" title="6"></a>
<a class="sourceLine" id="cb143-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb143-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb143-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb143-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb143-11" title="11"></a>
<a class="sourceLine" id="cb143-12" title="12"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb143-13" title="13">{</a>
<a class="sourceLine" id="cb143-14" title="14">        pid_t child_pid ;</a>
<a class="sourceLine" id="cb143-15" title="15">        pid_t parent ;</a>
<a class="sourceLine" id="cb143-16" title="16"></a>
<a class="sourceLine" id="cb143-17" title="17">        printf( <span class="st">&quot;------------------------------</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb143-18" title="18">        printf( <span class="st">&quot;:::BEFORE::: \</span></a>
<a class="sourceLine" id="cb143-19" title="19"><span class="st">                 getpid() = %d \</span></a>
<a class="sourceLine" id="cb143-20" title="20"><span class="st">                 parent = %d \</span></a>
<a class="sourceLine" id="cb143-21" title="21"><span class="st">                 child = %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb143-22" title="22">             getpid(), child_pid, parent ) ;</a>
<a class="sourceLine" id="cb143-23" title="23">        printf( <span class="st">&quot;------------------------------</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb143-24" title="24"></a>
<a class="sourceLine" id="cb143-25" title="25">        <span class="co">// create 5 children</span></a>
<a class="sourceLine" id="cb143-26" title="26">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; <span class="dv">5</span> ; ++i )</a>
<a class="sourceLine" id="cb143-27" title="27">        {</a>
<a class="sourceLine" id="cb143-28" title="28">                child_pid = fork() ;</a>
<a class="sourceLine" id="cb143-29" title="29"></a>
<a class="sourceLine" id="cb143-30" title="30">                <span class="co">// make sure the children don&#39;t create more children!</span></a>
<a class="sourceLine" id="cb143-31" title="31">                <span class="cf">if</span>(!child_pid)</a>
<a class="sourceLine" id="cb143-32" title="32">                        <span class="cf">break</span> ;</a>
<a class="sourceLine" id="cb143-33" title="33">        }</a>
<a class="sourceLine" id="cb143-34" title="34"></a>
<a class="sourceLine" id="cb143-35" title="35">        <span class="co">// wait for the kids</span></a>
<a class="sourceLine" id="cb143-36" title="36">        <span class="dt">int</span> wait_status ;</a>
<a class="sourceLine" id="cb143-37" title="37">        pid_t wait_result = wait( &amp;wait_status ) ;</a>
<a class="sourceLine" id="cb143-38" title="38"></a>
<a class="sourceLine" id="cb143-39" title="39">        printf( <span class="st">&quot;:::AFTER::: &quot;</span> ) ;</a>
<a class="sourceLine" id="cb143-40" title="40">        child_pid ? printf( <span class="st">&quot;---PARENT!--- &quot;</span> ) : printf( <span class="st">&quot;---CHILD!--- &quot;</span> ) ;</a>
<a class="sourceLine" id="cb143-41" title="41">        printf( <span class="st">&quot;getpid() = %d \</span></a>
<a class="sourceLine" id="cb143-42" title="42"><span class="st">                 parent = %d \</span></a>
<a class="sourceLine" id="cb143-43" title="43"><span class="st">                 child = %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb143-44" title="44">             getpid(), child_pid, parent ) ;</a>
<a class="sourceLine" id="cb143-45" title="45"></a>
<a class="sourceLine" id="cb143-46" title="46">        printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb143-47" title="47">        <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb143-48" title="48">}</a></code></pre></div>
<p><strong>Note:</strong> the output can <strong>vary!</strong> Depends on which process gets to writing its buffer first.</p>
<pre><code>------------------------------
:::BEFORE:::         getpid() = 2492442          parent = 1612788000         child = 374366320
------------------------------
:::AFTER::: ---CHILD!--- getpid() = 2492443          parent = 0          child = 374366320

:::AFTER::: ---CHILD!--- getpid() = 2492444          parent = 0          child = 374366320

:::AFTER::: ---CHILD!--- getpid() = 2492445          parent = 0          child = 374366320

:::AFTER::: ---PARENT!--- getpid() = 2492442         parent = 2492447        child = 374366320
:::AFTER::: ---CHILD!--- getpid() = 2492446          parent = 0          child = 374366320


:::AFTER::: ---CHILD!--- getpid() = 2492447          parent = 0          child = 374366320</code></pre>
<p>OR</p>
<pre><code>------------------------------
:::BEFORE:::         getpid() = 2492454          parent = -2016386784        child = 780062336
------------------------------
:::AFTER::: ---CHILD!--- getpid() = 2492455          parent = 0          child = 780062336

:::AFTER::: ---CHILD!--- getpid() = 2492456          parent = 0          child = 780062336

:::AFTER::: ---CHILD!--- getpid() = 2492457          parent = 0          child = 780062336

:::AFTER::: ---CHILD!--- getpid() = 2492458          parent = 0          child = 780062336
:::AFTER::: ---PARENT!--- getpid() = 2492454         parent = 2492459        child = 780062336


:::AFTER::: ---CHILD!--- getpid() = 2492459          parent = 0          child = 780062336</code></pre>
<p>OR many other combinations. We are seeing the <strong>inherent nondeterminism</strong> in parallel execution.</p>
<h3 id="process-vs-thread"><span class="header-section-number">7.4.1</span> process vs thread</h3>
<p>A minor detour. One may ver well be confused about the difference between a “process” and a “thread”. The main difference is that a process, <em>owns resources</em> while a thread is just a <em>unit of execution</em>. This table should help clarify the difference:</p>
<table>
<thead>
<tr class="header">
<th>process</th>
<th>thread</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>owns resources</td>
<td>unit of execution</td>
</tr>
<tr class="even">
<td>isolation</td>
<td>share memory</td>
</tr>
<tr class="odd">
<td>system call*</td>
<td>no system call*</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>* for creation: <em>i.e.,</em> the creation of a process is a <strong>system call</strong>, <em>i.e.,</em> we need to ask the operating system to help us since the OS is what allocates resources to newly formed procsses. A new thread, on the other hand, doesn’t require us to invoke a system call and is often created using <em>user-space libraries</em> (*e.g., look up <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">pthreads</a>).</p>
<h2 id="exit"><span class="header-section-number">7.5</span> <code>exit()</code></h2>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/processes-2-exit.html#/">Slides</a></p>
<p><code>exit</code> is the function that used to terminate the current process.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb146-1" title="1"><span class="dt">void</span> exit(<span class="dt">int</span> status);</a></code></pre></div>
<p>as defined in <code>&lt;stdlib.h</code>. The input argument is the <strong>exit status</strong>:</p>
<table>
<thead>
<tr class="header">
<th>value</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0</code></td>
<td><code>EXIT_SUCCESS</code></td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td><code>EXIT_FAILURE</code></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>And note that <code>exit()</code> does not <em>explicitly</em> return any value. All the information is passed via the <code>status</code> field.</p>
<p>The following two pieces of code are identical:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb147-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb147-2" title="2"></a>
<a class="sourceLine" id="cb147-3" title="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb147-4" title="4">{</a>
<a class="sourceLine" id="cb147-5" title="5">    exit(EXIT_SUCCESS) ;</a>
<a class="sourceLine" id="cb147-6" title="6">}</a></code></pre></div>
<div class="sourceCode" id="cb148"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb148-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb148-2" title="2"></a>
<a class="sourceLine" id="cb148-3" title="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb148-4" title="4">{</a>
<a class="sourceLine" id="cb148-5" title="5">    <span class="cf">return</span> EXIT_SUCCESS ;</a>
<a class="sourceLine" id="cb148-6" title="6">}</a></code></pre></div>
<p><br></p>
<h3 id="interpreting-exit-status"><span class="header-section-number">7.5.1</span> Interpreting <code>exit()</code> status</h3>
<p>Despite <code>wait</code>’s status return value being a simple <code>int</code>, the <em>bits</em> of that integer mean very specific things. See the <code>man</code> page for <code>wait</code> for details, but we can use a set of functions (really “macros”) to interpret the status value: - <code>WIFEXITED(status)</code> will return <code>0</code> if the process didn’t exit (e.g. if it faulted instead), and non-<code>0</code> otherwise - <code>WEXITSTATUS(status)</code> will get the intuitive integer value that was passed to <code>exit</code> (or returned from <code>main</code>), but assumes that this value is only 8 bits large, max (thus has a maximum value of 256)</p>
<p>both defined in <code>&lt;sys/wait.h&gt;</code>.</p>
<h3 id="relationship-between-wait-and-exit"><span class="header-section-number">7.5.2</span> Relationship between <code>wait()</code> and <code>exit()</code></h3>
<p>The relationship between these two calls can be confusing but they are <em>closelfy related</em>.</p>
<ol type="1">
<li>first <code>fork()</code> creates a new child:</li>
</ol>
<figure>
<img src="./figures/wait_exit2.png" alt="Wait and Exit" /><figcaption>Wait and Exit</figcaption>
</figure>
<ol start="2" type="1">
<li>if the parent is waiting for the child, then the return value of <code>wait()</code> is the <code>pid</code> of that child.</li>
</ol>
<figure>
<img src="./figures/wait_exit3.png" alt="Wait and Exit" /><figcaption>Wait and Exit</figcaption>
</figure>
<ol start="3" type="1">
<li>when the <strong>child</strong> calls <code>exit(status)</code> then that status is written into the status variable of the <code>wait(&amp;status)</code> call.</li>
</ol>
<figure>
<img src="./figures/wait_exit4.png" alt="Wait and Exit" /><figcaption>Wait and Exit</figcaption>
</figure>
<p><strong>Note:</strong> the interface for <code>wait()</code>:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb149-1" title="1">pid_t wait(<span class="dt">int</span> *wstatus)</a></code></pre></div>
<p>the input is a <strong>pointer to an integer</strong>. Hence, the value passed from <code>exit()</code> is written into that integer and is <strong>accessible after the <code>wait()</code> call returns</strong>.</p>
<ol start="4" type="1">
<li>this goes for <em>any</em> <code>exit()</code> call from the child.</li>
</ol>
<figure>
<img src="./figures/wait_exit5.png" alt="Wait and Exit" /><figcaption>Wait and Exit</figcaption>
</figure>
<div class="sourceCode" id="cb150"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb150-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb150-2" title="2"><span class="co"> * intro to fork(), wait() and exit()</span></a>
<a class="sourceLine" id="cb150-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb150-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb150-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb150-6" title="6"></a>
<a class="sourceLine" id="cb150-7" title="7"></a>
<a class="sourceLine" id="cb150-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span><span class="pp">     </span><span class="co">// fork(), getpid()</span></a>
<a class="sourceLine" id="cb150-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span><span class="pp">   </span><span class="co">// wait()</span></a>
<a class="sourceLine" id="cb150-10" title="10"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span><span class="pp">     </span><span class="co">// exit()</span></a>
<a class="sourceLine" id="cb150-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb150-12" title="12"></a>
<a class="sourceLine" id="cb150-13" title="13"></a>
<a class="sourceLine" id="cb150-14" title="14"><span class="pp">#define NUM_CHILDREN 5</span></a>
<a class="sourceLine" id="cb150-15" title="15"></a>
<a class="sourceLine" id="cb150-16" title="16"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb150-17" title="17">{</a>
<a class="sourceLine" id="cb150-18" title="18">    pid_t pid, child_pid ;</a>
<a class="sourceLine" id="cb150-19" title="19"></a>
<a class="sourceLine" id="cb150-20" title="20">    <span class="co">// create multiple children </span></a>
<a class="sourceLine" id="cb150-21" title="21">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; NUM_CHILDREN ; ++i )</a>
<a class="sourceLine" id="cb150-22" title="22">    {</a>
<a class="sourceLine" id="cb150-23" title="23">        pid = fork() ;</a>
<a class="sourceLine" id="cb150-24" title="24">        <span class="cf">if</span>( !pid )</a>
<a class="sourceLine" id="cb150-25" title="25">        {</a>
<a class="sourceLine" id="cb150-26" title="26">            <span class="co">// we are inside the child</span></a>
<a class="sourceLine" id="cb150-27" title="27">            printf( <span class="st">&quot;---CHILD %d--- exiting with %d</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid(), i+<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb150-28" title="28"></a>
<a class="sourceLine" id="cb150-29" title="29">            <span class="co">// both of these terminate immediately AND return the same value</span></a>
<a class="sourceLine" id="cb150-30" title="30">            <span class="co">// identical, really!</span></a>
<a class="sourceLine" id="cb150-31" title="31">            <span class="cf">if</span>( i % <span class="dv">2</span> )</a>
<a class="sourceLine" id="cb150-32" title="32">                exit( i+<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb150-33" title="33">            <span class="cf">else</span></a>
<a class="sourceLine" id="cb150-34" title="34">                <span class="cf">return</span> i+<span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb150-35" title="35">        }</a>
<a class="sourceLine" id="cb150-36" title="36">    }</a>
<a class="sourceLine" id="cb150-37" title="37"></a>
<a class="sourceLine" id="cb150-38" title="38">    <span class="co">/* Inside the parent, wait until the wait() call returns -1 -&gt; no more children left</span></a>
<a class="sourceLine" id="cb150-39" title="39"><span class="co">     * take the return value from wait(), put it in &quot;child_pid&quot; and compare that to &quot;-1&quot;</span></a>
<a class="sourceLine" id="cb150-40" title="40"><span class="co">     */</span></a>
<a class="sourceLine" id="cb150-41" title="41">    <span class="dt">int</span> status ;</a>
<a class="sourceLine" id="cb150-42" title="42">    <span class="cf">while</span>( ( child_pid = wait( &amp;status ) ) != -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb150-43" title="43">    {</a>
<a class="sourceLine" id="cb150-44" title="44">        <span class="co">// all children are done!</span></a>
<a class="sourceLine" id="cb150-45" title="45">        <span class="cf">if</span>( WIFEXITED(status) )</a>
<a class="sourceLine" id="cb150-46" title="46">        {</a>
<a class="sourceLine" id="cb150-47" title="47">            <span class="co">// check that the process didn&#39;t terminate with any errors</span></a>
<a class="sourceLine" id="cb150-48" title="48">            <span class="co">// note that the output of WIFEEXITED is non-zero for normal exit</span></a>
<a class="sourceLine" id="cb150-49" title="49"></a>
<a class="sourceLine" id="cb150-50" title="50">            printf( <span class="st">&quot;Inside :::PARENT::: where child %d exited with status: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb150-51" title="51">                    child_pid, </a>
<a class="sourceLine" id="cb150-52" title="52">                    (<span class="dt">char</span>) WEXITSTATUS(status) ) ;</a>
<a class="sourceLine" id="cb150-53" title="53">        }</a>
<a class="sourceLine" id="cb150-54" title="54">    }</a>
<a class="sourceLine" id="cb150-55" title="55"></a>
<a class="sourceLine" id="cb150-56" title="56">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb150-57" title="57">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb150-58" title="58">    <span class="co">// exit(EXIT_SUCCESS) ;</span></a>
<a class="sourceLine" id="cb150-59" title="59">    <span class="co">// return EXIT_SUCCESS ;</span></a>
<a class="sourceLine" id="cb150-60" title="60">}</a></code></pre></div>
<p><strong>Note:</strong> the output of this is alo <strong>non-deterministic</strong> as we can see with multiple runs of it:</p>
<pre><code>---CHILD 2566089--- exiting with 1
---CHILD 2566090--- exiting with 2
---CHILD 2566091--- exiting with 3
---CHILD 2566092--- exiting with 4
Inside :::PARENT::: where child 2566089 exited with status: 1
---CHILD 2566093--- exiting with 5
Inside :::PARENT::: where child 2566090 exited with status: 2
Inside :::PARENT::: where child 2566091 exited with status: 3
Inside :::PARENT::: where child 2566092 exited with status: 4
Inside :::PARENT::: where child 2566093 exited with status: 5</code></pre>
<pre><code>---CHILD 2568612--- exiting with 1
---CHILD 2568613--- exiting with 2
---CHILD 2568614--- exiting with 3
---CHILD 2568615--- exiting with 4
Inside :::PARENT::: where child 2568612 exited with status: 1
---CHILD 2568616--- exiting with 5
Inside :::PARENT::: where child 2568613 exited with status: 2
Inside :::PARENT::: where child 2568614 exited with status: 3
Inside :::PARENT::: where child 2568615 exited with status: 4
Inside :::PARENT::: where child 2568616 exited with status: 5</code></pre>
<p>This <em>non-determinism</em> is a product of the <em>isolation</em> that is provided by processes. The OS switches back and forth between processes frequently (up to thousands of time per second!) so that if one goes into an infinite loop, others will still make progress. But this also means that the OS can choose to run any of the processes that are trying to execute at any point in time! We cannot predict the order of execution, completion, or <code>wait</code> notification. This non-deterministic execution is called <em>concurrency</em>. You’ll want to keep this in mind as you continue to learn the process APIs, and when we talk about IPC, later.</p>
<h3 id="life-after-exit"><span class="header-section-number">7.5.3</span> life after <code>exit()</code>?</h3>
<p>Remember that when <code>main()</code> returns, it is the same as <code>exit()</code> because <strong>main() calls exit()</strong>.</p>
<blockquote>
<p><strong>Investigating <code>main</code> return → <code>exit</code> via <code>gdb</code>.</strong> You can see this by diving into any program with <code>gdb -tui</code>, breakpointing before the return (e.g. <code>b 5</code>), and single-stepping through the program. You’ll want to <code>layout asm</code> to drop into “assembly mode”, and single step through the assembly and if you want to step through it instruction at a time use <code>stepi</code> or <code>si</code>. You can see that it ends up calling <code>__GI_exit</code>. <code>__GI_*</code> functions are glibc internal functions, so we see that <code>libc</code> is actually calling <code>main</code>, and when it returns, it is then going through its logic for <code>exit</code>.</p>
</blockquote>
<p><code>C</code> provides you with additional control of what happens when you exit from a program. For instance, you may need to <em>clean up resources</em>, <em>e.g.,</em> release some memory, close some files or network connections, write some debug information to a file, <em>etc.</em> Hence, the following functions <em>can be</em> are called once <code>exit()</code> is invoked: |function| defined in | |——–|——–| | <code>on_exit</code>| <code>&lt;stdlib.h&gt;</code>| | <code>atexit</code>| <code>&lt;stdlib.h&gt;</code>| | <code>_exit</code>| <code>&lt;unistd.h&gt;</code>| ||</p>
<p>Let’s look at these in more details.</p>
<h4 id="on_exit"><span class="header-section-number">7.5.3.1</span> <code>on_exit()</code></h4>
<div class="sourceCode" id="cb153"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb153-1" title="1">typdef <span class="dt">void</span> (*function)( <span class="dt">int</span> , <span class="dt">void</span> * ) ;</a>
<a class="sourceLine" id="cb153-2" title="2"><span class="dt">int</span> on_exit( function my_func, <span class="dt">void</span> *arg ) ;</a></code></pre></div>
<ul>
<li>register a <em>user-defined</em> <strong>function pointer</strong></li>
<li><code>my_func</code></li>
<li>to be called while exiting from <code>main()</code><br> <code>typdef void (*function)( int , void * ) ;</code></li>
<li>function receives → exit <code>status</code> &amp; <code>argument</code></li>
<li>we can pass data/args to that function</li>
</ul>
<h4 id="atexit"><span class="header-section-number">7.5.3.2</span> <code>atexit()</code></h4>
<div class="sourceCode" id="cb154"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb154-1" title="1"><span class="kw">typedef</span> <span class="dt">void</span> (*function)(<span class="dt">void</span>) ;</a>
<a class="sourceLine" id="cb154-2" title="2"><span class="dt">int</span> atexit(function my_func);</a></code></pre></div>
<p>Program output:</p>
<pre><code>/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o: in function `_start&#39;:
(.text+0x24): undefined reference to `main&#39;
collect2: error: ld returned 1 exit status
make[1]: *** [Makefile:33: inline_exec_tmp] Error 1</code></pre>
<ul>
<li>register a <em>user-defined</em> <strong>function pointer</strong></li>
<li><code>my_func</code></li>
<li>to be called while exiting from <code>main()</code><br> <code>typedef void (*function)(void) ;</code></li>
<li><strong>much simpler</strong> function/interface → <strong>no</strong> args!</li>
<li><strong>no</strong> data/args passed to that function</li>
</ul>
<p><strong>Note:</strong> some nuances: 1. neither <code>atexit()</code> nor <code>on_exit()</code> immediately terminate the process. 2. you can register <strong>multiple</strong> functions using either one; these are called in <strong>reverse</strong> order of registrations 3. <code>atexit()</code> is <em>standard</em> <code>c</code>, while <code>on_exit()</code> <em>may not</em> be!</p>
<h4 id="exit-1"><span class="header-section-number">7.5.3.3</span> <code>_exit()</code></h4>
<p><code>void _exit(int status);</code></p>
<ul>
<li><strong>immediate</strong> termination of process!</li>
<li>no return value</li>
<li>output buffers are <strong>not</strong> flushed</li>
<li><strong>does not</strong> call the funcs registered by others</li>
</ul>
<div class="sourceCode" id="cb156"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb156-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb156-2" title="2"><span class="co"> * intro to fork(), wait() and exit()</span></a>
<a class="sourceLine" id="cb156-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb156-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb156-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb156-6" title="6"></a>
<a class="sourceLine" id="cb156-7" title="7"></a>
<a class="sourceLine" id="cb156-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span><span class="pp">     </span><span class="co">// fork(), getpid()</span></a>
<a class="sourceLine" id="cb156-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span><span class="pp">   </span><span class="co">// wait()</span></a>
<a class="sourceLine" id="cb156-10" title="10"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span><span class="pp">     </span><span class="co">// exit()</span></a>
<a class="sourceLine" id="cb156-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb156-12" title="12"></a>
<a class="sourceLine" id="cb156-13" title="13"></a>
<a class="sourceLine" id="cb156-14" title="14"><span class="pp">#define NUM_CHILDREN 1</span></a>
<a class="sourceLine" id="cb156-15" title="15"></a>
<a class="sourceLine" id="cb156-16" title="16"><span class="co">// function signature to match on_exit()</span></a>
<a class="sourceLine" id="cb156-17" title="17"><span class="dt">void</span> cleanup( <span class="dt">int</span> status, <span class="dt">void</span>* args )</a>
<a class="sourceLine" id="cb156-18" title="18">{</a>
<a class="sourceLine" id="cb156-19" title="19">    free( args ) ;</a>
<a class="sourceLine" id="cb156-20" title="20">    printf( <span class="st">&quot;AFTER Exit(): Doing some cleanup. Freeing memory %hhx status = %d</span><span class="sc">\n</span><span class="st">&quot;</span>, args, status ) ;</a>
<a class="sourceLine" id="cb156-21" title="21">}</a>
<a class="sourceLine" id="cb156-22" title="22"></a>
<a class="sourceLine" id="cb156-23" title="23"><span class="dt">void</span> simple_cleanup()</a>
<a class="sourceLine" id="cb156-24" title="24">{</a>
<a class="sourceLine" id="cb156-25" title="25">    printf( <span class="st">&quot;Goodbye cruel world!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb156-26" title="26">}</a>
<a class="sourceLine" id="cb156-27" title="27"></a>
<a class="sourceLine" id="cb156-28" title="28"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb156-29" title="29">{</a>
<a class="sourceLine" id="cb156-30" title="30">    pid_t pid, child_pid ;</a>
<a class="sourceLine" id="cb156-31" title="31"></a>
<a class="sourceLine" id="cb156-32" title="32">    <span class="dt">int</span>* some_memory = (<span class="dt">int</span>*)malloc(<span class="dv">1024</span>) ;</a>
<a class="sourceLine" id="cb156-33" title="33">    <span class="co">// register the function and also tell it what to cleanup</span></a>
<a class="sourceLine" id="cb156-34" title="34">    on_exit( cleanup, some_memory ) ;</a>
<a class="sourceLine" id="cb156-35" title="35"></a>
<a class="sourceLine" id="cb156-36" title="36">    <span class="co">// register the simpler atexit function</span></a>
<a class="sourceLine" id="cb156-37" title="37">    atexit(simple_cleanup) ;</a>
<a class="sourceLine" id="cb156-38" title="38">    </a>
<a class="sourceLine" id="cb156-39" title="39"></a>
<a class="sourceLine" id="cb156-40" title="40">    <span class="co">// create multiple children </span></a>
<a class="sourceLine" id="cb156-41" title="41">    <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; NUM_CHILDREN ; ++i )</a>
<a class="sourceLine" id="cb156-42" title="42">    {</a>
<a class="sourceLine" id="cb156-43" title="43">        pid = fork() ;</a>
<a class="sourceLine" id="cb156-44" title="44">        <span class="cf">if</span>( !pid )</a>
<a class="sourceLine" id="cb156-45" title="45">        {</a>
<a class="sourceLine" id="cb156-46" title="46">            <span class="co">// we are inside the child</span></a>
<a class="sourceLine" id="cb156-47" title="47">            printf( <span class="st">&quot;---CHILD %d--- exiting with %d</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid(), i+<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb156-48" title="48"></a>
<a class="sourceLine" id="cb156-49" title="49">            <span class="co">// both of these terminate immediately AND return the same value</span></a>
<a class="sourceLine" id="cb156-50" title="50">            <span class="co">// identical, really!</span></a>
<a class="sourceLine" id="cb156-51" title="51">            <span class="cf">if</span>( i % <span class="dv">2</span> )</a>
<a class="sourceLine" id="cb156-52" title="52">                exit( i+<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb156-53" title="53">            <span class="cf">else</span></a>
<a class="sourceLine" id="cb156-54" title="54">                <span class="cf">return</span> i+<span class="dv">1</span> ;</a>
<a class="sourceLine" id="cb156-55" title="55">        }</a>
<a class="sourceLine" id="cb156-56" title="56">    }</a>
<a class="sourceLine" id="cb156-57" title="57"></a>
<a class="sourceLine" id="cb156-58" title="58">    <span class="co">/* Inside the parent, wait until the wait() call returns -1 -&gt; no more children left</span></a>
<a class="sourceLine" id="cb156-59" title="59"><span class="co">     * take the return value from wait(), put it in &quot;child_pid&quot; and compare that to &quot;-1&quot;</span></a>
<a class="sourceLine" id="cb156-60" title="60"><span class="co">     */</span></a>
<a class="sourceLine" id="cb156-61" title="61">    <span class="dt">int</span> status ;</a>
<a class="sourceLine" id="cb156-62" title="62">    <span class="cf">while</span>( ( child_pid = wait( &amp;status ) ) != -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb156-63" title="63">    {</a>
<a class="sourceLine" id="cb156-64" title="64">        <span class="co">// all children are done!</span></a>
<a class="sourceLine" id="cb156-65" title="65">        <span class="cf">if</span>( WIFEXITED(status) )</a>
<a class="sourceLine" id="cb156-66" title="66">        {</a>
<a class="sourceLine" id="cb156-67" title="67">            <span class="co">// check that the process didn&#39;t terminate with any errors</span></a>
<a class="sourceLine" id="cb156-68" title="68">            <span class="co">// note that the output of WIFEEXITED is non-zero for normal exit</span></a>
<a class="sourceLine" id="cb156-69" title="69"></a>
<a class="sourceLine" id="cb156-70" title="70">            printf( <span class="st">&quot;Inside :::PARENT::: where child %d exited with status: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb156-71" title="71">                    child_pid, </a>
<a class="sourceLine" id="cb156-72" title="72">                    (<span class="dt">char</span>) WEXITSTATUS(status) ) ;</a>
<a class="sourceLine" id="cb156-73" title="73">        }</a>
<a class="sourceLine" id="cb156-74" title="74">    }</a>
<a class="sourceLine" id="cb156-75" title="75"></a>
<a class="sourceLine" id="cb156-76" title="76">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb156-77" title="77">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb156-78" title="78">    <span class="co">// exit(EXIT_SUCCESS) ;</span></a>
<a class="sourceLine" id="cb156-79" title="79">    <span class="co">// return EXIT_SUCCESS ;</span></a>
<a class="sourceLine" id="cb156-80" title="80">}</a></code></pre></div>
<p>The output:</p>
<pre><code>---CHILD 2608965--- exiting with 1
Goodbye cruel world!
AFTER Exit(): Doing some cleanup. Freeing memory a0 status = 1
Inside :::PARENT::: where child 2608965 exited with status: 1

Goodbye cruel world!
AFTER Exit(): Doing some cleanup. Freeing memory a0 status = 0</code></pre>
<p>But, what happens if we change the following lines?</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb158-1" title="1">    <span class="co">// register the simpler atexit function</span></a>
<a class="sourceLine" id="cb158-2" title="2">    atexit(simple_cleanup) ;</a>
<a class="sourceLine" id="cb158-3" title="3"></a>
<a class="sourceLine" id="cb158-4" title="4">    <span class="dt">int</span>* some_memory = (<span class="dt">int</span>*)malloc(<span class="dv">1024</span>) ;</a>
<a class="sourceLine" id="cb158-5" title="5">    <span class="co">// register the function and also tell it what to cleanup</span></a>
<a class="sourceLine" id="cb158-6" title="6">    on_exit( cleanup, some_memory ) ;</a></code></pre></div>
<p>The output now looks like (what’s the difference?):</p>
<pre><code>---CHILD 2609577--- exiting with 1
AFTER Exit(): Doing some cleanup. Freeing memory a0 status = 1
Goodbye cruel world!
Inside :::PARENT::: where child 2609577 exited with status: 1

AFTER Exit(): Doing some cleanup. Freeing memory a0 status = 0
Goodbye cruel world!</code></pre>
<p>Finally, we change the <code>return (i+1)</code> to <code>_exit(i+1)</code> as follows:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb160-1" title="1">            <span class="cf">if</span>( i % <span class="dv">2</span> )</a>
<a class="sourceLine" id="cb160-2" title="2">                exit( i+<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb160-3" title="3">            <span class="cf">else</span></a>
<a class="sourceLine" id="cb160-4" title="4">                <span class="co">// return i+1 ;</span></a>
<a class="sourceLine" id="cb160-5" title="5">                _exit(i+<span class="dv">1</span>) ;</a></code></pre></div>
<p>What does the output look like now?</p>
<pre><code>---CHILD 2610300--- exiting with 1
Inside :::PARENT::: where child 2610300 exited with status: 1

AFTER Exit(): Doing some cleanup. Freeing memory a0 status = 0
Goodbye cruel world!</code></pre>
<h2 id="command-line-arguments"><span class="header-section-number">7.6</span> Command Line Arguments</h2>
<p>I think that we likely have a decent intuition about what the command-line arguments are`:</p>
<pre><code>$ ls /bin /sbin</code></pre>
<p>The <code>ls</code> program takes two arguments, <code>/bin</code> and <code>/sbin</code>. How does <code>ls</code> access those arguments?</p>
<p>Lets look at a <em>chain of programs</em> that <code>exec</code> each other. The first program (that you see here) is called <code>inline_exec_tmp</code>, and the programs <code>03/args?.c</code> are subsequently executed.</p>
<figure>
<img src="figures/exec_chain.png" alt="A chain of processes execing each other, and passing arguments. We only print them out in the 3rd program, args2.bin." /><figcaption>A chain of processes <code>exec</code>ing each other, and passing arguments. We only print them out in the 3rd program, <code>args2.bin</code>.</figcaption>
</figure>
<div class="sourceCode" id="cb163"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb163-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb163-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb163-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb163-4" title="4"></a>
<a class="sourceLine" id="cb163-5" title="5"><span class="dt">char</span> *prog = <span class="st">&quot;./03/args1.bin&quot;</span>;</a>
<a class="sourceLine" id="cb163-6" title="6"></a>
<a class="sourceLine" id="cb163-7" title="7"><span class="dt">int</span></a>
<a class="sourceLine" id="cb163-8" title="8">main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb163-9" title="9">{</a>
<a class="sourceLine" id="cb163-10" title="10">    <span class="dt">char</span> *args[] = {prog, <span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>, NULL};</a>
<a class="sourceLine" id="cb163-11" title="11"></a>
<a class="sourceLine" id="cb163-12" title="12">    <span class="cf">if</span> (argc != <span class="dv">1</span>) <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb163-13" title="13"></a>
<a class="sourceLine" id="cb163-14" title="14">    printf(<span class="st">&quot;First program, arg 1: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, argv[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb163-15" title="15">    fflush(stdout);</a>
<a class="sourceLine" id="cb163-16" title="16"></a>
<a class="sourceLine" id="cb163-17" title="17">    <span class="co">/* lets execute args1 with some arguments! */</span></a>
<a class="sourceLine" id="cb163-18" title="18">    <span class="cf">if</span> (execvp(prog, args)) {</a>
<a class="sourceLine" id="cb163-19" title="19">        perror(<span class="st">&quot;exec&quot;</span>);</a>
<a class="sourceLine" id="cb163-20" title="20">        <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb163-21" title="21">    }</a>
<a class="sourceLine" id="cb163-22" title="22"></a>
<a class="sourceLine" id="cb163-23" title="23">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb163-24" title="24">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>First program, arg 1: ./inline_exec_tmp
Inside ./03/args2.bin
arg 0: ./03/args2.bin
arg 1: hello
arg 2: world</code></pre>
<p><code>args1.c</code> is</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb165-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb165-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb165-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb165-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb165-5" title="5"></a>
<a class="sourceLine" id="cb165-6" title="6"><span class="dt">char</span> *prog = <span class="st">&quot;./03/args2.bin&quot;</span>;</a>
<a class="sourceLine" id="cb165-7" title="7"></a>
<a class="sourceLine" id="cb165-8" title="8"><span class="dt">int</span></a>
<a class="sourceLine" id="cb165-9" title="9">main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb165-10" title="10">{</a>
<a class="sourceLine" id="cb165-11" title="11">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb165-12" title="12">    <span class="dt">char</span> **args;        <span class="co">/* an array of strings */</span></a>
<a class="sourceLine" id="cb165-13" title="13"></a>
<a class="sourceLine" id="cb165-14" title="14">    printf(<span class="st">&quot;Inside %s</span><span class="sc">\n</span><span class="st">&quot;</span>, argv[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb165-15" title="15"></a>
<a class="sourceLine" id="cb165-16" title="16">    <span class="co">/* lets just pass the arguments on through to args2! */</span></a>
<a class="sourceLine" id="cb165-17" title="17">    args = calloc(argc + <span class="dv">1</span>, <span class="kw">sizeof</span>(<span class="dt">char</span> *));</a>
<a class="sourceLine" id="cb165-18" title="18">    assert(args);</a>
<a class="sourceLine" id="cb165-19" title="19"></a>
<a class="sourceLine" id="cb165-20" title="20">    args[<span class="dv">0</span>] = prog;</a>
<a class="sourceLine" id="cb165-21" title="21">    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt; argc; i++) {</a>
<a class="sourceLine" id="cb165-22" title="22">        args[i] = argv[i];</a>
<a class="sourceLine" id="cb165-23" title="23">    }</a>
<a class="sourceLine" id="cb165-24" title="24">    args[i] = NULL; <span class="co">/* the arguments need to be `NULL`-terminated */</span></a>
<a class="sourceLine" id="cb165-25" title="25"></a>
<a class="sourceLine" id="cb165-26" title="26">    <span class="cf">if</span> (execvp(prog, args)) {</a>
<a class="sourceLine" id="cb165-27" title="27">        perror(<span class="st">&quot;exec&quot;</span>);</a>
<a class="sourceLine" id="cb165-28" title="28"></a>
<a class="sourceLine" id="cb165-29" title="29">        <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb165-30" title="30">    }</a>
<a class="sourceLine" id="cb165-31" title="31"></a>
<a class="sourceLine" id="cb165-32" title="32">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb165-33" title="33">}</a></code></pre></div>
<p>…and <code>args2.c</code> is</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb166-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb166-2" title="2"></a>
<a class="sourceLine" id="cb166-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb166-4" title="4">main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb166-5" title="5">{</a>
<a class="sourceLine" id="cb166-6" title="6">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb166-7" title="7"></a>
<a class="sourceLine" id="cb166-8" title="8">    printf(<span class="st">&quot;Inside %s</span><span class="sc">\n</span><span class="st">&quot;</span>, argv[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb166-9" title="9"></a>
<a class="sourceLine" id="cb166-10" title="10">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; argc; i++) {</a>
<a class="sourceLine" id="cb166-11" title="11">        printf(<span class="st">&quot;arg %d: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, i, argv[i]);</a>
<a class="sourceLine" id="cb166-12" title="12">    }</a>
<a class="sourceLine" id="cb166-13" title="13"></a>
<a class="sourceLine" id="cb166-14" title="14">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb166-15" title="15">}</a></code></pre></div>
<p>So we see the following.</p>
<ul>
<li>It is <em>convention</em> that the first argument to a program is always the program itself. The shell will <em>always</em> ensure that this is the case (NB: the shell <code>exec</code>s your programs).</li>
<li>The rest of the arguments are passed as separate entries in the array of arguments.</li>
<li>The <code>v</code> variants of <code>exec</code> require the <code>NULL</code> termination of the argument array, something that is easy to mess up!</li>
</ul>
<p>Parsing through the command-line arguments can be a little annoying, and <code>getopt</code> can help.</p>
<h2 id="environment-variables"><span class="header-section-number">7.7</span> Environment Variables</h2>
<p>Environment variables are UNIX’s means of providing configuration information to any process that might want it. They are a key-value store<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> that maps an environment variable to its value (both are strings).</p>
<p>Environment variables are used to make configuration information accessible to programs. They are used instead of command-line arguments when:</p>
<ul>
<li>You don’t want the user worrying about passing the variable to a program. For example, you don’t want the user to have to pass their username along to every program as an argument.</li>
<li>You don’t know which programs are going to use the configuration data, but <em>any</em> of them <em>could</em>. You don’t want to pass a bunch of command-line variables into each program, and expect them to pass them along to each child process.</li>
</ul>
<p>Example common environment variables include:</p>
<ul>
<li><code>PATH</code> - a <code>:</code>-separated list of file system paths to use to look for programs when attempt to execute a program.</li>
<li><code>HOME</code> - the current user’s home directory (e.g. <code>/home/gparmer</code>).</li>
<li><code>USER</code> - the username (e.g. <code>gparmer</code>).</li>
<li><code>TEMP</code> - a directory that you can use to store temporary files.</li>
</ul>
<p>Many programs setup and use their own environment variables. Note that environment variables are pretty pervasively used – simple libraries exist to access them from <code>python</code>, <code>node.js</code>, <code>rust</code>, <code>java</code>, etc…</p>
<p>You can easily access environment variables from the command line:</p>
<pre><code>$ echo $HOME
/home/gparmer
$ export BESTPUP=penny
$ echo $BESTPUP
penny</code></pre>
<p>Any program executed from that shell, will be able to access the “<code>BESTPUP</code>” environment variable. The <code>env</code> command dumps out all current environment variables.</p>
<h3 id="environment-variable-apis"><span class="header-section-number">7.7.1</span> Environment Variable APIs</h3>
<p>So how do we access the environment variable key-value store in C? The core functions for working with environment variables include:</p>
<ul>
<li><code>getenv</code> - Get an environment variable’s value.</li>
<li><code>setenv</code> - Set one of environment variable’s value (used by the shell to set up children’s variables).</li>
<li><code>clearenv</code> - Reset the entire environment.</li>
<li><code>environ</code> array - This is the array of environment variables you’ll see in the <code>man</code> pages. You don’t want to access/modify this directly, but you can imagine it is used to back all of the previous calls.</li>
</ul>
<div class="sourceCode" id="cb168"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb168-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb168-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb168-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb168-4" title="4"></a>
<a class="sourceLine" id="cb168-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb168-6" title="6">main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb168-7" title="7">{</a>
<a class="sourceLine" id="cb168-8" title="8">    <span class="dt">char</span> *u = getenv(<span class="st">&quot;USER&quot;</span>);</a>
<a class="sourceLine" id="cb168-9" title="9">    <span class="dt">char</span> *h = getenv(<span class="st">&quot;HOME&quot;</span>);</a>
<a class="sourceLine" id="cb168-10" title="10"></a>
<a class="sourceLine" id="cb168-11" title="11">    assert(u &amp;&amp; h);</a>
<a class="sourceLine" id="cb168-12" title="12"></a>
<a class="sourceLine" id="cb168-13" title="13">    printf(<span class="st">&quot;I am %s, and I live in %s</span><span class="sc">\n</span><span class="st">&quot;</span>, u, h);</a>
<a class="sourceLine" id="cb168-14" title="14"></a>
<a class="sourceLine" id="cb168-15" title="15">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb168-16" title="16">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>I am sibin, and I live in /home/sibin</code></pre>
<p>You can see all of the environmental variables available by default with:</p>
<pre><code>$ env
SHELL=/bin/bash
DESKTOP_SESSION=ubuntu
EDITOR=emacs -nw
PWD=/home/gparmer/repos/gwu-cs-sysprog/22/lectures
LOGNAME=gparmer
HOME=/home/gparmer
USERNAME=gparmer
USER=gparmer
PATH=/home/gparmer/.local/bin::/home/gparmer/.cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/usr/racket/bin/
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
...</code></pre>
<div class="sourceCode" id="cb171"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb171-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb171-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb171-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb171-4" title="4"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb171-5" title="5"></a>
<a class="sourceLine" id="cb171-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb171-7" title="7">main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb171-8" title="8">{</a>
<a class="sourceLine" id="cb171-9" title="9">    <span class="dt">char</span> *u = getenv(<span class="st">&quot;USER&quot;</span>);</a>
<a class="sourceLine" id="cb171-10" title="10"></a>
<a class="sourceLine" id="cb171-11" title="11">    assert(u);</a>
<a class="sourceLine" id="cb171-12" title="12">    printf(<span class="st">&quot;user: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, u);</a>
<a class="sourceLine" id="cb171-13" title="13">    fflush(stdout);</a>
<a class="sourceLine" id="cb171-14" title="14"></a>
<a class="sourceLine" id="cb171-15" title="15">    <span class="cf">if</span> (setenv(<span class="st">&quot;USER&quot;</span>, <span class="st">&quot;penny&quot;</span>, <span class="dv">1</span>)) {</a>
<a class="sourceLine" id="cb171-16" title="16">        perror(<span class="st">&quot;attempting setenv&quot;</span>);</a>
<a class="sourceLine" id="cb171-17" title="17">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb171-18" title="18">    }</a>
<a class="sourceLine" id="cb171-19" title="19"></a>
<a class="sourceLine" id="cb171-20" title="20">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb171-21" title="21">        <span class="dt">char</span> *u = getenv(<span class="st">&quot;USER&quot;</span>);</a>
<a class="sourceLine" id="cb171-22" title="22">        <span class="dt">char</span> *args[] = { <span class="st">&quot;./03/envtest.bin&quot;</span>, <span class="st">&quot;USER&quot;</span>, NULL };</a>
<a class="sourceLine" id="cb171-23" title="23"></a>
<a class="sourceLine" id="cb171-24" title="24">        <span class="co">/* environment is inherited across *both* `fork` and `exec`! */</span></a>
<a class="sourceLine" id="cb171-25" title="25">        printf(<span class="st">&quot;user (forked child): %s</span><span class="sc">\n</span><span class="st">&quot;</span>, u);</a>
<a class="sourceLine" id="cb171-26" title="26">        fflush(stdout);</a>
<a class="sourceLine" id="cb171-27" title="27">        <span class="cf">if</span> (execvp(<span class="st">&quot;./03/envtest.bin&quot;</span>, args)) {</a>
<a class="sourceLine" id="cb171-28" title="28">            perror(<span class="st">&quot;exec&quot;</span>);</a>
<a class="sourceLine" id="cb171-29" title="29"></a>
<a class="sourceLine" id="cb171-30" title="30">            <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb171-31" title="31">        }</a>
<a class="sourceLine" id="cb171-32" title="32">    }</a>
<a class="sourceLine" id="cb171-33" title="33"></a>
<a class="sourceLine" id="cb171-34" title="34">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb171-35" title="35">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>user: sibin
user (forked child): penny
Environment variable USER -&gt; penny</code></pre>
<p><code>03/envtest.c</code> is</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb173-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb173-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb173-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb173-4" title="4"></a>
<a class="sourceLine" id="cb173-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb173-6" title="6">main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])</a>
<a class="sourceLine" id="cb173-7" title="7">{</a>
<a class="sourceLine" id="cb173-8" title="8">    <span class="dt">char</span> *e = <span class="st">&quot;NOARG&quot;</span>;</a>
<a class="sourceLine" id="cb173-9" title="9">    <span class="dt">char</span> *v = <span class="st">&quot;NOVAL&quot;</span>;</a>
<a class="sourceLine" id="cb173-10" title="10"></a>
<a class="sourceLine" id="cb173-11" title="11">    <span class="cf">if</span> (argc == <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb173-12" title="12">        e = argv[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb173-13" title="13">        v = getenv(e);</a>
<a class="sourceLine" id="cb173-14" title="14">        <span class="cf">if</span> (!v) {</a>
<a class="sourceLine" id="cb173-15" title="15">            v = <span class="st">&quot;&quot;</span>;</a>
<a class="sourceLine" id="cb173-16" title="16">        }</a>
<a class="sourceLine" id="cb173-17" title="17">    }</a>
<a class="sourceLine" id="cb173-18" title="18"></a>
<a class="sourceLine" id="cb173-19" title="19">    printf(<span class="st">&quot;Environment variable %s -&gt; %s</span><span class="sc">\n</span><span class="st">&quot;</span>, e, v);</a>
<a class="sourceLine" id="cb173-20" title="20"></a>
<a class="sourceLine" id="cb173-21" title="21">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb173-22" title="22">}</a></code></pre></div>
<p>A common use of environment variables is the “home” directory in your shell. How is this implemented?</p>
<pre><code>$ cd ~</code></pre>
<p>The <code>~</code> means “my home directory”. To understand what directory is a user’s home directory, you can <code>getenv(HOME)</code>!</p>
<h3 id="an-aside-creating-processes-with-posix_spawn"><span class="header-section-number">7.7.2</span> An Aside: Creating Processes with <code>posix_spawn</code></h3>
<p><code>fork</code> and <code>exec</code> are not the only functions to execute a program. <code>posix_spawn</code> also enables the creation of a new process that execute a given program. <code>posix_spawn</code> performs three high-level actions:</p>
<ol type="1">
<li><code>fork</code> to create a new process,</li>
<li>a set of “file actions” that update and modify the files/descriptors for the new process, that are specified in an array argument to <code>posix_spawn</code>, and</li>
<li><code>exec</code> to execute a program and pass arguments/environmental variables.</li>
</ol>
<p>It is strictly <em>more limited</em> in what it can do than <code>fork</code> and <code>exec</code>, but this is often a feature not a bug. <code>fork</code> is really hard to use well, and can be quite confusing to use. It is considered by some to be a <a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf">flawed API</a>. Thus the focus of <code>posix_spawn</code> on specific executing a new program can be quite useful to simply programs.</p>
<h2 id="representations-of-processes"><span class="header-section-number">7.8</span> Representations of Processes</h2>
<p>We’ve seen how to create and manage processes and how to execute programs. Amazingly, modern systems have pretty spectacular facilities for <em>introspection</em> into executing processes. Introspection facilities generally let you dive into something as it runs. The most immediate example of this is <code>gdb</code> or any debugger that let you dive into an implementation. Looking at <code>pause.c</code>:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb175-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb175-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb175-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb175-4" title="4"></a>
<a class="sourceLine" id="cb175-5" title="5"><span class="dt">const</span> <span class="dt">int</span> global_readonly = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb175-6" title="6"><span class="dt">int</span> global = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb175-7" title="7"></a>
<a class="sourceLine" id="cb175-8" title="8"><span class="dt">int</span></a>
<a class="sourceLine" id="cb175-9" title="9">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb175-10" title="10">{</a>
<a class="sourceLine" id="cb175-11" title="11">    <span class="dt">int</span> stack_allocated;</a>
<a class="sourceLine" id="cb175-12" title="12">    <span class="dt">int</span> *heap = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb175-13" title="13"></a>
<a class="sourceLine" id="cb175-14" title="14">    printf(<span class="st">&quot;pid %d</span><span class="sc">\n</span><span class="st">global (RO):</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">global:      </span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">stack:      </span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">heap:      </span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">function:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb175-15" title="15">           getpid(), &amp;global_readonly, &amp;global, &amp;stack_allocated, heap, main);</a>
<a class="sourceLine" id="cb175-16" title="16"></a>
<a class="sourceLine" id="cb175-17" title="17">    pause();</a>
<a class="sourceLine" id="cb175-18" title="18"></a>
<a class="sourceLine" id="cb175-19" title="19">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb175-20" title="20">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>pid 9310
global (RO):    0x55be6d40b008
global:         0x55be6d40d014
stack:          0x7ffc7abafc7c
heap:           0x55be6da162a0
function:       0x55be6d40a1c9</code></pre>
<p>Lets take the process identifier, and <em>dive into the process!</em> The “<code>proc</code> filesystem” in Linux is a part of the file system devoted to representing processes. There is a subdirectly in it for each process in the system. Lets check out process <code>9310</code>.</p>
<pre><code>$ cd /proc/9310/
$ ls
arch_status  cgroup      coredump_filter  exe      io         maps       mountstats  oom_adj        patch_state  sched      smaps         statm    timers
attr         clear_refs  cpuset           fd       limits     mem        net         oom_score      personality  schedstat  smaps_rollup  status   timerslack_ns
autogroup    cmdline     cwd              fdinfo   loginuid   mountinfo  ns          oom_score_adj  projid_map   sessionid  stack         syscall  uid_map
auxv         comm        environ          gid_map  map_files  mounts     numa_maps   pagemap        root         setgroups  stat          task     wchan
$ cat maps
55be6d409000-55be6d40a000 r--p 00000000 08:02 1315893                    /home/ycombinator/repos/gwu-cs-sysprog/22/lectures/03/pause.bin
55be6d40a000-55be6d40b000 r-xp 00001000 08:02 1315893                    /home/ycombinator/repos/gwu-cs-sysprog/22/lectures/03/pause.bin
55be6d40b000-55be6d40c000 r--p 00002000 08:02 1315893                    /home/ycombinator/repos/gwu-cs-sysprog/22/lectures/03/pause.bin
55be6d40c000-55be6d40d000 r--p 00002000 08:02 1315893                    /home/ycombinator/repos/gwu-cs-sysprog/22/lectures/03/pause.bin
55be6d40d000-55be6d40e000 rw-p 00003000 08:02 1315893                    /home/ycombinator/repos/gwu-cs-sysprog/22/lectures/03/pause.bin
55be6da16000-55be6da37000 rw-p 00000000 00:00 0                          [heap]
7ff4a127f000-7ff4a12a4000 r--p 00000000 08:02 11797912                   /lib/x86_64-linux-gnu/libc-2.31.so
7ff4a12a4000-7ff4a141c000 r-xp 00025000 08:02 11797912                   /lib/x86_64-linux-gnu/libc-2.31.so
7ff4a141c000-7ff4a1466000 r--p 0019d000 08:02 11797912                   /lib/x86_64-linux-gnu/libc-2.31.so
7ff4a1466000-7ff4a1467000 ---p 001e7000 08:02 11797912                   /lib/x86_64-linux-gnu/libc-2.31.so
7ff4a1467000-7ff4a146a000 r--p 001e7000 08:02 11797912                   /lib/x86_64-linux-gnu/libc-2.31.so
7ff4a146a000-7ff4a146d000 rw-p 001ea000 08:02 11797912                   /lib/x86_64-linux-gnu/libc-2.31.so
7ff4a146d000-7ff4a1473000 rw-p 00000000 00:00 0
7ff4a1495000-7ff4a1496000 r--p 00000000 08:02 11797896                   /lib/x86_64-linux-gnu/ld-2.31.so
7ff4a1496000-7ff4a14b9000 r-xp 00001000 08:02 11797896                   /lib/x86_64-linux-gnu/ld-2.31.so
7ff4a14b9000-7ff4a14c1000 r--p 00024000 08:02 11797896                   /lib/x86_64-linux-gnu/ld-2.31.so
7ff4a14c2000-7ff4a14c3000 r--p 0002c000 08:02 11797896                   /lib/x86_64-linux-gnu/ld-2.31.so
7ff4a14c3000-7ff4a14c4000 rw-p 0002d000 08:02 11797896                   /lib/x86_64-linux-gnu/ld-2.31.so
7ff4a14c4000-7ff4a14c5000 rw-p 00000000 00:00 0
7ffc7ab90000-7ffc7abb1000 rw-p 00000000 00:00 0                          [stack]
7ffc7abe1000-7ffc7abe4000 r--p 00000000 00:00 0                          [vvar]
7ffc7abe4000-7ffc7abe5000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</code></pre>
<p>There’s a <strong>lot</strong> going on here. The most important parts of the <em>ranges</em> of addresses on the left that tell us where we can find the <code>pause.bin</code> program’s code, read-only global data, global read-writable data, heap, and stack! We also see that the number of maps in a very simple process is surprisingly large. Let me manually focus in on a few parts of this.</p>
<pre><code>...
55be6d40a000-55be6d40b000 r-xp ... /03/pause.bin &lt;-- &amp;main      (0x55be6d40a1c9)
55be6d40b000-55be6d40c000 r--p ... /03/pause.bin &lt;-- &amp;global_ro (0x55be6d40b008)
...
55be6d40d000-55be6d40e000 rw-p ... /03/pause.bin &lt;-- &amp;global    (0x55be6d40d014)
...
55be6da16000-55be6da37000 rw-p ... [heap]        &lt;-- heap       (0x55be6da162a0)
...
7ff4a14c4000-7ff4a14c5000 rw-p ...
7ffc7ab90000-7ffc7abb1000 rw-p ... [stack]       &lt;-- stack      (0x7ffc7abafc7c)
...</code></pre>
<p>We can see that each of the variables we’re accessing in the program are at addresses that correspond to the <em>ranges</em> of memory in the <code>maps</code>. Even more, the <code>/proc/9310/mem</code> file contains <em>the actual memory for the process</em>! This is really amazing: we can watch the memory, even as it changes, as a process actually executes. This is how debuggers work!</p>
<p>As you can see, <em>processes are data</em> too!</p>
<h2 id="process-exercises"><span class="header-section-number">7.9</span> Process Exercises</h2>
<h3 id="exercise-1-fibonacci-with-fork"><span class="header-section-number">7.9.1</span> Exercise 1: fibonacci with <code>fork</code></h3>
<p>Implement <code>forkonacci</code>! This will solve the <code>n</code>th <a href="https://en.wikipedia.org/wiki/Fibonacci_number">fibonacci number</a>, using <code>fork</code> for the recursion, and a combination of <code>exit</code> to “return” and <code>wait</code> to retrieve the returned value, instead of function calls. The normal recursive implementation:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb179-1" title="1"><span class="dt">unsigned</span> <span class="dt">int</span></a>
<a class="sourceLine" id="cb179-2" title="2">fibonacci(<span class="dt">unsigned</span> <span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb179-3" title="3">{</a>
<a class="sourceLine" id="cb179-4" title="4">    <span class="cf">if</span> (n == <span class="dv">0</span> || n == <span class="dv">1</span>) <span class="cf">return</span> n;</a>
<a class="sourceLine" id="cb179-5" title="5"></a>
<a class="sourceLine" id="cb179-6" title="6">    <span class="cf">return</span> fibonacci(n - <span class="dv">1</span>) + fibonacci(n - <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb179-7" title="7">}</a></code></pre></div>
<p>This will work decently for <code>n &lt;= 12</code>, but not for <code>n &gt; 12</code>. Why<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>?</p>
<h3 id="exercise-2-shell-support-for-environment-variables"><span class="header-section-number">7.9.2</span> Exercise 2: Shell Support for Environment Variables</h3>
<p>How do you think that the shell-based support for environment variables (<code>export BESTPUP=penny</code>) is implemented? Specifically, if we do the following…</p>
<pre><code>$ export BESTPUP=penny
$ ./03/envtest.bin BESTPUP  // this just prints the environment variable
Environment variable BESTPUP -&gt; penny</code></pre>
<p>…which process is using which APIs? Put another way, how is <code>export</code> implemented?</p>
<h3 id="exercise-3-process-detective"><span class="header-section-number">7.9.3</span> Exercise 3: Process Detective</h3>
<p>The <code>/proc</code> filesystem is a treasure trove of information. You can dive into the process with <code>pid</code> <code>N</code>’s information in <code>/proc/N/</code>. You’ll only have access to the informationx for your processes. So how do you find the <code>pid</code> of your processes? You can find the <code>pid</code> of all of the processes that belong to you using <code>ps aux | grep gparmer  | awk '{print $2}'</code><a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>, but replacing your username for <code>gparmer</code>.</p>
<p>Choose one of those, and go into its directory in <code>/proc</code>. It it doesn’t work, you might have chosen a process that has terminated since you find its ID. Try again.</p>
<p>What do you think the following files contain:</p>
<ul>
<li><code>cmdline</code></li>
<li><code>environ</code></li>
<li><code>status</code></li>
</ul>
<p>Some of the files are <em>binary</em>, which means you might need to use <code>xxd</code> (a hexdecimal binary view program) to look at them. In <code>xxd</code>, pay attention to the right column here.</p>
<h2 id="executing-other-processes"><span class="header-section-number">7.10</span> Executing Other Processes</h2>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/execve.html">Slides</a></p>
<p><code>fork()</code> only makes clones of <em>itself</em>. So, we’re limited to the functions defined in that program. A shell can execute <strong>other programs</strong>! Recall the difference between a program and process: - program → <strong>compiled</strong> version of code - process → program <strong>executing</strong> in memory</p>
<p>So, we want to create a new process and then <strong>execute a new program</strong>. This is done via the <code>exec()</code> <em>family</em> of calls:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb181-1" title="1">     <span class="dt">int</span> execl(<span class="dt">const</span> <span class="dt">char</span> *path, <span class="dt">const</span> <span class="dt">char</span> *arg0, ..., <span class="co">/*, (char *)0, */</span>);</a>
<a class="sourceLine" id="cb181-2" title="2">     <span class="dt">int</span> execle(<span class="dt">const</span> <span class="dt">char</span> *path, <span class="dt">const</span> <span class="dt">char</span> *arg0, ..., <span class="co">/* (char *)0 char *const envp[] */</span>);</a>
<a class="sourceLine" id="cb181-3" title="3">     <span class="dt">int</span> execlp(<span class="dt">const</span> <span class="dt">char</span> *file, <span class="dt">const</span> <span class="dt">char</span> *arg0, ..., <span class="co">/*, (char *)0, */</span>);</a>
<a class="sourceLine" id="cb181-4" title="4">     <span class="dt">int</span> execv(<span class="dt">const</span> <span class="dt">char</span> *path, <span class="dt">char</span> *<span class="dt">const</span> argv[]);</a>
<a class="sourceLine" id="cb181-5" title="5">     <span class="dt">int</span> execvp(<span class="dt">const</span> <span class="dt">char</span> *file, <span class="dt">char</span> *<span class="dt">const</span> argv[]);</a>
<a class="sourceLine" id="cb181-6" title="6">     <span class="dt">int</span> execvP(<span class="dt">const</span> <span class="dt">char</span> *file, <span class="dt">const</span> <span class="dt">char</span> *search_path, <span class="dt">char</span> *<span class="dt">const</span> argv[]);</a></code></pre></div>
<p>They are defined in <code>&lt;unistd.h&gt;</code>.</p>
<p>These calls will do the following: - Stop executing in the current process. - Reclaim all memory within the current process. - Load the target program into the process. - Start executing in the target program (i.e. starting normally, resulting in <code>main</code> execution).</p>
<p><strong>Note:</strong> the main insight is that the <strong>same process continues execution</strong> but <strong>it now executes a new program</strong>.</p>
<h3 id="sequence-of-operations"><span class="header-section-number">7.10.1</span> Sequence of operations</h3>
<ol type="1">
<li>initial process executing [parent]</li>
</ol>
<p><img src="figures/process.png" width="200"></p>
<ol start="2" type="1">
<li><code>fork()</code> a new process [child]:</li>
</ol>
<p><img src="figures/process.png" width="200"> <img src="figures/process.png" width="200"></p>
<ol start="3" type="1">
<li>replace <strong>old</strong> code [child]</li>
</ol>
<p><img src="figures/process.png" width="200"> <img src="figures/execve1.png" width="200"></p>
<ol start="4" type="1">
<li>with <strong>new</strong> code [child]</li>
</ol>
<p><img src="figures/process.png" width="200"> <img src="figures/execve2.png" width="200"></p>
<ol start="5" type="1">
<li>with <strong>new</strong> code [child]</li>
</ol>
<p><img src="figures/process.png" width="200"> <img src="figures/execve3.png" width="200"></p>
<ol start="6" type="1">
<li>reclaim resources [child]</li>
</ol>
<p><img src="figures/process.png" width="200"> <img src="figures/execve4.png" width="200"></p>
<ol start="7" type="1">
<li>execute <strong>new</strong> program [child | from <code>main()</code>]</li>
</ol>
<p><img src="figures/process.png" width="200"> <img src="figures/execve5.png" width="200"></p>
<p><br></p>
<p>A few handy side-effects:</p>
<ul>
<li>The execution of the new program inherits the process identifier (<code>pid_t</code>) and the parent/child relationships of the process.</li>
<li>Comparably, the <em>descriptors</em> are inherited into the new program’s execution.</li>
<li>The environment variables (see section below) pass to the new program’s execution.</li>
<li>Many other process properties are comparably inherited. With the exception of the process memory, you can assume, by default, that process properties are inherited across an <code>exec</code>.</li>
</ul>
<p><strong>Good</strong> side effects | Shared Resources</p>
<p><img src="figures/process.png" width="200"> <img src="figures/execve6.png" width="200"></p>
<p><br></p>
<p><strong>Note:</strong> only memory <strong>not</strong> shared | Resources not Shared</p>
<p><img src="figures/process.png" width="200"> <img src="figures/execve7.png" width="200"></p>
<p><br></p>
<figure>
<img src="./figures/exec_agentxform.gif" alt="Matrix Agent Exec" /><figcaption>Matrix Agent Exec</figcaption>
</figure>
<blockquote>
<p><strong>Detour</strong>: Variadic functions.</p>
<p>Sometimes, <em>we don’t know how many arguments are needed for a function</em>, <em>e.g.</em>, <code>printf()</code>. Also, command line functions, <em>e.g.,</em> <code>ls</code> vs <code>ls -l</code>. In this instance, the shell is calling <code>fork()</code> and one of the <code>exec()</code> functions to launch <code>ls</code> which starts from…its own <code>main()</code>.</p>
<p>So, how does <code>ls</code> (or any other program) know what arguments are passed to it, and more importantly, <strong>how many</strong>?</p>
<p>The <em>actual</em> signature of <code>main()</code> is: <code>C DNE int main( int argc, char* argv[] )</code> - <code>argc</code> tells us <em>now many</em> arguments have been passed and - <code>char* argv[]</code> is the actual set of arguments, i.e. <em>an array of strings</em>!</p>
<p><strong>Note</strong>: the <em>first</em> argument is always the <strong>name of the program</strong>! Hence, we always have <em>at least one</em> argument.</p>
</blockquote>
<div class="sourceCode" id="cb182"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb182-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb182-2" title="2"><span class="co"> * exec() family of system calls | arguments to main()</span></a>
<a class="sourceLine" id="cb182-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb182-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb182-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb182-6" title="6"></a>
<a class="sourceLine" id="cb182-7" title="7"></a>
<a class="sourceLine" id="cb182-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb182-9" title="9"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb182-10" title="10"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb182-11" title="11"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb182-12" title="12"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb182-13" title="13"></a>
<a class="sourceLine" id="cb182-14" title="14"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>* argv[] ) </a>
<a class="sourceLine" id="cb182-15" title="15">{</a>
<a class="sourceLine" id="cb182-16" title="16">    <span class="cf">if</span>( argc )</a>
<a class="sourceLine" id="cb182-17" title="17">    {</a>
<a class="sourceLine" id="cb182-18" title="18">        <span class="co">// we get a positive number of arguments</span></a>
<a class="sourceLine" id="cb182-19" title="19">        <span class="co">// note that the first argument is always the name of the program</span></a>
<a class="sourceLine" id="cb182-20" title="20">        <span class="co">// so we ALWAYS have AT LEAST ONE argument</span></a>
<a class="sourceLine" id="cb182-21" title="21"></a>
<a class="sourceLine" id="cb182-22" title="22">        printf( <span class="st">&quot;Command Line Args received:</span><span class="sc">\t</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb182-23" title="23">        <span class="cf">for</span>( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; argc ; ++i )</a>
<a class="sourceLine" id="cb182-24" title="24">        {</a>
<a class="sourceLine" id="cb182-25" title="25">            printf( <span class="st">&quot;%s &quot;</span>, argv[i] ) ;</a>
<a class="sourceLine" id="cb182-26" title="26">        }</a>
<a class="sourceLine" id="cb182-27" title="27">    } </a>
<a class="sourceLine" id="cb182-28" title="28"></a>
<a class="sourceLine" id="cb182-29" title="29">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb182-30" title="30">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb182-31" title="31">}</a></code></pre></div>
<h2 id="exec_-family"><span class="header-section-number">7.11</span> <code>exec_()</code> family</h2>
<p>Multiple ways to launch a new program: - <code>execl</code> - <code>execlp</code> - <code>execle</code> - <code>execv</code> - <code>execvp</code></p>
<p>The naming scheme is quite annoying and hard to remember, but the <code>man</code> page has a decent summary. The trailing characters correspond to specific operations that differ in how the command-line arguments are passed to the <code>main</code>:</p>
<ol type="1">
<li><code>execl()</code> and <code>execlp()</code>: pass the argmuments <em>directly</em> to the <code>exec()</code> call:</li>
</ol>
<div class="sourceCode" id="cb183"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb183-1" title="1"> <span class="dt">int</span> execl( <span class="dt">const</span> <span class="dt">char</span> *path, <span class="dt">const</span> <span class="dt">char</span> *arg, ..., (<span class="dt">char</span>*)<span class="dv">0</span> ) ;</a></code></pre></div>
<p>The program gets the argument via the <code>argc</code> and <code>argv</code> method described earlier.</p>
<p><strong>Note:</strong> the last argument has to be <code>(char*)0</code>, <em>i.e.,</em> a <code>NULL</code>. This is so that the progam can figure out when the list of arguments is done.</p>
<ol start="2" type="1">
<li><code>execv()</code> and <code>execvp()</code>: pass argmuments in <strong>null terminated array</strong>, <code>argv[]</code></li>
</ol>
<div class="sourceCode" id="cb184"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb184-1" title="1"><span class="dt">int</span> execv( <span class="dt">const</span> <span class="dt">char</span> *path, <span class="dt">char</span> *<span class="dt">const</span> argv[] ) ;</a></code></pre></div>
<p>The caller <em>actually creates</em> an <strong>array of strings</strong> and passes the arguments using that.</p>
<p><strong>Note:</strong> <em>no <code>NULL</code> termination</em> in the function call.</p>
<ol start="3" type="1">
<li><code>execle()</code> and <code>execvpe()</code>: <strong>environment variables</strong> of caller are passed</li>
</ol>
<div class="sourceCode" id="cb185"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb185-1" title="1"><span class="dt">int</span> execle( <span class="dt">const</span> <span class="dt">char</span> *pathname, <span class="dt">const</span> <span class="dt">char</span> *arg, ...<span class="co">/*, (char *) NULL, char *const envp[] */</span> ) ;</a>
<a class="sourceLine" id="cb185-2" title="2"><span class="dt">int</span> execvpe(<span class="dt">const</span> <span class="dt">char</span> *file, <span class="dt">char</span> *<span class="dt">const</span> argv[], <span class="dt">char</span> *<span class="dt">const</span> envp[]) ;</a></code></pre></div>
<p>(<code>l</code> means pass the arguments to this <code>exec</code> call to the program, while <code>v</code> means pass the arguments as an array of the arguments into the <code>exec</code> call), how the program’s path is specified (by default, an “absolute path” starting with <code>/</code> must be used, but in a <code>v</code> variant, the binary is looked up using comparable logic to your shell), and how environment variables are passed to the program. For now, we’ll simply use <code>execvp</code>, and cover the rest in subsequent sections.</p>
<h3 id="execve"><span class="header-section-number">7.11.1</span> <code>execve()</code></h3>
<p>All of the above are layers on top of <code>execve()</code></p>
<div class="sourceCode" id="cb186"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb186-1" title="1"><span class="pp">#include </span><span class="im">&quot;unistd.h&quot;</span></a>
<a class="sourceLine" id="cb186-2" title="2"></a>
<a class="sourceLine" id="cb186-3" title="3"><span class="dt">int</span> execve(<span class="dt">const</span> <span class="dt">char</span> *pathname, <span class="dt">char</span> *<span class="dt">const</span> argv[],</a>
<a class="sourceLine" id="cb186-4" title="4"><span class="dt">char</span> *<span class="dt">const</span> envp[]);</a></code></pre></div>
<h3 id="fork-and-exec"><span class="header-section-number">7.11.2</span> <code>fork()</code> and <code>exec()</code></h3>
<p>Consider the following piece of code:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb187-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb187-2" title="2"><span class="co"> * exec() </span></a>
<a class="sourceLine" id="cb187-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb187-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb187-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb187-6" title="6"></a>
<a class="sourceLine" id="cb187-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb187-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span><span class="pp">     </span><span class="co">// fork(), getpid()</span></a>
<a class="sourceLine" id="cb187-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span><span class="pp">  </span><span class="co">// pid_t</span></a>
<a class="sourceLine" id="cb187-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span><span class="pp">   </span><span class="co">// wait()</span></a>
<a class="sourceLine" id="cb187-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span><span class="pp">     </span><span class="co">// exit()</span></a>
<a class="sourceLine" id="cb187-12" title="12"></a>
<a class="sourceLine" id="cb187-13" title="13"><span class="co">// int main() // not actual signature</span></a>
<a class="sourceLine" id="cb187-14" title="14"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>* argv[] )</a>
<a class="sourceLine" id="cb187-15" title="15">{</a>
<a class="sourceLine" id="cb187-16" title="16">    <span class="dt">char</span>* program = <span class="st">&quot;/bin/ls&quot;</span> ;</a>
<a class="sourceLine" id="cb187-17" title="17">    <span class="dt">char</span>* arg1 = <span class="st">&quot;-al&quot;</span> ;</a>
<a class="sourceLine" id="cb187-18" title="18">    <span class="dt">char</span>* arg2 = <span class="st">&quot;/home&quot;</span> ;</a>
<a class="sourceLine" id="cb187-19" title="19"></a>
<a class="sourceLine" id="cb187-20" title="20">    printf( <span class="st">&quot;BEFORE EXEC!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb187-21" title="21"></a>
<a class="sourceLine" id="cb187-22" title="22">    <span class="dt">int</span> ret = execl( program, <span class="st">&quot;banana&quot;</span>, arg1, arg2, NULL ) ;</a>
<a class="sourceLine" id="cb187-23" title="23"></a>
<a class="sourceLine" id="cb187-24" title="24">    printf( <span class="st">&quot;AFTER EXEC!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb187-25" title="25"></a>
<a class="sourceLine" id="cb187-26" title="26">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb187-27" title="27">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb187-28" title="28">}</a></code></pre></div>
<p><strong>Note:</strong> the <code>printf( "AFTER EXEC!\n" ) ;</code> and further code will <strong>never</strong> execute as the code for the <em>current</em> process is <strong>completely replaced</strong> by the code for the program called using <code>execl()</code>, <em>i.e.,</em> <code>/bin/ls</code>.</p>
<p>So, to get the behavior that <em>we want</em>, <em>i.e.,</em> for some post-processing/messages, <em>etc.</em>, we must first <code>fork()</code> and new child process and then run <code>execl()</code> <strong>in the child process</strong>!</p>
<p>Updating the previous code:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb188-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb188-2" title="2"><span class="co"> * exec() </span></a>
<a class="sourceLine" id="cb188-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb188-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb188-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb188-6" title="6"></a>
<a class="sourceLine" id="cb188-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb188-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span><span class="pp">     </span><span class="co">// fork(), getpid()</span></a>
<a class="sourceLine" id="cb188-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span><span class="pp">  </span><span class="co">// pid_t</span></a>
<a class="sourceLine" id="cb188-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span><span class="pp">   </span><span class="co">// wait()</span></a>
<a class="sourceLine" id="cb188-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span><span class="pp">     </span><span class="co">// exit()</span></a>
<a class="sourceLine" id="cb188-12" title="12"></a>
<a class="sourceLine" id="cb188-13" title="13"><span class="co">// int main() // not actual signature</span></a>
<a class="sourceLine" id="cb188-14" title="14"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>* argv[] )</a>
<a class="sourceLine" id="cb188-15" title="15">{</a>
<a class="sourceLine" id="cb188-16" title="16">    <span class="dt">char</span>* program = <span class="st">&quot;/bin/ls&quot;</span> ;</a>
<a class="sourceLine" id="cb188-17" title="17">    <span class="dt">char</span>* arg1 = <span class="st">&quot;-al&quot;</span> ;</a>
<a class="sourceLine" id="cb188-18" title="18">    <span class="dt">char</span>* arg2 = <span class="st">&quot;/home&quot;</span> ;</a>
<a class="sourceLine" id="cb188-19" title="19"></a>
<a class="sourceLine" id="cb188-20" title="20">    printf( <span class="st">&quot;BEFORE EXEC!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb188-21" title="21"></a>
<a class="sourceLine" id="cb188-22" title="22">    pid_t child = fork() ;</a>
<a class="sourceLine" id="cb188-23" title="23"></a>
<a class="sourceLine" id="cb188-24" title="24">    <span class="cf">if</span>( !child)</a>
<a class="sourceLine" id="cb188-25" title="25">    {</a>
<a class="sourceLine" id="cb188-26" title="26">        <span class="co">// in child process</span></a>
<a class="sourceLine" id="cb188-27" title="27">        <span class="dt">int</span> ret = execl( program, <span class="st">&quot;banana&quot;</span>, arg1, arg2, NULL ) ;</a>
<a class="sourceLine" id="cb188-28" title="28"></a>
<a class="sourceLine" id="cb188-29" title="29">        <span class="co">// ideally never comes here!</span></a>
<a class="sourceLine" id="cb188-30" title="30">        <span class="co">// as the child process&#39; code has now been replaced</span></a>
<a class="sourceLine" id="cb188-31" title="31">        perror(<span class="st">&quot;what happened!&quot;</span>) ;</a>
<a class="sourceLine" id="cb188-32" title="32">    }</a>
<a class="sourceLine" id="cb188-33" title="33"></a>
<a class="sourceLine" id="cb188-34" title="34">    <span class="dt">int</span> status ;</a>
<a class="sourceLine" id="cb188-35" title="35">    pid_t pid = wait(&amp;status) ;</a>
<a class="sourceLine" id="cb188-36" title="36"></a>
<a class="sourceLine" id="cb188-37" title="37">    <span class="cf">if</span>( WIFEXITED(status) )</a>
<a class="sourceLine" id="cb188-38" title="38">    {</a>
<a class="sourceLine" id="cb188-39" title="39">            <span class="co">// the child exited normally</span></a>
<a class="sourceLine" id="cb188-40" title="40">            printf( <span class="st">&quot;--PARENT--: Child %d exited with status %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb188-41" title="41">                    pid, WEXITSTATUS(status) ) ;</a>
<a class="sourceLine" id="cb188-42" title="42">    }</a>
<a class="sourceLine" id="cb188-43" title="43"></a>
<a class="sourceLine" id="cb188-44" title="44">    printf( <span class="st">&quot;AFTER EXEC!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb188-45" title="45"></a>
<a class="sourceLine" id="cb188-46" title="46">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb188-47" title="47">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb188-48" title="48">}</a></code></pre></div>
<h3 id="launch-any-child-processes"><span class="header-section-number">7.11.3</span> Launch <strong>Any</strong> Child Processes</h3>
<p>If we have <strong>another</strong> program that we’ve written, <em>e.g.</em>, <code>child1.c</code>:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb189-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb189-2" title="2"><span class="co"> * exec() child 1</span></a>
<a class="sourceLine" id="cb189-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb189-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb189-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb189-6" title="6"></a>
<a class="sourceLine" id="cb189-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb189-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb189-9" title="9"></a>
<a class="sourceLine" id="cb189-10" title="10"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>* argv[])</a>
<a class="sourceLine" id="cb189-11" title="11">{</a>
<a class="sourceLine" id="cb189-12" title="12">    <span class="co">/* Does nothing. Just prints the arguments passed to this program */</span></a>
<a class="sourceLine" id="cb189-13" title="13">    printf( <span class="st">&quot;INSIDE CHILD 1: argc = %d, argv[0] = %s, argv[1] = %s, argv[2] = %s</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb189-14" title="14">                                            argc, argv[<span class="dv">0</span>], argv[<span class="dv">1</span>], argv[<span class="dv">2</span>] ) ;</a>
<a class="sourceLine" id="cb189-15" title="15"> </a>
<a class="sourceLine" id="cb189-16" title="16">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb189-17" title="17">}</a></code></pre></div>
<p>Once it is compiled and linked and ready as an executable, say, <code>child1</code>, we can do:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb190-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb190-2" title="2"><span class="co"> * exec() </span></a>
<a class="sourceLine" id="cb190-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb190-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb190-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb190-6" title="6"></a>
<a class="sourceLine" id="cb190-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb190-8" title="8"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span><span class="pp">     </span><span class="co">// fork(), getpid()</span></a>
<a class="sourceLine" id="cb190-9" title="9"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span><span class="pp">  </span><span class="co">// pid_t</span></a>
<a class="sourceLine" id="cb190-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span><span class="pp">   </span><span class="co">// wait()</span></a>
<a class="sourceLine" id="cb190-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span><span class="pp">     </span><span class="co">// exit()</span></a>
<a class="sourceLine" id="cb190-12" title="12"></a>
<a class="sourceLine" id="cb190-13" title="13"><span class="co">// int main() // not actual signature</span></a>
<a class="sourceLine" id="cb190-14" title="14"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>* argv[] )</a>
<a class="sourceLine" id="cb190-15" title="15">{</a>
<a class="sourceLine" id="cb190-16" title="16">    <span class="dt">char</span>* program = <span class="st">&quot;./child1&quot;</span> ;</a>
<a class="sourceLine" id="cb190-17" title="17">    <span class="dt">char</span>* args = <span class="st">&quot;hello&quot;</span> ;</a>
<a class="sourceLine" id="cb190-18" title="18">    <span class="dt">char</span>* args2 = <span class="st">&quot;world&quot;</span> ;</a>
<a class="sourceLine" id="cb190-19" title="19"></a>
<a class="sourceLine" id="cb190-20" title="20">    pid_t child = fork() ;</a>
<a class="sourceLine" id="cb190-21" title="21"></a>
<a class="sourceLine" id="cb190-22" title="22">    <span class="cf">if</span>( !child)</a>
<a class="sourceLine" id="cb190-23" title="23">    {</a>
<a class="sourceLine" id="cb190-24" title="24">        <span class="co">// in child process</span></a>
<a class="sourceLine" id="cb190-25" title="25">        <span class="dt">int</span> ret = execl( program, <span class="st">&quot;banana&quot;</span>, args, args2, NULL ) ;</a>
<a class="sourceLine" id="cb190-26" title="26"></a>
<a class="sourceLine" id="cb190-27" title="27">        <span class="co">// ideally never comes here!</span></a>
<a class="sourceLine" id="cb190-28" title="28">        perror(<span class="st">&quot;what happened!&quot;</span>) ;</a>
<a class="sourceLine" id="cb190-29" title="29">    }</a>
<a class="sourceLine" id="cb190-30" title="30"></a>
<a class="sourceLine" id="cb190-31" title="31">    <span class="dt">int</span> status ;</a>
<a class="sourceLine" id="cb190-32" title="32">    pid_t pid = wait(&amp;status) ;</a>
<a class="sourceLine" id="cb190-33" title="33"></a>
<a class="sourceLine" id="cb190-34" title="34">    <span class="cf">if</span>( WIFEXITED(status) )</a>
<a class="sourceLine" id="cb190-35" title="35">    {</a>
<a class="sourceLine" id="cb190-36" title="36">            <span class="co">// the child exited normally</span></a>
<a class="sourceLine" id="cb190-37" title="37">            printf( <span class="st">&quot;--PARENT--: Child %d exited with status %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb190-38" title="38">                    pid, WEXITSTATUS(status) ) ;</a>
<a class="sourceLine" id="cb190-39" title="39">    }</a>
<a class="sourceLine" id="cb190-40" title="40"></a>
<a class="sourceLine" id="cb190-41" title="41">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb190-42" title="42">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb190-43" title="43">}</a></code></pre></div>
<h1 id="process-descriptors"><span class="header-section-number">8</span> Process Descriptors</h1>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/process_descriptors.html">Slides</a></p>
<p>We’re going to start discussing how processes can <strong>manipulate the resources</strong> it has access to.</p>
<h3 id="key-mechanisms"><span class="header-section-number">8.0.1</span> Key Mechanisms</h3>
<p>for a process to use effectively</p>
<ul>
<li>current working directory, <code>pwd</code></li>
<li>ability to manipulate <strong>descriptors</strong>
<ul>
<li>“file descriptors”</li>
</ul></li>
<li>controlling “exceptional” control flow, via <strong>signals</strong></li>
</ul>
<h3 id="current-working-directory"><span class="header-section-number">8.0.2</span> current working directory</h3>
<ul>
<li>each process has a “working directory”</li>
<li>base for any relative pathrs</li>
<li>all file system paths are one of,
<ul>
<li>absolute paths → they begin with “/”</li>
<li>relative paths</li>
</ul></li>
</ul>
<p>Relative paths are quite frequently used when we interact with the shell. Every time you type <code>cd blah/</code>, you’re saying “please change the current working directory to <code>blah/</code>” which is a directory in the current working directory.</p>
<p>A simple API to interact with the current working directory: |function| operation | |——–|——–| | <code>getcwd</code>| gets the current process’ working dir | | <code>chdir</code>| enables process to change dir | ||</p>
<p>both defined in <code>&lt;unistd.h&gt;</code>.</p>
<p>A quick listing of the <em>directory structure</em> of Linux: <img src="figures/linux-dir.png" height="400"></p>
<p>Let’s look at a simple code example:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb191-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb191-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb191-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb191-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb191-5" title="5"></a>
<a class="sourceLine" id="cb191-6" title="6"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb191-7" title="7">{</a>
<a class="sourceLine" id="cb191-8" title="8">    <span class="dt">char</span> *wd = getcwd(NULL, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb191-9" title="9"></a>
<a class="sourceLine" id="cb191-10" title="10">    assert(wd);</a>
<a class="sourceLine" id="cb191-11" title="11">    printf(<span class="st">&quot;Current directory: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, wd);</a>
<a class="sourceLine" id="cb191-12" title="12">    free(wd);</a>
<a class="sourceLine" id="cb191-13" title="13"></a>
<a class="sourceLine" id="cb191-14" title="14">    <span class="cf">if</span> (chdir(<span class="st">&quot;..&quot;</span>) == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb191-15" title="15">        perror(<span class="st">&quot;chdir&quot;</span>);</a>
<a class="sourceLine" id="cb191-16" title="16">        abort();</a>
<a class="sourceLine" id="cb191-17" title="17">    }</a>
<a class="sourceLine" id="cb191-18" title="18">    wd = getcwd(NULL, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb191-19" title="19">    printf(<span class="st">&quot;New current dir: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, wd);</a>
<a class="sourceLine" id="cb191-20" title="20">    free(wd);</a>
<a class="sourceLine" id="cb191-21" title="21"></a>
<a class="sourceLine" id="cb191-22" title="22">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb191-23" title="23">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb191-24" title="24">}</a></code></pre></div>
<p><br></p>
<p><strong>Note:</strong> the command <code>cd</code> is actually <strong>not</strong> a program, and is instead a <em>shell-internal function</em>. Try using the <code>which</code> program (used to find the location of a <em>known</em> program):</p>
<pre><code>$ which ls
/bin/ls
$ which pwd
/bin/pwd
$ which cd
$</code></pre>
<h3 id="process-descriptors-1"><span class="header-section-number">8.0.3</span> Process Descriptors</h3>
<ul>
<li>each process has a set of <strong>descriptors</strong></li>
<li>associated with a system resource
<ul>
<li>integer → passed to a family of APIs</li>
</ul></li>
</ul>
<p><img src="figures/process.png" height="300"></p>
<p><br></p>
<p>Most processes have <strong>at least</strong> three: |number | descriptor | What it is | |——–|——–|——–| |<code>0</code> | <code>STDIN_FILENO</code> | standard <strong>input</strong> | |<code>1</code> | <code>STDOUT_FILENO</code> | standard <strong>output</strong> | |<code>2</code> | <code>STDERR_FILENO</code> | standard <strong>error</strong> <code>perror()</code>| ||</p>
<p>defined in <code>unistd.h</code>.</p>
<h4 id="standard-input-output-and-error"><span class="header-section-number">8.0.3.1</span> Standard <strong>input</strong>, <strong>output</strong> and <strong>error</strong></h4>
<ul>
<li><em>infinite</em> sequence of bytes or “channels”</li>
<li>can terminate, if they run out of data
<ul>
<li><em>e.g.</em>, reaches end of file</li>
<li>user hits <code>ctrl-d</code></li>
</ul></li>
</ul>
<p>When we type at the shell, we’re providing a channel of data that is sent to the standard input of the active process. When a process prints, it sends a sequence of characters to the standard output, and because programs can loop, that stream can be <strong>infinite</strong>!</p>
<p><code>STDIN_FILENO</code> = <code>0</code> is the <em>standard input</em>, or the main way the process gets input from the system. As such, the resource is often the terminal if the user directly provides input, or sometimes the output of a previous stage in a command-line pipeline. <code>STDOUT_FILENO</code> = <code>1</code> is the <em>standard output</em>, or the main way the process sends its output to the system. When we call <code>printf</code>, it will, by default, output using this descriptor. <code>STDERR_FILENO</code> = <code>2</code> is the <em>standard error</em>, or the main way that the process outputs error messages. <code>perror</code> (and other error-centric APIs) output to the standard error.</p>
<p>Each of these descriptors is associated with a potentially infinite sequence of bytes, or <em>channel</em><a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>. When we type at the shell, we’re providing a channel of data that is sent to the standard input of the active process. When a process prints, it sends a sequence of characters to the standard output, and because programs can loop, that stream can be infinite! Channels, however, <em>can</em> terminate if they run out of data. This could happen, for example, if a channel reading through a file reaches the end of the file, or if the user hits <code>cntl-d</code> on their terminal to signify “I don’t have any more data”.</p>
<h3 id="file-descriptor-operations"><span class="header-section-number">8.0.4</span> File Descriptor Operations</h3>
<p>Now these are <strong>file descriptors</strong> so we treat them as <strong>files</strong>!</p>
<p>File descriptors are <em>analogous</em> to pointers. The descriptors effectively <em>point to channel resources</em>.</p>
<p>Some core operations on files: |operation| interface | |———|———–| |<strong>pull</strong> bytes from channel into buffer | <code>read</code> | |<strong>send</strong> bytes from channel into buffer | <code>write</code> |<strong>duplicate</strong> a file descriptor | <code>dup/dup2/dup3</code> | |<strong>deallocate</strong> a file descriptor | <code>close</code> | ||</p>
<p><strong>Note:</strong>: - <code>printf()</code> is a <code>write</code> to standard out - <code>close</code> doesn’t necessarily remove channel - analogous to removing a pointer</p>
<h4 id="dup-vs-dup2-vs-dup3"><span class="header-section-number">8.0.4.1</span> <code>dup()</code> vs <code>dup2()</code> vs <code>dup3()</code></h4>
<ul>
<li><code>dup()</code> returns smallest unused number as <code>fd</code></li>
<li><code>dup2()</code> same as dup() but uses given <code>fd</code></li>
<li>if given <code>fd</code> exists, then it is closed, <em>atomically</em></li>
<li><code>dup3()</code> same as <code>dup2()</code> but takes flags as input</li>
</ul>
<p>Look at the <code>man dup</code> page for more information.</p>
<p>Let’s see some of these calls in action:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb193-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb193-2" title="2"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb193-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb193-4" title="4"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb193-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb193-6" title="6"></a>
<a class="sourceLine" id="cb193-7" title="7"><span class="dt">int</span></a>
<a class="sourceLine" id="cb193-8" title="8">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb193-9" title="9">{</a>
<a class="sourceLine" id="cb193-10" title="10">    <span class="dt">char</span> *hw = <span class="st">&quot;hello world</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb193-11" title="11">    <span class="dt">char</span> output[<span class="dv">256</span>];</a>
<a class="sourceLine" id="cb193-12" title="12">    <span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb193-13" title="13">    <span class="dt">ssize_t</span> amnt; <span class="co">/* signed size */</span></a>
<a class="sourceLine" id="cb193-14" title="14"></a>
<a class="sourceLine" id="cb193-15" title="15">    amnt = write(STDOUT_FILENO, hw, strlen(hw));</a>
<a class="sourceLine" id="cb193-16" title="16">    <span class="cf">if</span> (amnt == <span class="dv">0</span>) { <span class="co">/* maybe STDOUT writes to a file with no disk space! */</span></a>
<a class="sourceLine" id="cb193-17" title="17">        <span class="co">/* this is *not* an error, so errno not set! */</span></a>
<a class="sourceLine" id="cb193-18" title="18">        printf(<span class="st">&quot;Cannot write more data to channel</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb193-19" title="19">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb193-20" title="20">    } <span class="cf">else</span> <span class="cf">if</span> (amnt &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb193-21" title="21">        <span class="co">/* normally, the return value tells us how much was written */</span></a>
<a class="sourceLine" id="cb193-22" title="22">        assert(amnt == (<span class="dt">ssize_t</span>)strlen(hw));</a>
<a class="sourceLine" id="cb193-23" title="23">    } <span class="cf">else</span> { <span class="co">/* amnt == -1 */</span></a>
<a class="sourceLine" id="cb193-24" title="24">        perror(<span class="st">&quot;Error writing to stdout&quot;</span>);</a>
<a class="sourceLine" id="cb193-25" title="25">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb193-26" title="26">    }</a>
<a class="sourceLine" id="cb193-27" title="27"></a>
<a class="sourceLine" id="cb193-28" title="28">    amnt = write(STDERR_FILENO, hw, strlen(hw));</a>
<a class="sourceLine" id="cb193-29" title="29">    assert(amnt &gt;= <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb193-30" title="30"></a>
<a class="sourceLine" id="cb193-31" title="31">    fd = dup(STDOUT_FILENO);</a>
<a class="sourceLine" id="cb193-32" title="32">    assert(fd &gt;= <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb193-33" title="33"></a>
<a class="sourceLine" id="cb193-34" title="34">    <span class="co">/* We can write formatted data out to stdout manually! */</span></a>
<a class="sourceLine" id="cb193-35" title="35">    snprintf(output, <span class="dv">255</span>, <span class="st">&quot;in: %d, out: %d, err: %d, new: %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb193-36" title="36">             STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO, fd);</a>
<a class="sourceLine" id="cb193-37" title="37">    output[<span class="dv">255</span>] = &#39;\<span class="dv">0</span><span class="er">&#39;</span>;</a>
<a class="sourceLine" id="cb193-38" title="38">    amnt = write(fd, output, strlen(output));</a>
<a class="sourceLine" id="cb193-39" title="39">    <span class="co">/* new file descriptors are supposed to use the lowest unused descriptor! */</span></a>
<a class="sourceLine" id="cb193-40" title="40"></a>
<a class="sourceLine" id="cb193-41" title="41">    <span class="co">/* make a descriptor available */</span></a>
<a class="sourceLine" id="cb193-42" title="42">    close(STDIN_FILENO); <span class="co">/* STDIN is no longer really the input! */</span></a>
<a class="sourceLine" id="cb193-43" title="43">    fd = dup(STDOUT_FILENO);</a>
<a class="sourceLine" id="cb193-44" title="44">    printf(<span class="st">&quot;New descriptor @ %d</span><span class="sc">\n</span><span class="st">&quot;</span>, fd);</a>
<a class="sourceLine" id="cb193-45" title="45"></a>
<a class="sourceLine" id="cb193-46" title="46">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb193-47" title="47">}</a></code></pre></div>
<p>You can run this, and redirect the standard error to a file to see that writing to standard error is a different operation than writing to standard output. For example: <code>$ prog 2&gt; errors.txt</code> will redirect file descriptor <code>2</code> (stderr) to the file.</p>
<p>Lets focus in a little bit on <code>read</code> and <code>write</code>. First, it is notable that the buffer they take as an argument (along with its length) is simply an array of bytes. It can be a string, or it could be the bytes that are part of an encoded video. Put another way, by default, <em>channels are just sequences of bytes</em>. It is up to our program to interpret those bytes properly.</p>
<p>Second, we need to understand that the return value for <code>read</code>/<code>write</code> has four main, interesting conditions:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb194-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb194-2" title="2"><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span></a>
<a class="sourceLine" id="cb194-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb194-4" title="4"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb194-5" title="5"></a>
<a class="sourceLine" id="cb194-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb194-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb194-8" title="8">{</a>
<a class="sourceLine" id="cb194-9" title="9">    <span class="dt">ssize_t</span> amnt;</a>
<a class="sourceLine" id="cb194-10" title="10">    <span class="dt">char</span> *hi = <span class="st">&quot;more complicated than you&#39;d think...&quot;</span>;</a>
<a class="sourceLine" id="cb194-11" title="11">    <span class="dt">ssize_t</span> hi_sz = strlen(hi);</a>
<a class="sourceLine" id="cb194-12" title="12"></a>
<a class="sourceLine" id="cb194-13" title="13">    amnt = write(STDOUT_FILENO, hi, hi_sz);</a>
<a class="sourceLine" id="cb194-14" title="14"></a>
<a class="sourceLine" id="cb194-15" title="15">    <span class="co">/* Can often mean that we are not able to write to the resource */</span></a>
<a class="sourceLine" id="cb194-16" title="16">    <span class="cf">if</span> (amnt == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb194-17" title="17">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb194-18" title="18"><span class="co">         * Keep trying to write, or give up.</span></a>
<a class="sourceLine" id="cb194-19" title="19"><span class="co">         * Common return value for `read` when a file has no more data, or a pipe is closed.</span></a>
<a class="sourceLine" id="cb194-20" title="20"><span class="co">         */</span></a>
<a class="sourceLine" id="cb194-21" title="21">    } <span class="cf">else</span> <span class="cf">if</span> (amnt &gt; <span class="dv">0</span> &amp;&amp; amnt &lt; hi_sz) {</a>
<a class="sourceLine" id="cb194-22" title="22">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb194-23" title="23"><span class="co">         * Didn&#39;t write everythign we wanted, better call write again sending</span></a>
<a class="sourceLine" id="cb194-24" title="24"><span class="co">         * data starting at `&amp;hi[amnt]`, of length `hi_sz - amnt`.</span></a>
<a class="sourceLine" id="cb194-25" title="25"><span class="co">         */</span></a>
<a class="sourceLine" id="cb194-26" title="26">    } <span class="cf">else</span> <span class="cf">if</span> (amnt == hi_sz) {</a>
<a class="sourceLine" id="cb194-27" title="27">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb194-28" title="28"><span class="co">         * Wrote out everything! Wooo!</span></a>
<a class="sourceLine" id="cb194-29" title="29"><span class="co">         */</span></a>
<a class="sourceLine" id="cb194-30" title="30">    } <span class="cf">else</span> { <span class="co">/* amnt == -1 */</span></a>
<a class="sourceLine" id="cb194-31" title="31">        <span class="co">/* Could be a genuine error, but not always... */</span></a>
<a class="sourceLine" id="cb194-32" title="32">        <span class="cf">if</span> (errno == EPIPE || errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK) {</a>
<a class="sourceLine" id="cb194-33" title="33">            <span class="co">/* conditions we should probably handle properly */</span></a>
<a class="sourceLine" id="cb194-34" title="34">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb194-35" title="35">            <span class="co">/* error in the channel! */</span></a>
<a class="sourceLine" id="cb194-36" title="36">        }</a>
<a class="sourceLine" id="cb194-37" title="37">    }</a>
<a class="sourceLine" id="cb194-38" title="38"></a>
<a class="sourceLine" id="cb194-39" title="39">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb194-40" title="40">}</a></code></pre></div>
<p>It is common to have a convention on how channel data is structured. UNIX pipeline encourage channels to be plain text, so that each program can read from their standard input, do some processing that can involved filtering out data or transforming it, and send the result to the standard out. That standard output is sent to the standard input of the next process in the pipeline. An example in which we print out each unique program that is executing on the system:</p>
<pre><code>$ ps aux | tr -s &#39; &#39; | cut -d &#39; &#39; -f 11 | sort | uniq</code></pre>
<p>Each of the programs in the pipeline is not configured to print out each unique process, and we are able to compose them together in a pipeline to accomplish the goal.</p>
<h2 id="pipes"><span class="header-section-number">8.1</span> Pipes</h2>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/pipes.html">Slides</a></p>
<p>Processes have resources</p>
<p><img src="figures/process.png" height="300"></p>
<p>Note that descriptors <code>0-2</code> are automatically set up: - <code>STDIN_FILENO</code> - <code>STDOUT_FILENO</code> - <code>STDERR_FILENO</code></p>
<p>But how do we <em>create</em> resources? But first off, <strong>what</strong> are resources? There are many different resources in a UNIX system, but three of the main ones:</p>
<ol type="1">
<li><code>files</code> and other file-system objects (e.g. directories),</li>
<li><code>sockets</code> that are used to communicate over the network, and</li>
<li>communication facilities like <code>pipe</code>s that are used to send data and coordinate between processes.</li>
</ol>
<p>Each of these has very different APIs for creating the resources. We’ll discuss files later, and will now focus on <strong><code>pipe</code>s</strong>.</p>
<p>We’ve seen pipes before:</p>
<pre><code>$ ps aux | tr -s &#39; &#39; | cut -d &#39; &#39; -f 11 | sort | uniq</code></pre>
<p>(look up each of those commands).</p>
<p>Not what we’re talking about…well, not exactly!</p>
<h3 id="unix-pipes"><span class="header-section-number">8.1.1</span> unix ‘pipes’</h3>
<p>(short for “<em>pipelines</em>”)</p>
<p>A finite <em>channel</em> → a sequence of bytes:</p>
<p><img src="figures/pipes4.png" height="75"></p>
<p>A pipe is accessed using <strong>two (file) descriptors</strong><a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>,</p>
<table>
<thead>
<tr class="header">
<th>descriptor</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fd[0]</code></td>
<td>read</td>
</tr>
<tr class="even">
<td><code>fd[1]</code></td>
<td>write</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>This can be represented as follows:</p>
<p><img src="figures/pipes6.png" height="75"></p>
<p>The sequence of bytes written to the pipe will be correspondingly read out <em>in a FIFO</em> manner.</p>
<h3 id="pipes-api"><span class="header-section-number">8.1.2</span> pipes api</h3>
<div class="sourceCode" id="cb197"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb197-1" title="1"><span class="dt">int</span> pipe( <span class="dt">int</span> pipefd[<span class="dv">2</span>] ) ;</a></code></pre></div>
<p>defined in <code>&lt;unistd.h&gt;</code>.</p>
<p>The <code>pipe</code> and <code>pipe2</code> functions create a pipe resource, and return the two file descriptors that reference the readable and writable ends of the pipe.</p>
<p><strong>Return values</strong></p>
<table>
<thead>
<tr class="header">
<th>value</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0</code></td>
<td>success</td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td>failed</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>We use a familiar interface to send/receive data from a pipe, <em>viz.</em>, <code>read()</code> and <code>write()</code>.</p>
<p>Let’s look at a simple example of how to use a <code>pipe</code>.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb198-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb198-2" title="2"><span class="co"> * intro to pipes</span></a>
<a class="sourceLine" id="cb198-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb198-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb198-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb198-6" title="6"></a>
<a class="sourceLine" id="cb198-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb198-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb198-9" title="9"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb198-10" title="10"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb198-11" title="11"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb198-12" title="12"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb198-13" title="13"><span class="pp">#include </span><span class="im">&lt;sys/param.h&gt;</span><span class="pp"> </span><span class="co">/* MIN */</span></a>
<a class="sourceLine" id="cb198-14" title="14"></a>
<a class="sourceLine" id="cb198-15" title="15"><span class="pp">#define BUFFER_SIZE 16</span></a>
<a class="sourceLine" id="cb198-16" title="16"></a>
<a class="sourceLine" id="cb198-17" title="17"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb198-18" title="18">{</a>
<a class="sourceLine" id="cb198-19" title="19">    <span class="dt">char</span> from[BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb198-20" title="20">    <span class="dt">char</span> to[BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb198-21" title="21"></a>
<a class="sourceLine" id="cb198-22" title="22">    <span class="dt">int</span> pipe_fds[<span class="dv">2</span>] ; <span class="co">// the two FDs for reading/writing</span></a>
<a class="sourceLine" id="cb198-23" title="23"></a>
<a class="sourceLine" id="cb198-24" title="24">    memset( from, <span class="ch">&#39;x&#39;</span>, BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb198-25" title="25">    memset (to, <span class="ch">&#39;-&#39;</span>, BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb198-26" title="26"></a>
<a class="sourceLine" id="cb198-27" title="27">    <span class="cf">if</span>( pipe(pipe_fds) )</a>
<a class="sourceLine" id="cb198-28" title="28">    {</a>
<a class="sourceLine" id="cb198-29" title="29">        <span class="co">// non zero is an error!</span></a>
<a class="sourceLine" id="cb198-30" title="30">        perror( <span class="st">&quot;Pipe creation failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb198-31" title="31">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb198-32" title="32">    }</a>
<a class="sourceLine" id="cb198-33" title="33"></a>
<a class="sourceLine" id="cb198-34" title="34">    printf( <span class="st">&quot;BEFORE</span><span class="sc">\n\t</span><span class="st"> from: %s</span><span class="sc">\n\t</span><span class="st"> to: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, from, to ) ;</a>
<a class="sourceLine" id="cb198-35" title="35"></a>
<a class="sourceLine" id="cb198-36" title="36">    <span class="dt">ssize_t</span> write_return = write( pipe_fds[<span class="dv">1</span>], &amp;from, BUFFER_SIZE ) ;</a>
<a class="sourceLine" id="cb198-37" title="37">    assert( write_return == BUFFER_SIZE ) ; <span class="co">// check how many bytes were written</span></a>
<a class="sourceLine" id="cb198-38" title="38"></a>
<a class="sourceLine" id="cb198-39" title="39">    <span class="dt">ssize_t</span> read_return = read( pipe_fds[<span class="dv">0</span>], &amp;to, BUFFER_SIZE ) ;</a>
<a class="sourceLine" id="cb198-40" title="40"></a>
<a class="sourceLine" id="cb198-41" title="41">    printf( <span class="st">&quot;AFTER</span><span class="sc">\n\t</span><span class="st"> from: %s</span><span class="sc">\n\t</span><span class="st"> to: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, from, to ) ;</a>
<a class="sourceLine" id="cb198-42" title="42"></a>
<a class="sourceLine" id="cb198-43" title="43"></a>
<a class="sourceLine" id="cb198-44" title="44">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb198-45" title="45">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb198-46" title="46">}</a></code></pre></div>
<p>Output, as expected:</p>
<pre><code>BEFORE
         from: xxxxxxxxxxxxxxx
         to: ---------------
AFTER
         from: xxxxxxxxxxxxxxx
         to: xxxxxxxxxxxxxxx</code></pre>
<p>Now, let’s change things a bit. Let’s make the <code>from</code> buffer really <strong>LARGE</strong>!</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb200-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb200-2" title="2"><span class="co"> * intro to pipes</span></a>
<a class="sourceLine" id="cb200-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb200-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb200-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb200-6" title="6"></a>
<a class="sourceLine" id="cb200-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb200-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb200-9" title="9"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb200-10" title="10"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb200-11" title="11"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb200-12" title="12"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb200-13" title="13"><span class="pp">#include </span><span class="im">&lt;sys/param.h&gt;</span><span class="pp"> </span><span class="co">/* MIN */</span></a>
<a class="sourceLine" id="cb200-14" title="14"></a>
<a class="sourceLine" id="cb200-15" title="15"><span class="pp">#define BUFFER_SIZE 16</span></a>
<a class="sourceLine" id="cb200-16" title="16"><span class="pp">#define LARGE_BUFFER_SIZE 1&lt;&lt;18</span></a>
<a class="sourceLine" id="cb200-17" title="17"></a>
<a class="sourceLine" id="cb200-18" title="18"></a>
<a class="sourceLine" id="cb200-19" title="19"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb200-20" title="20">{</a>
<a class="sourceLine" id="cb200-21" title="21">    <span class="dt">char</span> from[LARGE_BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb200-22" title="22">    <span class="dt">char</span> to[BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb200-23" title="23"></a>
<a class="sourceLine" id="cb200-24" title="24">    <span class="dt">int</span> pipe_fds[<span class="dv">2</span>] ; <span class="co">// the two FDs for reading/writing</span></a>
<a class="sourceLine" id="cb200-25" title="25"></a>
<a class="sourceLine" id="cb200-26" title="26">    memset( from, <span class="ch">&#39;x&#39;</span>, LARGE_BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb200-27" title="27">    memset (to, <span class="ch">&#39;-&#39;</span>, BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb200-28" title="28"></a>
<a class="sourceLine" id="cb200-29" title="29">    <span class="cf">if</span>( pipe(pipe_fds) )</a>
<a class="sourceLine" id="cb200-30" title="30">    {</a>
<a class="sourceLine" id="cb200-31" title="31">        <span class="co">// non zero is an error!</span></a>
<a class="sourceLine" id="cb200-32" title="32">        perror( <span class="st">&quot;Pipe creation failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb200-33" title="33">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb200-34" title="34">    }</a>
<a class="sourceLine" id="cb200-35" title="35"></a>
<a class="sourceLine" id="cb200-36" title="36">    <span class="dt">ssize_t</span> write_return = write( pipe_fds[<span class="dv">1</span>], &amp;from, LARGE_BUFFER_SIZE ) ;</a>
<a class="sourceLine" id="cb200-37" title="37">    printf( <span class="st">&quot;Here!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb200-38" title="38">    assert( write_return == LARGE_BUFFER_SIZE ) ; <span class="co">// check how many bytes were written</span></a>
<a class="sourceLine" id="cb200-39" title="39"></a>
<a class="sourceLine" id="cb200-40" title="40">    <span class="dt">ssize_t</span> read_return = read( pipe_fds[<span class="dv">0</span>], &amp;to, BUFFER_SIZE ) ;</a>
<a class="sourceLine" id="cb200-41" title="41"></a>
<a class="sourceLine" id="cb200-42" title="42">    printf( <span class="st">&quot;AFTER</span><span class="sc">\n\t</span><span class="st"> to: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, from, to ) ;</a>
<a class="sourceLine" id="cb200-43" title="43"></a>
<a class="sourceLine" id="cb200-44" title="44"></a>
<a class="sourceLine" id="cb200-45" title="45">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb200-46" title="46">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb200-47" title="47">}</a></code></pre></div>
<p>Output is empty and the program <strong>doesn’t terminate</strong>. Why? Two reasons:</p>
<ol type="1">
<li>the size of a pipe is <strong>limited</strong> (usually <code>64k</code> on moder linux)</li>
<li><code>write()</code> <strong>blocks</strong> until a <code>read()</code> clears some space in the pipe buffer.</li>
</ol>
<p>You can get/set the size of the pipe buffer. See <code>man 7 pipe</code> for more details.</p>
<p>so, what do we need to do? We need to <strong>clear</strong> the pipe buffer by using <code>read</code>.</p>
<p>Why does this not work?</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb201-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb201-2" title="2"><span class="co"> * intro to pipes</span></a>
<a class="sourceLine" id="cb201-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb201-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb201-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb201-6" title="6"></a>
<a class="sourceLine" id="cb201-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb201-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb201-9" title="9"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb201-10" title="10"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb201-11" title="11"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb201-12" title="12"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb201-13" title="13"><span class="pp">#include </span><span class="im">&lt;sys/param.h&gt;</span><span class="pp"> </span><span class="co">/* MIN */</span></a>
<a class="sourceLine" id="cb201-14" title="14"></a>
<a class="sourceLine" id="cb201-15" title="15"><span class="pp">#define BUFFER_SIZE 16</span></a>
<a class="sourceLine" id="cb201-16" title="16"><span class="pp">#define LARGE_BUFFER_SIZE 1&lt;&lt;18</span></a>
<a class="sourceLine" id="cb201-17" title="17"></a>
<a class="sourceLine" id="cb201-18" title="18"></a>
<a class="sourceLine" id="cb201-19" title="19"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb201-20" title="20">{</a>
<a class="sourceLine" id="cb201-21" title="21">    <span class="dt">char</span> from[LARGE_BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb201-22" title="22">    <span class="dt">char</span> to[LARGE_BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb201-23" title="23"></a>
<a class="sourceLine" id="cb201-24" title="24">    <span class="dt">int</span> pipe_fds[<span class="dv">2</span>] ; <span class="co">// the two FDs for reading/writing</span></a>
<a class="sourceLine" id="cb201-25" title="25"></a>
<a class="sourceLine" id="cb201-26" title="26">    memset( from, <span class="ch">&#39;x&#39;</span>, LARGE_BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb201-27" title="27">    memset (to, <span class="ch">&#39;-&#39;</span>, LARGE_BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb201-28" title="28"></a>
<a class="sourceLine" id="cb201-29" title="29">    <span class="cf">if</span>( pipe(pipe_fds) )</a>
<a class="sourceLine" id="cb201-30" title="30">    {</a>
<a class="sourceLine" id="cb201-31" title="31">        <span class="co">// non zero is an error!</span></a>
<a class="sourceLine" id="cb201-32" title="32">        perror( <span class="st">&quot;Pipe creation failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb201-33" title="33">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb201-34" title="34">    }</a>
<a class="sourceLine" id="cb201-35" title="35"></a>
<a class="sourceLine" id="cb201-36" title="36">    <span class="dt">ssize_t</span> write_return = write( pipe_fds[<span class="dv">1</span>], &amp;from, LARGE_BUFFER_SIZE ) ;</a>
<a class="sourceLine" id="cb201-37" title="37">    printf( <span class="st">&quot;Here!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb201-38" title="38">    assert( write_return == LARGE_BUFFER_SIZE ) ; <span class="co">// check how many bytes were written</span></a>
<a class="sourceLine" id="cb201-39" title="39"></a>
<a class="sourceLine" id="cb201-40" title="40">    <span class="dt">ssize_t</span> read_return = read( pipe_fds[<span class="dv">0</span>], &amp;to, LARGE_BUFFER_SIZE ) ;</a>
<a class="sourceLine" id="cb201-41" title="41"></a>
<a class="sourceLine" id="cb201-42" title="42">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb201-43" title="43">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb201-44" title="44">}</a></code></pre></div>
<p>Because the <code>write()</code> is <em>still blocked</em>! We haven’t cleared the pipe buffer. The <code>write()</code> call <em>has not returned</em> and so the <code>read()</code> call <em>cannot run</em>!</p>
<p><strong>Note</strong>: this is not parallel execution!</p>
<p>So, let’s fix it. By writing and reading inside a loop, using <strong>smaller chunks</strong> of read/write each time.</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb202-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb202-2" title="2"><span class="co"> * intro to pipes</span></a>
<a class="sourceLine" id="cb202-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb202-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb202-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb202-6" title="6"></a>
<a class="sourceLine" id="cb202-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb202-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb202-9" title="9"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb202-10" title="10"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb202-11" title="11"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb202-12" title="12"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb202-13" title="13"><span class="pp">#include </span><span class="im">&lt;sys/param.h&gt;</span><span class="pp"> </span><span class="co">/* MIN */</span></a>
<a class="sourceLine" id="cb202-14" title="14"></a>
<a class="sourceLine" id="cb202-15" title="15"><span class="pp">#define BUFFER_SIZE 16</span></a>
<a class="sourceLine" id="cb202-16" title="16"><span class="pp">#define LARGE_BUFFER_SIZE 1&lt;&lt;18</span></a>
<a class="sourceLine" id="cb202-17" title="17"></a>
<a class="sourceLine" id="cb202-18" title="18"><span class="pp">#define WRITE_CHUNK 1&lt;&lt;8</span></a>
<a class="sourceLine" id="cb202-19" title="19"></a>
<a class="sourceLine" id="cb202-20" title="20"></a>
<a class="sourceLine" id="cb202-21" title="21"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb202-22" title="22">{</a>
<a class="sourceLine" id="cb202-23" title="23">    <span class="dt">char</span> from[LARGE_BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb202-24" title="24">    <span class="dt">char</span> to[LARGE_BUFFER_SIZE] = {&#39;\<span class="dv">0</span><span class="er">&#39;</span>} ;</a>
<a class="sourceLine" id="cb202-25" title="25"></a>
<a class="sourceLine" id="cb202-26" title="26">    <span class="dt">int</span> pipe_fds[<span class="dv">2</span>] ; <span class="co">// the two FDs for reading/writing</span></a>
<a class="sourceLine" id="cb202-27" title="27"></a>
<a class="sourceLine" id="cb202-28" title="28">    memset( from, <span class="ch">&#39;x&#39;</span>, LARGE_BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb202-29" title="29">    memset (to, <span class="ch">&#39;-&#39;</span>, LARGE_BUFFER_SIZE-<span class="dv">1</span> ) ;</a>
<a class="sourceLine" id="cb202-30" title="30"></a>
<a class="sourceLine" id="cb202-31" title="31">    <span class="dt">int</span> buffer_size = <span class="kw">sizeof</span>(from) ;</a>
<a class="sourceLine" id="cb202-32" title="32"></a>
<a class="sourceLine" id="cb202-33" title="33">    <span class="cf">if</span>( pipe(pipe_fds) )</a>
<a class="sourceLine" id="cb202-34" title="34">    {</a>
<a class="sourceLine" id="cb202-35" title="35">        <span class="co">// non zero is an error!</span></a>
<a class="sourceLine" id="cb202-36" title="36">        perror( <span class="st">&quot;Pipe creation failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb202-37" title="37">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb202-38" title="38">    }</a>
<a class="sourceLine" id="cb202-39" title="39"></a>
<a class="sourceLine" id="cb202-40" title="40">    <span class="dt">size_t</span> written = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb202-41" title="41">    <span class="cf">while</span>( buffer_size )</a>
<a class="sourceLine" id="cb202-42" title="42">    {</a>
<a class="sourceLine" id="cb202-43" title="43">        <span class="dt">ssize_t</span> write_return, read_return ;</a>
<a class="sourceLine" id="cb202-44" title="44">        <span class="dt">size_t</span> write_amount = MIN( buffer_size, WRITE_CHUNK ) ;</a>
<a class="sourceLine" id="cb202-45" title="45"></a>
<a class="sourceLine" id="cb202-46" title="46">        write_return = write( pipe_fds[<span class="dv">1</span>], &amp;from[written], write_amount ) ;</a>
<a class="sourceLine" id="cb202-47" title="47">        <span class="cf">if</span>( write_return &lt; <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb202-48" title="48">        {</a>
<a class="sourceLine" id="cb202-49" title="49">            perror( <span class="st">&quot;Error writing to pipe!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb202-50" title="50">            exit(EXIT_FAILURE) ;</a>
<a class="sourceLine" id="cb202-51" title="51">        }</a>
<a class="sourceLine" id="cb202-52" title="52"></a>
<a class="sourceLine" id="cb202-53" title="53">        read_return = read( pipe_fds[<span class="dv">0</span>], &amp;to[written], write_return ) ;</a>
<a class="sourceLine" id="cb202-54" title="54">        assert( read_return == write_return ) ;</a>
<a class="sourceLine" id="cb202-55" title="55"></a>
<a class="sourceLine" id="cb202-56" title="56">        <span class="co">// what&#39;s going on here?</span></a>
<a class="sourceLine" id="cb202-57" title="57">        buffer_size -= write_return ;</a>
<a class="sourceLine" id="cb202-58" title="58">        written += write_return ;</a>
<a class="sourceLine" id="cb202-59" title="59">    }</a>
<a class="sourceLine" id="cb202-60" title="60"></a>
<a class="sourceLine" id="cb202-61" title="61">    assert( memcmp( from, to, <span class="kw">sizeof</span>(from) ) == <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb202-62" title="62">    printf( <span class="st">&quot;from and to are IDENTICAL!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb202-63" title="63"></a>
<a class="sourceLine" id="cb202-64" title="64">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb202-65" title="65">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb202-66" title="66">}</a></code></pre></div>
<p>Now, let’s make this more interesting (and actually useful)! Let’s send data <strong>between processes</strong>, <strong>i.e.,</strong> using <code>fork()</code>!</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb203-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb203-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb203-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb203-4" title="4"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb203-5" title="5"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb203-6" title="6"></a>
<a class="sourceLine" id="cb203-7" title="7"><span class="co">/* Large array containing 2^20 characters */</span></a>
<a class="sourceLine" id="cb203-8" title="8"><span class="dt">char</span> from[<span class="dv">1</span> &lt;&lt; <span class="dv">20</span>];</a>
<a class="sourceLine" id="cb203-9" title="9"><span class="dt">char</span> to[<span class="dv">1</span> &lt;&lt; <span class="dv">20</span>];</a>
<a class="sourceLine" id="cb203-10" title="10"></a>
<a class="sourceLine" id="cb203-11" title="11"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb203-12" title="12">{</a>
<a class="sourceLine" id="cb203-13" title="13">    <span class="dt">int</span> pipe_fds[<span class="dv">2</span>]; <span class="co">/* see `man 3 pipe`: `[0]` = read end, `[1]` = write end */</span></a>
<a class="sourceLine" id="cb203-14" title="14">    pid_t pid;</a>
<a class="sourceLine" id="cb203-15" title="15">    <span class="dt">size_t</span> buf_sz = <span class="kw">sizeof</span>(from);</a>
<a class="sourceLine" id="cb203-16" title="16"></a>
<a class="sourceLine" id="cb203-17" title="17">    <span class="cf">if</span> (pipe(pipe_fds) == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb203-18" title="18">        perror(<span class="st">&quot;pipe creation&quot;</span>);</a>
<a class="sourceLine" id="cb203-19" title="19">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb203-20" title="20">    }</a>
<a class="sourceLine" id="cb203-21" title="21"></a>
<a class="sourceLine" id="cb203-22" title="22">    <span class="co">/* descriptors copied into each process during `fork`! */</span></a>
<a class="sourceLine" id="cb203-23" title="23">    pid = fork();</a>
<a class="sourceLine" id="cb203-24" title="24"></a>
<a class="sourceLine" id="cb203-25" title="25">    <span class="cf">if</span> (pid &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb203-26" title="26">        perror(<span class="st">&quot;fork error&quot;</span>);</a>
<a class="sourceLine" id="cb203-27" title="27">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb203-28" title="28">    } <span class="cf">else</span> <span class="cf">if</span> (pid == <span class="dv">0</span>) { <span class="co">/* child */</span></a>
<a class="sourceLine" id="cb203-29" title="29">        <span class="dt">ssize_t</span> ret_w;</a>
<a class="sourceLine" id="cb203-30" title="30"></a>
<a class="sourceLine" id="cb203-31" title="31">        close(pipe_fds[<span class="dv">0</span>]); <span class="co">/* we aren&#39;t reading! */</span></a>
<a class="sourceLine" id="cb203-32" title="32">        ret_w = write(pipe_fds[<span class="dv">1</span>], from, buf_sz);</a>
<a class="sourceLine" id="cb203-33" title="33">        <span class="cf">if</span> (ret_w &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb203-34" title="34">            perror(<span class="st">&quot;write to pipe&quot;</span>);</a>
<a class="sourceLine" id="cb203-35" title="35">            exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb203-36" title="36">        }</a>
<a class="sourceLine" id="cb203-37" title="37">        assert((<span class="dt">size_t</span>)ret_w == buf_sz);</a>
<a class="sourceLine" id="cb203-38" title="38">        printf(<span class="st">&quot;Child sent whole message!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb203-39" title="39">    } <span class="cf">else</span> { <span class="co">/* parent */</span></a>
<a class="sourceLine" id="cb203-40" title="40">        <span class="dt">ssize_t</span> ret_r;</a>
<a class="sourceLine" id="cb203-41" title="41">        <span class="dt">ssize_t</span> rest = buf_sz, offset = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb203-42" title="42"></a>
<a class="sourceLine" id="cb203-43" title="43">        close(pipe_fds[<span class="dv">1</span>]); <span class="co">/* we aren&#39;t writing! */</span></a>
<a class="sourceLine" id="cb203-44" title="44">        <span class="cf">while</span> (rest &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb203-45" title="45">            ret_r = read(pipe_fds[<span class="dv">0</span>], &amp;to[offset], rest);</a>
<a class="sourceLine" id="cb203-46" title="46">            <span class="cf">if</span> (ret_r &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb203-47" title="47">                perror(<span class="st">&quot;read from pipe&quot;</span>);</a>
<a class="sourceLine" id="cb203-48" title="48">                exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb203-49" title="49">            }</a>
<a class="sourceLine" id="cb203-50" title="50">            rest   -= ret_r;</a>
<a class="sourceLine" id="cb203-51" title="51">            offset += ret_r;</a>
<a class="sourceLine" id="cb203-52" title="52">        }</a>
<a class="sourceLine" id="cb203-53" title="53"></a>
<a class="sourceLine" id="cb203-54" title="54">        printf(<span class="st">&quot;Parent got the message!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb203-55" title="55">    }</a>
<a class="sourceLine" id="cb203-56" title="56"></a>
<a class="sourceLine" id="cb203-57" title="57">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb203-58" title="58">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Parent got the message!
Child sent whole message!</code></pre>
<p>The <em>concurrency</em> of the system enables separate processes to be active at the same time, thus for the <code>write</code> and <code>read</code> to be transferring data through the pipe <em>at the same time</em>. This simplifies our code as we don’t need to worry about sending chunks of our data.</p>
<p>Note that we’re <code>close</code>ing the end of the pipe that we aren’t using in the corresponding processes. Though the file descriptors are identical in each process following <code>fork</code>, each process does have a <em>separate</em> set of those descriptors. Thus closing in one, doesn’t impact the other.</p>
<p>Remember, processes provide <strong>isolation</strong>!</p>
<h3 id="the-shell"><span class="header-section-number">8.1.3</span> The Shell</h3>
<p>We can start to understand part of how to a shell might be implemented now!</p>
<p><strong>Setting up pipes.</strong> Lets start with the more obvious: for each <code>|</code> in a command, the shell will create a new <code>pipe</code>. It is a little less obvious to understand how the standard output for one process is hooked up through a <code>pipe</code> to the standard input of the next process. To do this, the shell does the following procedure:</p>
<ol type="1">
<li>Create a <code>pipe</code>.</li>
<li><code>fork</code> the processes (a <code>fork</code> for each process in a pipeline).</li>
<li>In the <em>upstream</em> process <code>close(STDOUT_FILENO)</code>, and <code>dup2</code> the writable file descriptor in the pipe into <code>STDOUT_FILENO</code>.</li>
<li>In the <em>downstream</em> process <code>close(STDIN_FILENO)</code>, and <code>dup2</code> the readable file descriptor in the pipe into <code>STDIN_FILENO</code>.</li>
</ol>
<p>Due to this <em>careful</em> usage of <code>close</code> to get rid of the old standard in/out, and <code>dup</code> or <code>dup2</code> to methodically replace it with the pipe, we can see how the shell sets up the processes in a pipeline!</p>
<p>Lets go over an example of setting up the file descriptors for a child process. This does <em>not</em> set up the pipe-based communication between <em>two children</em>, so is not sufficient for a shell; but it is well on the way. Pipes contain arbitrary streams of bytes, not just characters. This example will</p>
<ol type="1">
<li>setup the input and output of two files to communicate over a pipe, and</li>
<li>send and receive binary data between processes.</li>
</ol>
<div class="sourceCode" id="cb205"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb205-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb205-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb205-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb205-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb205-5" title="5"></a>
<a class="sourceLine" id="cb205-6" title="6"><span class="dt">void</span> perror_exit(<span class="dt">char</span> *s)</a>
<a class="sourceLine" id="cb205-7" title="7">{</a>
<a class="sourceLine" id="cb205-8" title="8">    perror(s);</a>
<a class="sourceLine" id="cb205-9" title="9">    exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb205-10" title="10">}</a>
<a class="sourceLine" id="cb205-11" title="11"></a>
<a class="sourceLine" id="cb205-12" title="12"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb205-13" title="13">{</a>
<a class="sourceLine" id="cb205-14" title="14">    <span class="dt">int</span> fds[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb205-15" title="15">    pid_t pid;</a>
<a class="sourceLine" id="cb205-16" title="16"></a>
<a class="sourceLine" id="cb205-17" title="17">    <span class="co">/* make the pipe before we fork, so we can acccess it in each process */</span></a>
<a class="sourceLine" id="cb205-18" title="18">    <span class="cf">if</span> (pipe(fds) == -<span class="dv">1</span>) perror_exit(<span class="st">&quot;Opening pipe&quot;</span>);</a>
<a class="sourceLine" id="cb205-19" title="19"></a>
<a class="sourceLine" id="cb205-20" title="20">    pid = fork();</a>
<a class="sourceLine" id="cb205-21" title="21">    <span class="cf">if</span> (pid == -<span class="dv">1</span>) perror_exit(<span class="st">&quot;Forking process&quot;</span>);</a>
<a class="sourceLine" id="cb205-22" title="22"></a>
<a class="sourceLine" id="cb205-23" title="23">    <span class="cf">if</span> (pid == <span class="dv">0</span>) {       <span class="co">/* child */</span></a>
<a class="sourceLine" id="cb205-24" title="24">        <span class="co">/* Same as above, but for standard output */</span></a>
<a class="sourceLine" id="cb205-25" title="25">        close(STDOUT_FILENO);</a>
<a class="sourceLine" id="cb205-26" title="26">        <span class="cf">if</span> (dup2(fds[<span class="dv">1</span>], STDOUT_FILENO) == -<span class="dv">1</span>) perror_exit(<span class="st">&quot;child dup stdout&quot;</span>);</a>
<a class="sourceLine" id="cb205-27" title="27"></a>
<a class="sourceLine" id="cb205-28" title="28">        close(fds[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb205-29" title="29">        close(fds[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb205-30" title="30"></a>
<a class="sourceLine" id="cb205-31" title="31">        printf(<span class="st">&quot;%d %c %x&quot;</span>, <span class="dv">42</span>, <span class="ch">&#39;+&#39;</span>, <span class="dv">42</span>);</a>
<a class="sourceLine" id="cb205-32" title="32">        fflush(stdout); <span class="co">/* make sure that we output to the stdout */</span></a>
<a class="sourceLine" id="cb205-33" title="33"></a>
<a class="sourceLine" id="cb205-34" title="34">        exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb205-35" title="35">    } <span class="cf">else</span> {              <span class="co">/* parent */</span></a>
<a class="sourceLine" id="cb205-36" title="36">        <span class="dt">int</span> a, c;</a>
<a class="sourceLine" id="cb205-37" title="37">        <span class="dt">char</span> b;</a>
<a class="sourceLine" id="cb205-38" title="38"></a>
<a class="sourceLine" id="cb205-39" title="39">        <span class="co">/* close standard in... */</span></a>
<a class="sourceLine" id="cb205-40" title="40">        close(STDIN_FILENO);</a>
<a class="sourceLine" id="cb205-41" title="41">        <span class="co">/* ...and replace it with the input side of the pipe */</span></a>
<a class="sourceLine" id="cb205-42" title="42">        <span class="cf">if</span> (dup2(fds[<span class="dv">0</span>], STDIN_FILENO) == -<span class="dv">1</span>) perror_exit(<span class="st">&quot;parent dup stdin&quot;</span>);</a>
<a class="sourceLine" id="cb205-43" title="43">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb205-44" title="44"><span class="co">         * if we don&#39;t close the pipes, the child will</span></a>
<a class="sourceLine" id="cb205-45" title="45"><span class="co">         * always wait for additional input</span></a>
<a class="sourceLine" id="cb205-46" title="46"><span class="co">         */</span></a>
<a class="sourceLine" id="cb205-47" title="47">        close(fds[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb205-48" title="48">        close(fds[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb205-49" title="49"></a>
<a class="sourceLine" id="cb205-50" title="50">        scanf(<span class="st">&quot;%d %c %x&quot;</span>, &amp;a, &amp;b, &amp;c);</a>
<a class="sourceLine" id="cb205-51" title="51"></a>
<a class="sourceLine" id="cb205-52" title="52">        printf(<span class="st">&quot;%d %c %x&quot;</span>, a, b, c);</a>
<a class="sourceLine" id="cb205-53" title="53">        <span class="cf">if</span> (wait(NULL) == -<span class="dv">1</span>) perror_exit(<span class="st">&quot;parent&#39;s wait&quot;</span>);</a>
<a class="sourceLine" id="cb205-54" title="54">    }</a>
<a class="sourceLine" id="cb205-55" title="55"></a>
<a class="sourceLine" id="cb205-56" title="56">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb205-57" title="57">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>42 + 2a</code></pre>
<p><strong>Closing pipes.</strong> <code>read</code>ing from a pipe will return that there is no more data on the pipe (i.e. return <code>0</code>) <em>only if all <code>write</code>-ends of the pipe are <code>close</code>d</em>.</p>
<p>This makes sense because we think of a pipe as a potentially infinite stream of bytes, thus the only way the system can know that there are no more bytes to be <code>read</code>, is if the <code>write</code> end of the pipe cannot receive more data, i.e. if it is <code>close</code>d.</p>
<p>This seems simple, in principle, but when implementing a shell, you use <code>dup</code> to make multiple copies of the <code>write</code> file descriptor. In this case, the shell must be very careful to close its own copies because <em>if any <code>write</code> end of a pipe is open, the reader will not realize when there is no more data left</em>. If you implement a shell, and it seems like commands are hanging, and not <code>exit</code>ing, this is likely why.</p>
<figure>
<img src="figures/pipe_proc.png" alt="A graphical sequence for the above code. Each image is a snapshot of the system after an operation is preformed. The red portions of each figure show what is changed in each operation. The parent creates a pipe, forks a child, which inherits a copy of all of the file descriptors (including the pipe), the parent and child close their stdin and stdout, respectively, the pipes descriptors are duped into those now vacant descriptors, and the pipe descriptors are closed. Now all processes are in a state where they can use their stdin/stdout/stderr descriptors as normal (scanf, printf), but the standard output from the child will get piped to the standard input of the parent. Shells do a similar set of operations, but in which a child has their standard output piped to the standard input of another child." /><figcaption>A graphical sequence for the above code. Each image is a snapshot of the system after an operation is preformed. The red portions of each figure show what is changed in each operation. The parent creates a pipe, forks a child, which inherits a copy of all of the file descriptors (including the pipe), the parent and child close their stdin and stdout, respectively, the pipes descriptors are <code>dup</code>ed into those now vacant descriptors, and the pipe descriptors are closed. Now all processes are in a state where they can use their stdin/stdout/stderr descriptors as normal (<code>scanf</code>, <code>printf</code>), but the standard output from the child will get piped to the standard input of the parent. Shells do a similar set of operations, but in which a child has their standard output piped to the standard input of another child.</figcaption>
</figure>
<p><strong>Question.</strong> If we wanted to have a parent, shell process setup two child connected by <code>|</code>, what would the <em>final</em> picture (in the image of the pictures above) look like?</p>
<h2 id="signals"><span class="header-section-number">8.2</span> Signals</h2>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/signals.html">Slides</a></p>
<p>We’re used to <em>sequential</em> execution in our processes. Each instruction executes after the previous in the “instruction stream”. However, systems also require <em>exceptional</em> execution patterns. What happens when you access memory that doesn’t exist (e.g. <code>*(int *)NULL</code>); when you divide by <code>0</code>; when a user types <code>cntl-c</code>; when a process terminates; or when you make a call to access a descriptor which somehow is not accessible outside of the call<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>?</p>
<p>Consider the following code where we try to access (dereference) address <code>NULL</code>.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb207-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb207-2" title="2"><span class="co"> * intro to signals</span></a>
<a class="sourceLine" id="cb207-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb207-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb207-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb207-6" title="6"></a>
<a class="sourceLine" id="cb207-7" title="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb207-8" title="8">{</a>
<a class="sourceLine" id="cb207-9" title="9">    <span class="co">// some standard errors</span></a>
<a class="sourceLine" id="cb207-10" title="10">    <span class="dt">int</span>* a = (<span class="dt">int</span>*)NULL ;</a>
<a class="sourceLine" id="cb207-11" title="11">    *a = <span class="dv">10</span> ;</a>
<a class="sourceLine" id="cb207-12" title="12"></a>
<a class="sourceLine" id="cb207-13" title="13">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb207-14" title="14">}</a></code></pre></div>
<p>What happens with the following code?</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb208-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb208-2" title="2"><span class="co"> * intro to signals</span></a>
<a class="sourceLine" id="cb208-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb208-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb208-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb208-6" title="6"></a>
<a class="sourceLine" id="cb208-7" title="7"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb208-8" title="8">{</a>
<a class="sourceLine" id="cb208-9" title="9">    <span class="co">// some standard errors</span></a>
<a class="sourceLine" id="cb208-10" title="10">    <span class="dt">int</span> div = <span class="dv">100</span>/<span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb208-11" title="11"></a>
<a class="sourceLine" id="cb208-12" title="12">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb208-13" title="13">}</a></code></pre></div>
<p>Programs <strong>crash</strong>! Unless you <em>plan</em> to “<strong>handle</strong>” it!</p>
<h3 id="enter-signals"><span class="header-section-number">8.2.1</span> Enter ‘<strong>signals</strong>’</h3>
<p>UNIX’s <strong>signals</strong> provide <em>asynchronous</em> execution in a process: - provide asynchronous execution - when a signal activates, - a “signal handler” function is activated - regardless of what was executing!</p>
<p>Signals can be used for, - dealing with <em>exceptions</em>, <em>e.g.,</em> - invalid access → <code>*(int *)NULL</code> - divide by <code>0</code> - tracking time → <code>ualarm</code> - parent/child coordination → <code>SIGTERM</code> - …</p>
<p>Let’s look at a basic setup for using signals:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb209-1" title="1"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span><span class="pp"> </span><span class="co">/* sigaction and SIG* */</span></a>
<a class="sourceLine" id="cb209-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb209-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb209-4" title="4"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb209-5" title="5"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb209-6" title="6"></a>
<a class="sourceLine" id="cb209-7" title="7"><span class="co">// this is the interface for the signal fault handler!</span></a>
<a class="sourceLine" id="cb209-8" title="8"><span class="dt">void</span> sig_fault_handler(<span class="dt">int</span> signal_number, siginfo_t *info, <span class="dt">void</span> *context)</a>
<a class="sourceLine" id="cb209-9" title="9">{</a>
<a class="sourceLine" id="cb209-10" title="10">    <span class="co">/* printf has problems here; see &quot;The Dark Side of Signals&quot; */</span></a>
<a class="sourceLine" id="cb209-11" title="11">    printf(<span class="st">&quot;My downfall is the forbidden fruit at address %p.</span><span class="sc">\n</span><span class="st">&quot;</span>, info-&gt;si_addr);</a>
<a class="sourceLine" id="cb209-12" title="12"></a>
<a class="sourceLine" id="cb209-13" title="13">    <span class="co">/* Question: what happens if we comment this out? */</span></a>
<a class="sourceLine" id="cb209-14" title="14">    exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb209-15" title="15"></a>
<a class="sourceLine" id="cb209-16" title="16">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb209-17" title="17">}</a>
<a class="sourceLine" id="cb209-18" title="18"></a>
<a class="sourceLine" id="cb209-19" title="19"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb209-20" title="20">{</a>
<a class="sourceLine" id="cb209-21" title="21">    sigset_t masked;</a>
<a class="sourceLine" id="cb209-22" title="22">    <span class="kw">struct</span> sigaction siginfo;</a>
<a class="sourceLine" id="cb209-23" title="23">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb209-24" title="24"></a>
<a class="sourceLine" id="cb209-25" title="25">    sigemptyset(&amp;masked);</a>
<a class="sourceLine" id="cb209-26" title="26">    sigaddset(&amp;masked, SIGSEGV);</a>
<a class="sourceLine" id="cb209-27" title="27">    siginfo = (<span class="kw">struct</span> sigaction) {</a>
<a class="sourceLine" id="cb209-28" title="28">        .sa_sigaction = sig_fault_handler,</a>
<a class="sourceLine" id="cb209-29" title="29">        .sa_mask      = masked,</a>
<a class="sourceLine" id="cb209-30" title="30">        .sa_flags     = SA_RESTART | SA_SIGINFO <span class="co">/* we&#39;ll see this later */</span></a>
<a class="sourceLine" id="cb209-31" title="31">    };</a>
<a class="sourceLine" id="cb209-32" title="32"></a>
<a class="sourceLine" id="cb209-33" title="33">    <span class="cf">if</span> (sigaction(SIGSEGV, &amp;siginfo, NULL) == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb209-34" title="34">        perror(<span class="st">&quot;sigaction error&quot;</span>);</a>
<a class="sourceLine" id="cb209-35" title="35">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb209-36" title="36">    }</a>
<a class="sourceLine" id="cb209-37" title="37"></a>
<a class="sourceLine" id="cb209-38" title="38">    printf(<span class="st">&quot;Lets live dangerously</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb209-39" title="39">    ret = *(<span class="dt">int</span> *)NULL;</a>
<a class="sourceLine" id="cb209-40" title="40">    printf(<span class="st">&quot;I live!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb209-41" title="41"></a>
<a class="sourceLine" id="cb209-42" title="42">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb209-43" title="43">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Lets live dangerously
My downfall is the forbidden fruit at address (nil).
make[1]: *** [Makefile:30: inline_exec] Error 1</code></pre>
<p>We can actually execute in the signal handler when we access invalid memory! We can write code to execute in response to a segmentation fault. This is how Java prints out a backtrace.</p>
<p>Let’s explore the concepts in the above code and the <strong>signals interface</strong> in general.</p>
<h3 id="signals-interface"><span class="header-section-number">8.2.2</span> Signals Interface</h3>
<h4 id="sigset_t"><span class="header-section-number">8.2.2.1</span> <code>sigset_t</code></h4>
<ul>
<li>a bitmap → <strong>one bit per signal</strong></li>
<li>used to program the <strong>signal mask</strong></li>
<li>filled with <code>0</code>s or <code>1</code>s</li>
</ul>
<p><img src="figures/sigset2.png" height="25"></p>
<table>
<thead>
<tr class="header">
<th>value</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="figures/sigset3.png" height="25"></td>
<td>signals <strong>can</strong> nest</td>
</tr>
<tr class="even">
<td><img src="figures/sigset4.png" height="25"></td>
<td>signals <strong>cannot</strong> nest</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Essentially….<code>sigset_t</code> tells us…when a signal executes, - can <em>others</em> occur? - if so, <em>which ones</em>?</p>
<h4 id="sigset_t-functions"><span class="header-section-number">8.2.2.2</span> <code>sigset_t</code> functions</h4>
<p>Defined in <code>&lt;signal.h&gt;</code> to manage the <code>sigset_t</code> data structure. |name|function| |—-|——–| |<code>sigemptyset</code>| initialize/empty the signal set <br> <em>i.e.</em>, “unmask” all| |<code>sigfullset</code>| initializefill the signal set <br> <em>i.e.</em>, “mask” all|<br />
|<code>sigaddset</code>|add <em>specific</em> signal to set <br> <em>i.e.,</em> “mask” specific one| |<code>sigdelset</code>|remove <em>specific</em> signal from set <br> <em>i.e.,</em> “mask” specific one| |<code>sigismember</code>|checks whether given signal is <br> part of the set|</p>
<h4 id="sig_fault_handler"><span class="header-section-number">8.2.2.3</span> <code>sig_fault_handler</code></h4>
<ul>
<li>the signal <code>"handler"</code></li>
<li>function that is called <em>asynchronously</em>
<ul>
<li>when corresponding event happens</li>
</ul></li>
<li><strong>user defined</strong></li>
</ul>
<p>In the example of SIGSEGV above, here, the signal handler is called whenever we access invalid memory (e.g. segmentation fault).</p>
<h4 id="sigaction"><span class="header-section-number">8.2.2.4</span> <code>sigaction</code></h4>
<p>The function that sets up signal handler for a specific signal:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb211-1" title="1"><span class="pp">#include </span><span class="im">&quot;signal.h&quot;</span></a>
<a class="sourceLine" id="cb211-2" title="2"></a>
<a class="sourceLine" id="cb211-3" title="3"><span class="dt">int</span> sigaction( <span class="dt">int</span> signum, </a>
<a class="sourceLine" id="cb211-4" title="4">               <span class="dt">const</span> <span class="kw">struct</span> sigaction *<span class="dt">restrict</span> act, </a>
<a class="sourceLine" id="cb211-5" title="5">               <span class="kw">struct</span> sigaction *<span class="dt">restrict</span> oldact ) ;</a></code></pre></div>
<h4 id="struct-sigaction"><span class="header-section-number">8.2.2.5</span> <code>struct sigaction</code></h4>
<div class="sourceCode" id="cb212"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb212-1" title="1"><span class="kw">struct</span> sigaction {</a>
<a class="sourceLine" id="cb212-2" title="2">            <span class="dt">void</span>     (*sa_handler)(<span class="dt">int</span>);</a>
<a class="sourceLine" id="cb212-3" title="3">            <span class="dt">void</span>     (*sa_sigaction)(<span class="dt">int</span>, siginfo_t *, <span class="dt">void</span> *);</a>
<a class="sourceLine" id="cb212-4" title="4">            sigset_t   sa_mask;</a>
<a class="sourceLine" id="cb212-5" title="5">            <span class="dt">int</span>        sa_flags;</a>
<a class="sourceLine" id="cb212-6" title="6">            <span class="dt">void</span>     (*sa_restorer)(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb212-7" title="7">} ;</a></code></pre></div>
<h4 id="sequence-of-actions"><span class="header-section-number">8.2.2.6</span> Sequence of Actions</h4>
<p>…for using signals</p>
<p><img src="figures/signal_handler9.png" height="300"></p>
<h3 id="notable-signals"><span class="header-section-number">8.2.3</span> Notable Signals</h3>
<p>There are signals for quite a few events. A list of all of the signals is listed in <code>man 7 signal</code> and <code>glibc</code> has decent <a href="https://www.gnu.org/software/libc/manual/html_node/Signal-Handling.html">documentation</a>. Notable signals include: |signal| description | |——–|——–| |<code>SIGCHILD</code> | child process terminated | |<code>SIGINT</code> | user typed <code>ctrl-c</code> | |<code>SIGSTOP/SIGCONT</code> | stop/continue child execution | |<code>SIGTSTP</code> | user typed <code>ctrl-z</code> | |<code>SIGTPIPE</code> | write to a pipe with no reader | |<code>SIGSEGV</code> | invalid memory access [segmentation fault] | |<code>SIGTERM/SIGKILL</code> | kill a process; SIGTERM can be caught, <strong>SIGKILL</strong> not | |<code>SIGHUP</code> | kill terminal that created shell | |<code>SIGALRM</code> | notification that time has passed | |<code>SIGUSR1/SIGUSR2</code> | <strong>user-defined</strong> signal handlers | ||</p>
<p><strong>Note:</strong> <code>SIGKILL/SIGTOP</code> - cannot be “caught” - to deal with unresponsive processes - SIGCONT → continue process after SIGSTOP</p>
<p>Each signal has a <em>default behavior</em> that triggers if you do not define a handler. These are: * ignore * terminate process * stop process from executing * continue execution</p>
<h3 id="minor-detour-sa_sigaction"><span class="header-section-number">8.2.4</span> Minor Detour | <code>sa_sigaction</code></h3>
<p>We have seen (and used) this struct:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb213-1" title="1"><span class="kw">struct</span> sigaction {</a>
<a class="sourceLine" id="cb213-2" title="2">    <span class="dt">void</span>     (*sa_handler)(<span class="dt">int</span>);</a>
<a class="sourceLine" id="cb213-3" title="3">    <span class="dt">void</span>     (*sa_sigaction)(<span class="dt">int</span>, siginfo_t *, <span class="dt">void</span> *);</a>
<a class="sourceLine" id="cb213-4" title="4">    sigset_t   sa_mask;</a>
<a class="sourceLine" id="cb213-5" title="5">    <span class="dt">int</span>        sa_flags;</a>
<a class="sourceLine" id="cb213-6" title="6">    <span class="dt">void</span>     (*sa_restorer)(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb213-7" title="7">};</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c:3:35: error: unknown type name siginfo_t
    3 |     void     (*sa_sigaction)(int, siginfo_t *, void *);
      |                                   ^~~~~~~~~
inline_exec_tmp.c:4:5: error: expected ; before sigset_t
    4 |     sigset_t   sa_mask;
      |     ^~~~~~~~
make[1]: *** [Makefile:33: inline_exec_tmp] Error 1</code></pre>
<p>Why <strong>two</strong> function pointers? - <code>(*sa_handler)</code> - <code>(*sa_sigaction)</code></p>
<p>One takes <strong>more information</strong> than the other</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb215-1" title="1"><span class="dt">void</span>     (*sa_handler)(<span class="dt">int</span>);`</a>
<a class="sourceLine" id="cb215-2" title="2"><span class="dt">void</span>     (*sa_sigaction)(<span class="dt">int</span>, siginfo_t *, <span class="dt">void</span> *);</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c:1:29: error: stray ` in program
    1 | void     (*sa_handler)(int);`
      |                             ^
inline_exec_tmp.c:2:31: error: unknown type name siginfo_t
    2 | void     (*sa_sigaction)(int, siginfo_t *, void *);
      |                               ^~~~~~~~~
make[1]: *** [Makefile:33: inline_exec_tmp] Error 1</code></pre>
<p>choice of which → depends on a <strong>flag</strong> that is set.</p>
<h4 id="flags"><span class="header-section-number">8.2.4.1</span> Flags?</h4>
<p>Provide flags to <code>sa_flags</code> member:</p>
<table>
<thead>
<tr class="header">
<th>flag</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SA_SIGINFO</code></td>
<td>use the <code>*sa_sigaction</code> handler (<em>i.e.,</em> take more information)</td>
</tr>
<tr class="even">
<td><code>SA_RESTART</code></td>
<td>make sure system calls are ‘<em>restartable</em>’</td>
</tr>
<tr class="odd">
<td>(many others)</td>
<td>…</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>man 2 sigaction</code> for more details.</p>
<h3 id="signals-further-examples"><span class="header-section-number">8.2.5</span> Signals | Further Examples</h3>
<h4 id="tracking-time-with-signals"><span class="header-section-number">8.2.5.1</span> Tracking Time with Signals</h4>
<p>Now let’s use another signal, <code>SIGALRM</code>. Use the following code example:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb217-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb217-2" title="2"><span class="co"> * intro to signals</span></a>
<a class="sourceLine" id="cb217-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb217-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb217-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb217-6" title="6"></a>
<a class="sourceLine" id="cb217-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb217-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb217-9" title="9"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb217-10" title="10"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb217-11" title="11"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb217-12" title="12"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb217-13" title="13"></a>
<a class="sourceLine" id="cb217-14" title="14"><span class="co">// why volatile?</span></a>
<a class="sourceLine" id="cb217-15" title="15"><span class="dt">volatile</span> <span class="dt">int</span> timers = <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb217-16" title="16"></a>
<a class="sourceLine" id="cb217-17" title="17"><span class="co">// the signal hanlder</span></a>
<a class="sourceLine" id="cb217-18" title="18"><span class="dt">void</span> my_timer_handler( <span class="dt">int</span> signal_number, siginfo_t* info,</a>
<a class="sourceLine" id="cb217-19" title="19">                                            <span class="dt">void</span>* context )</a>
<a class="sourceLine" id="cb217-20" title="20">{</a>
<a class="sourceLine" id="cb217-21" title="21">    <span class="co">// Handler for SIGALRM</span></a>
<a class="sourceLine" id="cb217-22" title="22"></a>
<a class="sourceLine" id="cb217-23" title="23">    printf( <span class="st">&quot;Inside Alarm Handler!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb217-24" title="24"></a>
<a class="sourceLine" id="cb217-25" title="25">    ++timers ;</a>
<a class="sourceLine" id="cb217-26" title="26">    <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb217-27" title="27">}</a>
<a class="sourceLine" id="cb217-28" title="28"></a>
<a class="sourceLine" id="cb217-29" title="29"><span class="co">// the function pointer for the signal handler type</span></a>
<a class="sourceLine" id="cb217-30" title="30"><span class="kw">typedef</span> <span class="dt">void</span>(*signal_handler_function)( <span class="dt">int</span>, siginfo_t*, <span class="dt">void</span>* ) ;</a>
<a class="sourceLine" id="cb217-31" title="31"></a>
<a class="sourceLine" id="cb217-32" title="32"><span class="co">// We can use a function to set up the signal, </span></a>
<a class="sourceLine" id="cb217-33" title="33"><span class="co">// hide all the sigset, sigaction stuff using this</span></a>
<a class="sourceLine" id="cb217-34" title="34"><span class="co">// EXPLAIN this function</span></a>
<a class="sourceLine" id="cb217-35" title="35"><span class="dt">void</span> setup_signal( <span class="dt">int</span> signal_number, </a>
<a class="sourceLine" id="cb217-36" title="36">                   signal_handler_function func,</a>
<a class="sourceLine" id="cb217-37" title="37">                   <span class="dt">int</span> sa_flags )</a>
<a class="sourceLine" id="cb217-38" title="38">{</a>
<a class="sourceLine" id="cb217-39" title="39">    sigset_t masked ; <span class="co">// bitmask</span></a>
<a class="sourceLine" id="cb217-40" title="40">    sigemptyset( &amp;masked ) ; <span class="co">// clear the mask</span></a>
<a class="sourceLine" id="cb217-41" title="41">    sigaddset( &amp;masked, signal_number ) ; <span class="co">// set only bit for SIGSEGV</span></a>
<a class="sourceLine" id="cb217-42" title="42">    <span class="kw">struct</span> sigaction siginfo = (<span class="kw">struct</span> sigaction){</a>
<a class="sourceLine" id="cb217-43" title="43">        .sa_sigaction = func,</a>
<a class="sourceLine" id="cb217-44" title="44">        .sa_mask = &amp;masked,</a>
<a class="sourceLine" id="cb217-45" title="45">        .sa_flags = sa_flags </a>
<a class="sourceLine" id="cb217-46" title="46">    } ; </a>
<a class="sourceLine" id="cb217-47" title="47"></a>
<a class="sourceLine" id="cb217-48" title="48">    <span class="cf">if</span>( sigaction( signal_number, &amp;siginfo, NULL ) == -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb217-49" title="49">    {</a>
<a class="sourceLine" id="cb217-50" title="50">        perror( <span class="st">&quot;sigaction failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb217-51" title="51">        exit(EXIT_FAILURE) ;</a>
<a class="sourceLine" id="cb217-52" title="52">    }</a>
<a class="sourceLine" id="cb217-53" title="53">}</a>
<a class="sourceLine" id="cb217-54" title="54"></a>
<a class="sourceLine" id="cb217-55" title="55"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb217-56" title="56">{</a>
<a class="sourceLine" id="cb217-57" title="57">    <span class="dt">int</span> t = timers ;</a>
<a class="sourceLine" id="cb217-58" title="58">    setup_signal( SIGALRM, my_timer_handler, (SA_RESTART | SA_SIGINFO) ) ;</a>
<a class="sourceLine" id="cb217-59" title="59"></a>
<a class="sourceLine" id="cb217-60" title="60">    pid_t pid ;</a>
<a class="sourceLine" id="cb217-61" title="61"></a>
<a class="sourceLine" id="cb217-62" title="62">    <span class="cf">if</span>( (pid = fork()) == <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb217-63" title="63">    {</a>
<a class="sourceLine" id="cb217-64" title="64">        <span class="co">// Child process</span></a>
<a class="sourceLine" id="cb217-65" title="65">        pause() ;</a>
<a class="sourceLine" id="cb217-66" title="66">        exit( EXIT_SUCCESS ) ;</a>
<a class="sourceLine" id="cb217-67" title="67">    }</a>
<a class="sourceLine" id="cb217-68" title="68"></a>
<a class="sourceLine" id="cb217-69" title="69">    <span class="co">// We did setup_signal BEFORE fork(). Parent/child both get signal info!</span></a>
<a class="sourceLine" id="cb217-70" title="70">    </a>
<a class="sourceLine" id="cb217-71" title="71">    ualarm( <span class="dv">1000</span>, <span class="dv">1000</span> ) ; <span class="co">// 1000 us --&gt; 1 ms</span></a>
<a class="sourceLine" id="cb217-72" title="72">    <span class="co">// alarm(1) ; // same as previous ualarm? SHOW BOTH!</span></a>
<a class="sourceLine" id="cb217-73" title="73"></a>
<a class="sourceLine" id="cb217-74" title="74">    <span class="cf">while</span> (t &lt; <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb217-75" title="75">    {</a>
<a class="sourceLine" id="cb217-76" title="76">        <span class="cf">if</span>( timers &gt; t )</a>
<a class="sourceLine" id="cb217-77" title="77">        {</a>
<a class="sourceLine" id="cb217-78" title="78">            printf( <span class="st">&quot;Count: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, t ) ;</a>
<a class="sourceLine" id="cb217-79" title="79">            t = timers ;</a>
<a class="sourceLine" id="cb217-80" title="80">        }</a>
<a class="sourceLine" id="cb217-81" title="81">    }</a>
<a class="sourceLine" id="cb217-82" title="82"></a>
<a class="sourceLine" id="cb217-83" title="83">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb217-84" title="84">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb217-85" title="85">}</a></code></pre></div>
<p>*Question**: Track and explain the control flow through this program.</p>
<p><code>SIGKILL</code> and <code>SIGSTOP</code> are unique in that they <em>cannot be disabled</em>, and handlers for them cannot be defined. They enable non-optional control of a child by the parent.</p>
<h4 id="parentchild-coordination-with-signals"><span class="header-section-number">8.2.5.2</span> Parent/Child Coordination with Signals</h4>
<p>Another example of coordination between parent and child processes. We can use signals to get a notification that <em>a child has exited</em>! Additionally, we can send the <code>SIGTERM</code> signal to terminate a process (this is used to implement the <code>kill</code> command line program – see <code>man 1 kill</code>).</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb218-1" title="1"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb218-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb218-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb218-4" title="4"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb218-5" title="5"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb218-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span><span class="pp"> </span><span class="co">/* kill, pause */</span></a>
<a class="sourceLine" id="cb218-7" title="7"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb218-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb218-9" title="9"></a>
<a class="sourceLine" id="cb218-10" title="10"><span class="dt">void</span> sig_handler(<span class="dt">int</span> signal_number, siginfo_t *info, <span class="dt">void</span> *context)</a>
<a class="sourceLine" id="cb218-11" title="11">{</a>
<a class="sourceLine" id="cb218-12" title="12">    <span class="cf">switch</span>(signal_number) {</a>
<a class="sourceLine" id="cb218-13" title="13">    <span class="cf">case</span> SIGCHLD: {</a>
<a class="sourceLine" id="cb218-14" title="14">        <span class="co">/* see documentation on `siginfo_t` in `man sigaction` */</span></a>
<a class="sourceLine" id="cb218-15" title="15">        printf(<span class="st">&quot;%d: Child process %d has exited.</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid(), info-&gt;si_pid);</a>
<a class="sourceLine" id="cb218-16" title="16">        fflush(stdout);</a>
<a class="sourceLine" id="cb218-17" title="17">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb218-18" title="18">    }</a>
<a class="sourceLine" id="cb218-19" title="19">    <span class="cf">case</span> SIGTERM: {</a>
<a class="sourceLine" id="cb218-20" title="20">        printf(<span class="st">&quot;%d: We&#39;ve been asked to terminate. Exit!</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid());</a>
<a class="sourceLine" id="cb218-21" title="21">        fflush(stdout);</a>
<a class="sourceLine" id="cb218-22" title="22">        exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb218-23" title="23">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb218-24" title="24">    }}</a>
<a class="sourceLine" id="cb218-25" title="25"></a>
<a class="sourceLine" id="cb218-26" title="26">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb218-27" title="27">}</a>
<a class="sourceLine" id="cb218-28" title="28"></a>
<a class="sourceLine" id="cb218-29" title="29"><span class="dt">void</span> setup_signal(<span class="dt">int</span> signo, <span class="dt">void</span> (*fn)(<span class="dt">int</span> , siginfo_t *, <span class="dt">void</span> *))</a>
<a class="sourceLine" id="cb218-30" title="30">{</a>
<a class="sourceLine" id="cb218-31" title="31">    sigset_t masked;</a>
<a class="sourceLine" id="cb218-32" title="32">    <span class="kw">struct</span> sigaction siginfo;</a>
<a class="sourceLine" id="cb218-33" title="33">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb218-34" title="34"></a>
<a class="sourceLine" id="cb218-35" title="35">    sigemptyset(&amp;masked);</a>
<a class="sourceLine" id="cb218-36" title="36">    sigaddset(&amp;masked, signo);</a>
<a class="sourceLine" id="cb218-37" title="37">    siginfo = (<span class="kw">struct</span> sigaction) {</a>
<a class="sourceLine" id="cb218-38" title="38">        .sa_sigaction = fn,</a>
<a class="sourceLine" id="cb218-39" title="39">        .sa_mask      = masked,</a>
<a class="sourceLine" id="cb218-40" title="40">        .sa_flags     = SA_RESTART | SA_SIGINFO</a>
<a class="sourceLine" id="cb218-41" title="41">    };</a>
<a class="sourceLine" id="cb218-42" title="42"></a>
<a class="sourceLine" id="cb218-43" title="43">    <span class="cf">if</span> (sigaction(signo, &amp;siginfo, NULL) == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb218-44" title="44">        perror(<span class="st">&quot;sigaction error&quot;</span>);</a>
<a class="sourceLine" id="cb218-45" title="45">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb218-46" title="46">    }</a>
<a class="sourceLine" id="cb218-47" title="47">}</a>
<a class="sourceLine" id="cb218-48" title="48"></a>
<a class="sourceLine" id="cb218-49" title="49"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb218-50" title="50">{</a>
<a class="sourceLine" id="cb218-51" title="51">    pid_t pid;</a>
<a class="sourceLine" id="cb218-52" title="52">    <span class="dt">int</span> status;</a>
<a class="sourceLine" id="cb218-53" title="53"></a>
<a class="sourceLine" id="cb218-54" title="54">    setup_signal(SIGCHLD, sig_handler);</a>
<a class="sourceLine" id="cb218-55" title="55">    setup_signal(SIGTERM, sig_handler);</a>
<a class="sourceLine" id="cb218-56" title="56"></a>
<a class="sourceLine" id="cb218-57" title="57">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb218-58" title="58"><span class="co">     * The signal infromation is inherited across a fork,</span></a>
<a class="sourceLine" id="cb218-59" title="59"><span class="co">     * and is set the same for the parent and the child.</span></a>
<a class="sourceLine" id="cb218-60" title="60"><span class="co">     */</span></a>
<a class="sourceLine" id="cb218-61" title="61">    pid = fork();</a>
<a class="sourceLine" id="cb218-62" title="62">    <span class="cf">if</span> (pid == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb218-63" title="63">        perror(<span class="st">&quot;fork&quot;</span>);</a>
<a class="sourceLine" id="cb218-64" title="64">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb218-65" title="65">    }</a>
<a class="sourceLine" id="cb218-66" title="66"></a>
<a class="sourceLine" id="cb218-67" title="67">    <span class="cf">if</span> (pid == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb218-68" title="68">        pause(); <span class="co">/* stop execution, wake upon signal */</span></a>
<a class="sourceLine" id="cb218-69" title="69"></a>
<a class="sourceLine" id="cb218-70" title="70">        exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb218-71" title="71">    }</a>
<a class="sourceLine" id="cb218-72" title="72"></a>
<a class="sourceLine" id="cb218-73" title="73">    printf(<span class="st">&quot;%d: Parent asking child (%d) to terminate</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid(), pid);</a>
<a class="sourceLine" id="cb218-74" title="74">    kill(pid, SIGTERM); <span class="co">/* send the child the TERM signal */</span></a>
<a class="sourceLine" id="cb218-75" title="75"></a>
<a class="sourceLine" id="cb218-76" title="76">    <span class="co">/* Wait for the sigchild notification of child termination! */</span></a>
<a class="sourceLine" id="cb218-77" title="77">    pause();</a>
<a class="sourceLine" id="cb218-78" title="78"></a>
<a class="sourceLine" id="cb218-79" title="79">    <span class="co">/* this should return immediately because waited for sigchld! */</span></a>
<a class="sourceLine" id="cb218-80" title="80">    assert(pid == wait(&amp;status));</a>
<a class="sourceLine" id="cb218-81" title="81">    assert(WIFEXITED(status));</a>
<a class="sourceLine" id="cb218-82" title="82"></a>
<a class="sourceLine" id="cb218-83" title="83">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb218-84" title="84">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>3498761: We&#39;ve been asked to terminate. Exit!
3498760: Parent asking child (3498761) to terminate
3498760: Child process 3498761 has exited.</code></pre>
<p><em>Note:</em> You want to run this a few times on your system to see the output. The auto-execution scripts of the lectures might cause wonky effects here due to concurrency.</p>
<p>We now see a couple of new features:</p>
<ul>
<li>The <code>SIGCHLD</code> signal is activated in the parent when a child process exits.</li>
<li>We can use the <code>kill</code> function to <em>send a signal</em> to a another process owned by the same user (e.g. <code>gparmer</code>).</li>
<li>The <code>pause</code> call says to stop execution (to pause) until a signal is triggered.</li>
</ul>
<figure>
<img src="./figures/sig_chld.png" alt="A high-level overview of the control flow between parent and child in this code." /><figcaption>A high-level overview of the control flow between parent and child in this code.</figcaption>
</figure>
<p>A couple of additional important functions:</p>
<ul>
<li><code>raise</code> will trigger a signal in the current process (it is effectively a <code>kill(getpid(), ...)</code>).</li>
<li><code>ualarm</code> will set a recurring <code>SIGALRM</code> signal. This can be quite useful if your program needs to keep track of time in some way.</li>
</ul>
<h3 id="the-dark-side-of-signals"><span class="header-section-number">8.2.6</span> The Dark Side of Signals</h3>
<p><img src="figures/dark_side_vader.jpg" height="300"></p>
<p>Signals are dangerous mechanisms in some situations. It can be difficult to use them properly, and avoid bugs. Signals complication data-structures as only functionality that is re-eentrant should be used in signal handlers, and they complicate the logic around all system calls as they can interrupt slow system calls.</p>
<p><strong>Two</strong> main problems: 1. problems with “slow” system calls 2. only “reentrant” data structures</p>
<h4 id="slow-system-calls"><span class="header-section-number">8.2.6.1</span> “Slow” System Calls</h4>
<ul>
<li>many library calls can <em>block</em>
<ul>
<li><em>e.g.</em>, <code>wait</code> or <code>read</code></li>
</ul></li>
<li>what if → signal sent <em>when blocked?</em></li>
<li>default → sys call will <strong>return immediately</strong></li>
<li><code>wait</code> → returns even if child didn’t <code>exit</code></li>
<li><code>read</code> → returns despite <strong>not</strong> reading data!</li>
</ul>
<p>So how do you tell the difference between the blocking function returning properly, or returning because it was interrupted by a signal? The answer is, of course, in the man pages – look at the <strong>return</strong>/<code>errno</code> values: - function will return <code>-1</code> - errno will be set to <code>EINTR</code></p>
<p>Given this, we see the problem with this design: now the programmer must add logic for <em>every single system call</em> that can block to check this condition. Yikes<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>.</p>
<p>Luckily, UNIX provides a means to disable the interruption of blocking calls by setting the <code>SA_RESTART</code> flag to the <code>sa_flags</code> field of the <code>sigaction</code> struct passed to the <code>sigaction</code> call.</p>
<p><strong>Note:</strong> that the code above already sets this as I consider it a default requirement if you’re setting up signal handlers.</p>
<p>The use of <code>SA_RESTART</code> can have interesting side effects, especially for <strong>slow</strong> system calls! Lets see the explicit interaction with between the slow call <code>wait</code>, and the signal handler:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb220-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb220-2" title="2"><span class="co"> * intro to signals</span></a>
<a class="sourceLine" id="cb220-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb220-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb220-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb220-6" title="6"></a>
<a class="sourceLine" id="cb220-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb220-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb220-9" title="9"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb220-10" title="10"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb220-11" title="11"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb220-12" title="12"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb220-13" title="13"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb220-14" title="14"></a>
<a class="sourceLine" id="cb220-15" title="15"><span class="dt">void</span> my_timer_handler( <span class="dt">int</span> signal_number, siginfo_t* info,</a>
<a class="sourceLine" id="cb220-16" title="16">                                            <span class="dt">void</span>* context )</a>
<a class="sourceLine" id="cb220-17" title="17">{</a>
<a class="sourceLine" id="cb220-18" title="18">    <span class="co">// Handler for SIGALRM</span></a>
<a class="sourceLine" id="cb220-19" title="19"></a>
<a class="sourceLine" id="cb220-20" title="20">    printf( <span class="st">&quot;Inside Alarm Handler!</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb220-21" title="21"></a>
<a class="sourceLine" id="cb220-22" title="22">    <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb220-23" title="23">}</a>
<a class="sourceLine" id="cb220-24" title="24"></a>
<a class="sourceLine" id="cb220-25" title="25"><span class="co">// the function pointer for the signal handler type</span></a>
<a class="sourceLine" id="cb220-26" title="26"><span class="kw">typedef</span> <span class="dt">void</span>(*signal_handler_function)( <span class="dt">int</span>, siginfo_t*, <span class="dt">void</span>* ) ;</a>
<a class="sourceLine" id="cb220-27" title="27"></a>
<a class="sourceLine" id="cb220-28" title="28"><span class="co">// We can use a function to set up the signal, </span></a>
<a class="sourceLine" id="cb220-29" title="29"><span class="co">// hide all the sigset, sigaction stuff using this</span></a>
<a class="sourceLine" id="cb220-30" title="30"><span class="dt">void</span> setup_signal( <span class="dt">int</span> signal_number, </a>
<a class="sourceLine" id="cb220-31" title="31">                   signal_handler_function func,</a>
<a class="sourceLine" id="cb220-32" title="32">                   <span class="dt">int</span> sa_flags )</a>
<a class="sourceLine" id="cb220-33" title="33">{</a>
<a class="sourceLine" id="cb220-34" title="34">    sigset_t masked ; <span class="co">// bitmask</span></a>
<a class="sourceLine" id="cb220-35" title="35">    sigemptyset( &amp;masked ) ; <span class="co">// clear the mask</span></a>
<a class="sourceLine" id="cb220-36" title="36">    sigaddset( &amp;masked, signal_number ) ; <span class="co">// set only bit for given signal</span></a>
<a class="sourceLine" id="cb220-37" title="37">    <span class="kw">struct</span> sigaction siginfo = (<span class="kw">struct</span> sigaction){</a>
<a class="sourceLine" id="cb220-38" title="38">        .sa_sigaction = func,</a>
<a class="sourceLine" id="cb220-39" title="39">        .sa_mask = &amp;masked,</a>
<a class="sourceLine" id="cb220-40" title="40">        .sa_flags = sa_flags </a>
<a class="sourceLine" id="cb220-41" title="41">    } ; </a>
<a class="sourceLine" id="cb220-42" title="42"></a>
<a class="sourceLine" id="cb220-43" title="43">    <span class="cf">if</span>( sigaction( signal_number, &amp;siginfo, NULL ) == -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb220-44" title="44">    {</a>
<a class="sourceLine" id="cb220-45" title="45">        perror( <span class="st">&quot;sigaction failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb220-46" title="46">        exit(EXIT_FAILURE) ;</a>
<a class="sourceLine" id="cb220-47" title="47">    }</a>
<a class="sourceLine" id="cb220-48" title="48">}</a>
<a class="sourceLine" id="cb220-49" title="49"></a>
<a class="sourceLine" id="cb220-50" title="50"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb220-51" title="51">{</a>
<a class="sourceLine" id="cb220-52" title="52"></a>
<a class="sourceLine" id="cb220-53" title="53">    <span class="co">// comment out one or the other of this to see the different behaviors</span></a>
<a class="sourceLine" id="cb220-54" title="54">    setup_signal( SIGALRM, my_timer_handler, (SA_SIGINFO) ) ;</a>
<a class="sourceLine" id="cb220-55" title="55">    <span class="co">// setup_signal( SIGALRM, my_timer_handler, (SA_RESTART | SA_SIGINFO) ) ;</span></a>
<a class="sourceLine" id="cb220-56" title="56"></a>
<a class="sourceLine" id="cb220-57" title="57">    pid_t pid ;</a>
<a class="sourceLine" id="cb220-58" title="58"></a>
<a class="sourceLine" id="cb220-59" title="59">    <span class="cf">if</span>( (pid = fork()) == <span class="dv">0</span> )</a>
<a class="sourceLine" id="cb220-60" title="60">    {</a>
<a class="sourceLine" id="cb220-61" title="61">        <span class="co">// Child process</span></a>
<a class="sourceLine" id="cb220-62" title="62">        pause() ; <span class="co">// wait for a signal</span></a>
<a class="sourceLine" id="cb220-63" title="63">        exit( EXIT_SUCCESS ) ;</a>
<a class="sourceLine" id="cb220-64" title="64">    }</a>
<a class="sourceLine" id="cb220-65" title="65"></a>
<a class="sourceLine" id="cb220-66" title="66">    alarm(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb220-67" title="67"></a>
<a class="sourceLine" id="cb220-68" title="68">    <span class="cf">while</span> (<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb220-69" title="69">    {</a>
<a class="sourceLine" id="cb220-70" title="70">        pid_t ret = wait(NULL) ;</a>
<a class="sourceLine" id="cb220-71" title="71"></a>
<a class="sourceLine" id="cb220-72" title="72">        <span class="cf">if</span>( ret == -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb220-73" title="73">        {</a>
<a class="sourceLine" id="cb220-74" title="74">            <span class="cf">if</span>( errno == EINTR )</a>
<a class="sourceLine" id="cb220-75" title="75">            {</a>
<a class="sourceLine" id="cb220-76" title="76">                <span class="co">// Child didn&#39;t exit properly</span></a>
<a class="sourceLine" id="cb220-77" title="77"></a>
<a class="sourceLine" id="cb220-78" title="78">                printf( <span class="st">&quot;System call interrupted by Signal</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb220-79" title="79">                kill( pid, SIGTERM ) ; <span class="co">// end the child process</span></a>
<a class="sourceLine" id="cb220-80" title="80"></a>
<a class="sourceLine" id="cb220-81" title="81">                <span class="co">// return -1 ;</span></a>
<a class="sourceLine" id="cb220-82" title="82">            }</a>
<a class="sourceLine" id="cb220-83" title="83">            <span class="cf">else</span> <span class="cf">if</span>( errno == ECHILD )</a>
<a class="sourceLine" id="cb220-84" title="84">            {</a>
<a class="sourceLine" id="cb220-85" title="85">                <span class="co">// this code may NEVER execute!</span></a>
<a class="sourceLine" id="cb220-86" title="86">                printf( <span class="st">&quot;Child exited cleanly</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb220-87" title="87">                <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb220-88" title="88">            }</a>
<a class="sourceLine" id="cb220-89" title="89">        }</a>
<a class="sourceLine" id="cb220-90" title="90">    }</a>
<a class="sourceLine" id="cb220-91" title="91"></a>
<a class="sourceLine" id="cb220-92" title="92">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb220-93" title="93">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb220-94" title="94">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c: In function setup_signal:
inline_exec_tmp.c:39:20: warning: initialization of long unsigned int from sigset_t * {aka struct &lt;anonymous&gt; *} makes integer from pointer without a cast [-Wint-conversion]
   39 |         .sa_mask = &amp;masked,
      |                    ^
inline_exec_tmp.c:39:20: note: (near initialization for (anonymous).sa_mask.__val[0])
inline_exec_tmp.c:37:32: warning: missing braces around initializer [-Wmissing-braces]
   37 |     struct sigaction siginfo = (struct sigaction){
      |                                ^
   38 |         .sa_sigaction = func,
      |                             }
   39 |         .sa_mask = &amp;masked,
      |                    {{     }}
inline_exec_tmp.c: In function main:
inline_exec_tmp.c:70:21: warning: implicit declaration of function wait [-Wimplicit-function-declaration]
   70 |         pid_t ret = wait(NULL) ;
      |                     ^~~~
Inside Alarm Handler!
System call interrupted by Signal
Child exited cleanly</code></pre>
<p>Comment out one of the other of the <code>setup_signal</code> function calls in <code>main()</code> to see very different behaviors.</p>
<h4 id="re-entrant-computations"><span class="header-section-number">8.2.6.2</span> Re-entrant Computations</h4>
<p>Signal handlers execute by interrupting the currently executing instructions, regardless what computations they are performing. Because we don’t really know anything about what was executing when a signal handler started, we have to an issue. What if an action in the signal handler in some way <strong>conflicts with the action it interrupted</strong>?</p>
<p>Consider <code>printf</code>, - copies data into a buffer - calls <code>write</code> → send buffer to standard output - a signal raised between the two? - signal calls printf!</p>
<p>The data written by the earlier <code>printf()</code> will be overwritten/discarded by the later one!</p>
<p>Any function that has these issues is called <a href="https://www.gnu.org/software/libc/manual/html_node/Nonreentrancy.html"><strong>non-reentrant</strong></a>. Yikes.</p>
<p>Consider the following example that overwrites <code>errno</code> with (potentially) disastrous effects!</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb222-1" title="1"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb222-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb222-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb222-4" title="4"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb222-5" title="5"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb222-6" title="6"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb222-7" title="7"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb222-8" title="8"></a>
<a class="sourceLine" id="cb222-9" title="9"><span class="dt">void</span> sig_handler(<span class="dt">int</span> signal_number, siginfo_t *info, <span class="dt">void</span> *context)</a>
<a class="sourceLine" id="cb222-10" title="10">{</a>
<a class="sourceLine" id="cb222-11" title="11">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb222-12" title="12"><span class="co">     * Reset `errno`! In a real program, this might instead be a call that causes</span></a>
<a class="sourceLine" id="cb222-13" title="13"><span class="co">     * an error setting `errno` to whatever the error is for *that call*.</span></a>
<a class="sourceLine" id="cb222-14" title="14"><span class="co">     */</span></a>
<a class="sourceLine" id="cb222-15" title="15">    errno = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb222-16" title="16"></a>
<a class="sourceLine" id="cb222-17" title="17">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb222-18" title="18">}</a>
<a class="sourceLine" id="cb222-19" title="19"></a>
<a class="sourceLine" id="cb222-20" title="20"><span class="dt">void</span> setup_signal(<span class="dt">int</span> signo)</a>
<a class="sourceLine" id="cb222-21" title="21">{</a>
<a class="sourceLine" id="cb222-22" title="22">    sigset_t masked;</a>
<a class="sourceLine" id="cb222-23" title="23">    <span class="kw">struct</span> sigaction siginfo;</a>
<a class="sourceLine" id="cb222-24" title="24">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb222-25" title="25"></a>
<a class="sourceLine" id="cb222-26" title="26">    sigemptyset(&amp;masked);</a>
<a class="sourceLine" id="cb222-27" title="27">    sigaddset(&amp;masked, signo);</a>
<a class="sourceLine" id="cb222-28" title="28">    siginfo = (<span class="kw">struct</span> sigaction) {</a>
<a class="sourceLine" id="cb222-29" title="29">        .sa_sigaction = sig_handler,</a>
<a class="sourceLine" id="cb222-30" title="30">        .sa_mask      = masked,</a>
<a class="sourceLine" id="cb222-31" title="31">        .sa_flags     = SA_RESTART | SA_SIGINFO</a>
<a class="sourceLine" id="cb222-32" title="32">    };</a>
<a class="sourceLine" id="cb222-33" title="33"></a>
<a class="sourceLine" id="cb222-34" title="34">    <span class="cf">if</span> (sigaction(signo, &amp;siginfo, NULL) == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb222-35" title="35">        perror(<span class="st">&quot;sigaction error&quot;</span>);</a>
<a class="sourceLine" id="cb222-36" title="36">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb222-37" title="37">    }</a>
<a class="sourceLine" id="cb222-38" title="38">}</a>
<a class="sourceLine" id="cb222-39" title="39"></a>
<a class="sourceLine" id="cb222-40" title="40"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb222-41" title="41">{</a>
<a class="sourceLine" id="cb222-42" title="42">    setup_signal(SIGUSR1);</a>
<a class="sourceLine" id="cb222-43" title="43"></a>
<a class="sourceLine" id="cb222-44" title="44">    assert(read(<span class="dv">400</span>, <span class="st">&quot;not going to work&quot;</span>, <span class="dv">10</span>) == -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb222-45" title="45">    raise(SIGUSR1);</a>
<a class="sourceLine" id="cb222-46" title="46">    printf(<span class="st">&quot;errno should be </span><span class="sc">\&quot;</span><span class="st">Bad file descriptor</span><span class="sc">\&quot;</span><span class="st">, but has value </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;\n</span><span class="st">&quot;</span>, strerror(errno));</a>
<a class="sourceLine" id="cb222-47" title="47"></a>
<a class="sourceLine" id="cb222-48" title="48">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb222-49" title="49">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>errno should be &quot;Bad file descriptor&quot;, but has value &quot;Success&quot;</code></pre>
<p>The set of functions you <em>can</em> call in a signal handler (i.e. that are <em>re-entrant</em>) are listed in the manual page: <code>man 7 signal-safety</code>.</p>
<p>Notably these do <em>not</em> include the likes of - <code>printf</code>/<code>snprintf</code> - <code>malloc</code> - <code>exit</code> (though <code>_exit</code> is fine) - functions that set <code>errno</code>! - …</p>
<p>It is hard to do much in a program of any complexity without <code>snprintf</code> (called by <code>printf</code>), <code>malloc</code>, or use <code>errno</code>. A very common modern way to handle this situation is to create a <code>pipe</code> into which the signal handlers <code>write</code> a notification (e.g. the signal number), while the main flow execution <code>read</code>s from the pipe. This enables the main execution in our programs to handle these notifications. However, this is only really possible and feasible when we get to <code>poll</code> later, and can block waiting for any of a number of file descriptors, including this pipe.</p>
<p>Note that in <em>most</em> cases, you won’t see a bug due to using non-re-entrant functions in your signal handlers. These bugs are heavily non-deterministic, and are dependent on exactly what instructions were interrupted when the signal activated. This may feel like a good thing: buggy behavior is very rare! But reality is opposite: rare, non-deterministic bugs become <em>very very hard to debug and test</em>. Worse, these bugs that pass your testing are more likely to happen in customer’s systems that might have different concurrency patterns. So it is nearly impossible to debug/test for these bugs, and they are more likely to cause problems in your customer’s environment. Again, yikes.</p>
<h1 id="files-and-file-handling"><span class="header-section-number">9</span> Files and File Handling</h1>
<p><a href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/files.html">Slides</a></p>
<p>The filesystem is one of the core abstractions on UNIX systems and indeed, on modern OSes. Each file is identified by a <em>path</em> through directories.</p>
<p>Remember the UNIX philosophy: <strong>everything</strong> is a file!</p>
<p>This is a strange statement as it raises the question “what wouldn’t normally be a file?” Some examples:</p>
<table>
<thead>
<tr class="header">
<th>location</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/proc/*</code></td>
<td>processes</td>
</tr>
<tr class="even">
<td><code>/dev/*</code></td>
<td>devices (hard disk, keyboards,…)</td>
</tr>
<tr class="odd">
<td><code>/dev/random</code></td>
<td>random values</td>
</tr>
<tr class="even">
<td><code>/sys/*</code></td>
<td>power settings</td>
</tr>
<tr class="odd">
<td><code>/dev/null</code></td>
<td>“nothing”</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong></p>
<ul>
<li>We know of processes as executable instances of programs so certainly they cannot be files, right? We’ve seen that they are represented by files in <code>/proc/*</code>! These files are used to provide “task monitor” type functionality (showing running processes) and <code>gdb</code>.</li>
<li>Devices are the physical parts of our computers like screens, keyboards, USB devices, hard-drives, and networks. They are all represented by files in <code>/dev/*</code>! You can actually <code>cat</code> a file directly to your disk<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>!</li>
<li>Want random values? <code>/dev/random</code>.</li>
<li>Want the complete absence of anything? <code>/dev/null</code><a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>.</li>
<li>Want to update your power settings? There are files in <code>/sys/*</code> for that.</li>
</ul>
<p>Remember the high-level directory structure of modern Linux:</p>
<p><img src="figures/linux-dir.png" height="200"></p>
<h2 id="basic-file-access"><span class="header-section-number">9.1</span> Basic File Access</h2>
<p>When everything is a file, it can all be manipulated and accessed using the exactly same functions and APIs as the normal files in the system, <em>e.g.,</em> <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code>, <em>etc.</em></p>
<p>This means that all of the shell programs we’ve seen can be used not just to operate on files, but also <em>on processes</em> or <em>devices</em>!</p>
<p>Here are the basic APIs for file operations:</p>
<ol type="1">
<li><code>open( path, flags, ... )</code>
<ul>
<li>open a file → identified by `path</cb></li>
<li>return → <code>file descriptor</code> → to access file</li>
</ul></li>
</ol>
<p>“flags” must be one of</p>
<ul>
<li><code>O_RDONLY</code> → only <strong>read</strong> from the file</li>
<li><code>O_WRONLY</code> → only <strong>write</strong> from the file</li>
<li><code>O_CREAT</code> → <strong>create</strong> the file if it doesn’t exist</li>
<li>can use bitwise OR: <code>O_RDONLY | O_CREAT</code></li>
</ul>
<p>When using O_CREAT → pass the third arg, “mode”:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb224-1" title="1">open(<span class="st">&quot;my_file_name.txt&quot;</span>, O_RDWR | O_CREAT, <span class="bn">0700</span>)</a></code></pre></div>
<p>Whenever you see “flags”, you should think of them as a set of bits, and each of the options as a single bit. The above example will create the file, <code>my_file_name.txt</code> if it doesn’t exist already and open it for reading and writing.</p>
<p>Note that when you pass in <code>O_CREAT</code>, you should pass in the third argument, the <code>mode</code> (for now, just always pass in <code>0700</code>!).</p>
<ol start="2" type="1">
<li><code>read</code>, <code>write</code>
<ul>
<li>generic functions for
<ul>
<li>getting data from,</li>
<li>sending data to,</li>
</ul></li>
<li>“descriptors” → <strong>file descriptors</strong> in this case.</li>
</ul></li>
</ol>
<p>We’ve seen them before when using pipes!</p>
<ol start="3" type="1">
<li><code>close</code>
<ul>
<li>to “close” any descriptor</li>
<li>akin to a <code>free</code> for descriptors</li>
</ul></li>
<li><code>stat</code>
<ul>
<li>get information about file pointed by <code>path</code></li>
<li>into the <code>info</code> structure</li>
<li><code>int stat(path, struct stat *info)</code></li>
<li><code>fstat</code> → same, but uses <code>fd</code></li>
</ul></li>
</ol>
<div class="sourceCode" id="cb225"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb225-1" title="1">    <span class="kw">struct</span> stat { </a>
<a class="sourceLine" id="cb225-2" title="2">    dev_t    st_dev;    <span class="co">/* device inode resides on */</span></a>
<a class="sourceLine" id="cb225-3" title="3">    ino_t    st_ino;    <span class="co">/* inode&#39;s number */</span></a>
<a class="sourceLine" id="cb225-4" title="4">    mode_t   st_mode;   <span class="co">/* inode protection mode */</span></a>
<a class="sourceLine" id="cb225-5" title="5">    nlink_t  st_nlink;  <span class="co">/* number of hard links to the file */</span></a>
<a class="sourceLine" id="cb225-6" title="6">    uid_t    st_uid;    <span class="co">/* user-id of owner */</span></a>
<a class="sourceLine" id="cb225-7" title="7">    gid_t    st_gid;    <span class="co">/* group-id of owner */</span></a>
<a class="sourceLine" id="cb225-8" title="8">    dev_t    st_rdev;   <span class="co">/* device type, for special file inode */</span></a>
<a class="sourceLine" id="cb225-9" title="9">    <span class="kw">struct</span> timespec st_atimespec;  <span class="co">/* time of last access */</span></a>
<a class="sourceLine" id="cb225-10" title="10">    <span class="kw">struct</span> timespec st_mtimespec;  <span class="co">/* time of last data modification */</span></a>
<a class="sourceLine" id="cb225-11" title="11">    <span class="kw">struct</span> timespec st_ctimespec;  <span class="co">/* time of last file status change */</span></a>
<a class="sourceLine" id="cb225-12" title="12">    off_t    st_size;   <span class="co">/* file size, in bytes */</span></a>
<a class="sourceLine" id="cb225-13" title="13">    quad_t   st_blocks; <span class="co">/* blocks allocated for file */</span></a>
<a class="sourceLine" id="cb225-14" title="14">    u_long   st_blksize;<span class="co">/* optimal file sys I/O ops blocksize */</span></a>
<a class="sourceLine" id="cb225-15" title="15">    u_long   st_flags;  <span class="co">/* user defined flags for file */</span></a>
<a class="sourceLine" id="cb225-16" title="16">    u_long   st_gen;    <span class="co">/* file generation number */</span></a>
<a class="sourceLine" id="cb225-17" title="17">};</a></code></pre></div>
<p>The structure is documented in the <code>man</code> page, but it includes, for example, the file size. It is defined in <code>&lt;sys/stat.h&gt;</code>.</p>
<ol start="5" type="1">
<li><code>unlink()</code>
<ul>
<li>try and <strong>remove</strong> a file</li>
<li><em>e.g.,</em> called by the <code>rm</code> program</li>
</ul></li>
</ol>
<blockquote>
<p>It is <em>really</em> important that quite a few interesting functions operate on <em>descriptors</em>, which might reference pipes, files, the terminal, or other resources. This means that processes can operate on descriptors and not care what resources back them. This enables shells to implement pipelines and the redirection of output to files, all without the processes knowing! It enables <code>fork</code>ed processes to inherit these resources from its parent. In this way, descriptors and the functions to operate on them are a <em>polymorphic</em> foundation (in the sense of object-oriented polymorphism) to accessing the system.</p>
</blockquote>
<p>Now, let’s look at an example of basic file operations:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb226-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb226-2" title="2"><span class="co"> * intro to reading and writing on files</span></a>
<a class="sourceLine" id="cb226-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb226-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb226-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb226-6" title="6"></a>
<a class="sourceLine" id="cb226-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb226-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb226-9" title="9"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb226-10" title="10"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb226-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb226-12" title="12"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb226-13" title="13"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb226-14" title="14"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb226-15" title="15"></a>
<a class="sourceLine" id="cb226-16" title="16"><span class="pp">#define TWEET_LEN 280</span></a>
<a class="sourceLine" id="cb226-17" title="17"></a>
<a class="sourceLine" id="cb226-18" title="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb226-19" title="19">{</a>
<a class="sourceLine" id="cb226-20" title="20">    <span class="dt">char</span> tweet[TWEET_LEN] ;</a>
<a class="sourceLine" id="cb226-21" title="21">    <span class="dt">int</span> fd = open( <span class="st">&quot;./daffodils.txt&quot;</span>, O_RDONLY ) ;</a>
<a class="sourceLine" id="cb226-22" title="22">    <span class="cf">if</span>( fd == -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb226-23" title="23">    {</a>
<a class="sourceLine" id="cb226-24" title="24">        perror( <span class="st">&quot;File daffodils.txt failed to open!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb226-25" title="25">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb226-26" title="26">    }</a>
<a class="sourceLine" id="cb226-27" title="27"></a>
<a class="sourceLine" id="cb226-28" title="28">    <span class="co">// what is the size of the file?</span></a>
<a class="sourceLine" id="cb226-29" title="29">    <span class="kw">struct</span> stat file_info ;</a>
<a class="sourceLine" id="cb226-30" title="30">    <span class="dt">int</span> ret = fstat( fd, &amp;file_info ) ;</a>
<a class="sourceLine" id="cb226-31" title="31">    assert( ret &gt;=<span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb226-32" title="32">    printf( <span class="st">&quot;Number of characters in file: %ld</span><span class="sc">\n</span><span class="st">&quot;</span>, file_info.st_size ) ;</a>
<a class="sourceLine" id="cb226-33" title="33">    </a>
<a class="sourceLine" id="cb226-34" title="34">    <span class="co">// Read TWEET_LEN number of characters from file</span></a>
<a class="sourceLine" id="cb226-35" title="35">    ret = read( fd, tweet, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb226-36" title="36">    assert( ret == TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb226-37" title="37">    write( STDOUT_FILENO, tweet, TWEET_LEN  ) ;</a>
<a class="sourceLine" id="cb226-38" title="38"></a>
<a class="sourceLine" id="cb226-39" title="39">    ret = read( fd, tweet, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb226-40" title="40">    assert( ret == TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb226-41" title="41">    write( STDOUT_FILENO, tweet, TWEET_LEN  ) ;</a>
<a class="sourceLine" id="cb226-42" title="42"></a>
<a class="sourceLine" id="cb226-43" title="43">    close(fd) ; <span class="co">// close the file.</span></a>
<a class="sourceLine" id="cb226-44" title="44"></a>
<a class="sourceLine" id="cb226-45" title="45">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb226-46" title="46">}</a></code></pre></div>
<h2 id="moving-around-in-files"><span class="header-section-number">9.2</span> Moving Around in Files</h2>
<p>We see something a little strange with files as compared to <code>pipe</code>s.</p>
<p><strong>Files vs Pipes</strong>:</p>
<table>
<thead>
<tr class="header">
<th>files</th>
<th>pipes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>finite size</td>
<td>potentially “infinite”</td>
</tr>
<tr class="even">
<td>data is permanent</td>
<td>temporary → only until read</td>
</tr>
<tr class="odd">
<td><strong>forward/backward</strong></td>
<td>no movement (FIFO)</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>For files, subsequent reads and writes must progress through the contents of the file, but we must also to be able to go back and read previously read data.</p>
<p>Lets understand what happens when we <code>read</code> or <code>write</code> from a file – we’ll focus only on <code>read</code> to start, but both behave similarly.</p>
<p>First, each <code>fd</code><a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a> tracks an “<strong>offset</strong>” - offset determines <em>where</em> we read/write in file</p>
<p>Lets go through an example of a file that contains the alphabet:</p>
<p>For freshly opened files → <code>offset = 0</code></p>
<p><img src="figures/file_offset1.png" height="100"> <br> <br></p>
<p>A <code>read(fd, buf, 10)</code> that returns <code>10</code> (saying that <code>10</code> bytes or characters <code>a</code> through <code>j</code> was successfully read) advances <code>offset</code> by <code>10</code>. <br> <br> <img src="figures/file_offset2.png" height="100"> <br> <br> Thus, an additional read will start reading from the file at <code>k</code>. The offset, then, enables subsequent reads to iterate through a file’s contents.</p>
<p><code>write()</code> uses the offset identically.</p>
<p>There are many cases in which we might want to modify the <code>offset</code>. For example, databases want to jump around a file to find exactly the interesting records, playing audio and video requires us to skip around a file finding the appropriate frames. So, we use:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb227-1" title="1">off_t lseek(<span class="dt">int</span> fd, off_t update, <span class="dt">int</span> whence)</a></code></pre></div>
<p>“<strong>whence</strong>”?</p>
<p><img src="figures/shakespeare.gif" height="200"></p>
<p><strong>how</strong> to update the <code>offset</code></p>
<table>
<thead>
<tr class="header">
<th>value</th>
<th>how updated</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>SEEK_SET</code></td>
<td><code>offset = update</code></td>
</tr>
<tr class="even">
<td><code>SEEK_CUR</code></td>
<td><code>offset += update</code></td>
</tr>
<tr class="odd">
<td><code>SEEK_END</code></td>
<td><code>offset = eof + update</code></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><code>eof</code> → end of file</p>
<p>Let’s update our previous example to use <code>lseek()</code> to reset to the start of the file.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb228-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb228-2" title="2"><span class="co"> * intro to reading and writing on files</span></a>
<a class="sourceLine" id="cb228-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb228-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb228-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb228-6" title="6"></a>
<a class="sourceLine" id="cb228-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb228-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb228-9" title="9"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb228-10" title="10"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb228-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb228-12" title="12"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb228-13" title="13"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb228-14" title="14"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb228-15" title="15"></a>
<a class="sourceLine" id="cb228-16" title="16"><span class="pp">#define TWEET_LEN 280</span></a>
<a class="sourceLine" id="cb228-17" title="17"></a>
<a class="sourceLine" id="cb228-18" title="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb228-19" title="19">{</a>
<a class="sourceLine" id="cb228-20" title="20">    <span class="dt">char</span> tweet[TWEET_LEN] ;</a>
<a class="sourceLine" id="cb228-21" title="21">    <span class="dt">int</span> fd = open( <span class="st">&quot;./daffodils.txt&quot;</span>, O_RDONLY ) ;</a>
<a class="sourceLine" id="cb228-22" title="22">    <span class="cf">if</span>( fd == -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb228-23" title="23">    {</a>
<a class="sourceLine" id="cb228-24" title="24">        perror( <span class="st">&quot;File daffodils.txt failed to open!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb228-25" title="25">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb228-26" title="26">    }</a>
<a class="sourceLine" id="cb228-27" title="27"></a>
<a class="sourceLine" id="cb228-28" title="28">    <span class="co">// what is the size of the file?</span></a>
<a class="sourceLine" id="cb228-29" title="29">    <span class="kw">struct</span> stat file_info ;</a>
<a class="sourceLine" id="cb228-30" title="30">    <span class="dt">int</span> ret = fstat( fd, &amp;file_info ) ;</a>
<a class="sourceLine" id="cb228-31" title="31">    assert( ret &gt;=<span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb228-32" title="32">    printf( <span class="st">&quot;Number of characters in file: %ld</span><span class="sc">\n</span><span class="st">&quot;</span>, file_info.st_size ) ;</a>
<a class="sourceLine" id="cb228-33" title="33">    </a>
<a class="sourceLine" id="cb228-34" title="34">    <span class="co">// Read TWEET_LEN number of characters from file</span></a>
<a class="sourceLine" id="cb228-35" title="35">    ret = read( fd, tweet, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb228-36" title="36">    assert( ret == TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb228-37" title="37">    write( STDOUT_FILENO, tweet, TWEET_LEN  ) ;</a>
<a class="sourceLine" id="cb228-38" title="38"></a>
<a class="sourceLine" id="cb228-39" title="39">    ret = read( fd, tweet, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb228-40" title="40">    assert( ret == TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb228-41" title="41">    write( STDOUT_FILENO, tweet, TWEET_LEN  ) ;</a>
<a class="sourceLine" id="cb228-42" title="42"></a>
<a class="sourceLine" id="cb228-43" title="43">    <span class="co">// Reset to the start of the file</span></a>
<a class="sourceLine" id="cb228-44" title="44">    ret = lseek( fd, <span class="dv">0</span>, SEEK_SET ) ;</a>
<a class="sourceLine" id="cb228-45" title="45">    <span class="cf">if</span>( ret == -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb228-46" title="46">    {</a>
<a class="sourceLine" id="cb228-47" title="47">        perror( <span class="st">&quot;lseek failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb228-48" title="48">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb228-49" title="49">    } </a>
<a class="sourceLine" id="cb228-50" title="50"></a>
<a class="sourceLine" id="cb228-51" title="51">    printf( <span class="st">&quot;</span><span class="sc">\n\n</span><span class="st"> ------ AFTER LSEEK ---------</span><span class="sc">\n\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb228-52" title="52">    <span class="co">// Read TWEEDT_LEN number of characters from file</span></a>
<a class="sourceLine" id="cb228-53" title="53">    ret = read( fd, tweet, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb228-54" title="54">    assert( ret == TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb228-55" title="55">    write( STDOUT_FILENO, tweet, TWEET_LEN  ) ;</a>
<a class="sourceLine" id="cb228-56" title="56"></a>
<a class="sourceLine" id="cb228-57" title="57">    close(fd) ; <span class="co">// close the file.</span></a>
<a class="sourceLine" id="cb228-58" title="58"></a>
<a class="sourceLine" id="cb228-59" title="59">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb228-60" title="60">}</a></code></pre></div>
<h2 id="other-ways-to-access-files"><span class="header-section-number">9.3</span> Other Ways to Access Files</h2>
<p>So far,</p>
<ul>
<li><code>read</code> &amp; <code>write</code> are fine interfaces for files</li>
<li>require many interactions with multiple calls</li>
</ul>
<p>There are <em>two</em> additional methods to access files:</p>
<ul>
<li><strong>memory mapping</strong></li>
<li><strong>streams</strong></li>
</ul>
<h3 id="memory-mapping-files-mmap"><span class="header-section-number">9.3.1</span> Memory Mapping Files | <code>mmap()</code></h3>
<p>UNIX also provides a way to directly “map” a file into a process, enabling to appear directly in memory, thus be accessible using normal memory accesses.</p>
<p>This is cool because your changes <em>in memory</em> update the file directly!</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb229-1" title="1"><span class="dt">void</span> *mmap(addr, len, prot, flags, fd, offset)</a></code></pre></div>
<p>defined in <code>&lt;sys/mman.h&gt;</code>.</p>
<h4 id="mmap-arguments"><span class="header-section-number">9.3.1.1</span> <code>mmap</code> arguments:</h4>
<table>
<thead>
<tr class="header">
<th>arg</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fd</code></td>
<td>file descriptor to map to memory</td>
</tr>
<tr class="even">
<td><code>addr</code></td>
<td>address in memory to map</td>
</tr>
<tr class="odd">
<td><code>len</code></td>
<td>how much of the file to map?</td>
</tr>
<tr class="even">
<td><code>prot</code></td>
<td><code>PROT_READ</code> or <code>PROT_WRITE</code></td>
</tr>
<tr class="odd">
<td><code>flags</code></td>
<td>type of mapped object <code>MAP_PRIVATE</code></td>
</tr>
<tr class="even">
<td><code>offset</code></td>
<td>where in the file to start the mapping</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>return value</strong> is the <strong>address</strong> at which the file is mapped.</p>
<p>Overview:</p>
<p><img src="figures/mmap6.png" height="300"></p>
<p>Some nuances:</p>
<ol type="1">
<li>The <code>flags</code> argument indicates the <em>type</em> of mapped object:</li>
</ol>
<table>
<thead>
<tr class="header">
<th>flag</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>MAP_PRIVATE</code></td>
<td>changes <strong>not</strong> written to file</td>
</tr>
<tr class="even">
<td><code>MAP_SHARED</code></td>
<td>changes <strong>written to</strong> file</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>So, if you want you changes to be reflected in the actual file, then make sure you set the flag as: <code>MAP_SHARED</code>.</p>
<p>Look at <code>man mmap</code> for more details on the <code>prot</code> and <code>flags</code> options.</p>
<ol start="2" type="1">
<li><p>Normally, <code>addr</code>, the address in memory at which you want to map, is <code>NULL</code>, which means “please map it whereever you want”. The <em>return value</em> is the address at which the file is mapped, or <code>NULL</code> if there was an error (see the <code>man</code> page and <code>errno</code> values).</p></li>
<li><p><code>stat</code> is quite useful to find the file’s size if you want to map it all in.</p></li>
<li><p><code>prot</code> enables you to choose some properties for the mapping, <em>e.g.</em>, <code>PROT_READ</code>, and <code>PROT_WRITE</code> that ask the system to map the memory in readable, or writable modes respectively (you can choose both with <code>PROT_READ | PROT_WRITE</code>). <strong>Note:</strong> the type of accesses here must <em>match</em> request accesses previously requested in <code>open</code> – for example, if we passed <code>O_RDONLY</code> in to <code>open</code>, <code>mmap</code> will return an error if we ask for <code>PROT_WRITE</code>.</p></li>
</ol>
<h4 id="munmap"><span class="header-section-number">9.3.1.2</span> <code>munmap()</code></h4>
<ul>
<li><strong>unmap</strong> a previously mapped file</li>
<li>deletes “mapping” for <strong>specified address range</strong></li>
</ul>
<div class="sourceCode" id="cb230"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb230-1" title="1"><span class="dt">int</span> munmap(<span class="dt">void</span> *addr, <span class="dt">size_t</span> len);</a></code></pre></div>
<p><br></p>
<p>Consider the following code:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb231-1" title="1"><span class="co">/* CSC 2410 Code Sample </span></a>
<a class="sourceLine" id="cb231-2" title="2"><span class="co"> * accessing files using mmap()</span></a>
<a class="sourceLine" id="cb231-3" title="3"><span class="co"> * Fall 2023</span></a>
<a class="sourceLine" id="cb231-4" title="4"><span class="co"> * (c) Sibin Mohan</span></a>
<a class="sourceLine" id="cb231-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb231-6" title="6"></a>
<a class="sourceLine" id="cb231-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb231-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb231-9" title="9"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb231-10" title="10"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb231-11" title="11"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb231-12" title="12"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb231-13" title="13"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb231-14" title="14"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb231-15" title="15"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb231-16" title="16"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb231-17" title="17"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb231-18" title="18"></a>
<a class="sourceLine" id="cb231-19" title="19"><span class="pp">#define TWEET_LEN 280</span></a>
<a class="sourceLine" id="cb231-20" title="20"><span class="pp">#define NUM_TWEETS 2</span></a>
<a class="sourceLine" id="cb231-21" title="21"></a>
<a class="sourceLine" id="cb231-22" title="22"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb231-23" title="23">{</a>
<a class="sourceLine" id="cb231-24" title="24">    <span class="dt">int</span> fd = open( <span class="st">&quot;./daffodils.txt&quot;</span>, O_RDONLY ) ;</a>
<a class="sourceLine" id="cb231-25" title="25">    <span class="co">// int fd = open( &quot;./daffodils.txt&quot;, O_RDWR ) ;</span></a>
<a class="sourceLine" id="cb231-26" title="26">    <span class="cf">if</span>( fd == -<span class="dv">1</span> )</a>
<a class="sourceLine" id="cb231-27" title="27">    {</a>
<a class="sourceLine" id="cb231-28" title="28">        perror( <span class="st">&quot;File daffodils.txt failed to open!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb231-29" title="29">        exit(EXIT_FAILURE) ;</a>
<a class="sourceLine" id="cb231-30" title="30">    }</a>
<a class="sourceLine" id="cb231-31" title="31"></a>
<a class="sourceLine" id="cb231-32" title="32">    <span class="co">// char* addr = mmap( NULL, TWEET_LEN, ( PROT_READ | PROT_WRITE ), MAP_SHARED, fd, 0 ) ;</span></a>
<a class="sourceLine" id="cb231-33" title="33">    <span class="dt">char</span>* addr = mmap( NULL, TWEET_LEN, ( PROT_READ | PROT_WRITE ), MAP_PRIVATE, fd, <span class="dv">0</span> ) ;</a>
<a class="sourceLine" id="cb231-34" title="34">    <span class="cf">if</span>( addr == NULL )</a>
<a class="sourceLine" id="cb231-35" title="35">    {</a>
<a class="sourceLine" id="cb231-36" title="36">        perror( <span class="st">&quot;nmmap failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb231-37" title="37">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb231-38" title="38">    }</a>
<a class="sourceLine" id="cb231-39" title="39"></a>
<a class="sourceLine" id="cb231-40" title="40">    <span class="co">// write out a tweet length </span></a>
<a class="sourceLine" id="cb231-41" title="41">    write( STDOUT_FILENO, addr, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb231-42" title="42"></a>
<a class="sourceLine" id="cb231-43" title="43">    <span class="co">// change the case of &quot;by&quot; to &quot;BY&quot;</span></a>
<a class="sourceLine" id="cb231-44" title="44">    <span class="dt">char</span>* by = strstr( addr, <span class="st">&quot;by&quot;</span> ) ;</a>
<a class="sourceLine" id="cb231-45" title="45">    assert(by) ;</a>
<a class="sourceLine" id="cb231-46" title="46">    by[<span class="dv">0</span>] = <span class="ch">&#39;B&#39;</span> ;</a>
<a class="sourceLine" id="cb231-47" title="47">    by[<span class="dv">1</span>] = <span class="ch">&#39;Y&#39;</span> ;</a>
<a class="sourceLine" id="cb231-48" title="48"></a>
<a class="sourceLine" id="cb231-49" title="49">    <span class="co">// printf( &quot;%c %c\n&quot;, by[0], by[1] ) ;</span></a>
<a class="sourceLine" id="cb231-50" title="50"></a>
<a class="sourceLine" id="cb231-51" title="51">    <span class="co">// write out a tweet length </span></a>
<a class="sourceLine" id="cb231-52" title="52">    write( STDOUT_FILENO, addr, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb231-53" title="53"></a>
<a class="sourceLine" id="cb231-54" title="54">    munmap( addr, TWEET_LEN ) ;</a>
<a class="sourceLine" id="cb231-55" title="55">    close(fd) ;</a>
<a class="sourceLine" id="cb231-56" title="56"></a>
<a class="sourceLine" id="cb231-57" title="57">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb231-58" title="58">    <span class="cf">return</span> <span class="dv">0</span> ;</a>
<a class="sourceLine" id="cb231-59" title="59">}</a></code></pre></div>
<p><strong>Note:</strong></p>
<ol type="1">
<li>will the above code work?</li>
<li>will the file reflect the changes?</li>
<li>what happens if the following line is uncommented (and the other, corresponding line is commented out?)</li>
</ol>
<div class="sourceCode" id="cb232"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb232-1" title="1"><span class="dt">char</span>* addr = mmap( NULL, TWEET_LEN, ( PROT_READ | PROT_WRITE ), MAP_SHARED, fd, <span class="dv">0</span> ) ;</a></code></pre></div>
<ol start="4" type="1">
<li>how will you fix the (inevitable) problem that occurs?</li>
</ol>
<h4 id="mmap-and-memory-allocation"><span class="header-section-number">9.3.1.3</span> <code>mmap</code> and memory allocation</h4>
<ul>
<li>can use mmap to <strong>allocate memory</strong>!</li>
<li><code>fd = 0</code></li>
<li><code>prot = PROT_READ | PROT_WRITE</code></li>
<li><code>flags = MAP_ANONYMOUS | MAP_PRIVATE</code></li>
<li>mmap returns → <strong>newly allocated memory</strong></li>
<li><code>malloc()</code> actually calls <code>mmap</code>!</li>
</ul>
<h3 id="stream-based-io"><span class="header-section-number">9.3.2</span> Stream-Based I/O</h3>
<p>There is actually a <em>third</em> way to access files beyond “raw” <code>read</code>/<code>write</code> and <code>mmap</code> – streams! <a href="https://www.gnu.org/software/libc/manual/html_node/I_002fO-on-Streams.html">Streams</a> are an abstraction <em>on top of the</em> “raw” descriptor accesses using <code>read</code> and <code>write</code>.</p>
<p>Streams:</p>
<ul>
<li>a <strong>sequence</strong> of characters</li>
<li>includes functions to
<ul>
<li>put characters in one end</li>
<li>take characters out on one end</li>
</ul></li>
</ul>
<p>Streams are identified by the type <code>FILE *</code>, and all the APIs for operating on streams take <code>FILE</code>s instead of file descriptors.</p>
<p>We’ve seen streams before…a lot!</p>
<ul>
<li><code>stdin</code>, <code>stdout</code>, <code>stderr</code></li>
<li><code>FILE*</code> names</li>
<li><code>STDOUT_FILENO</code>, <code>STDIN_FILENO</code> and <code>STDERR_FILENO</code></li>
<li><code>printf()</code> writes to a stream! Hence, it is <strong>buffered I/O</strong></li>
</ul>
<blockquote>
<p><strong>Why use Streams?</strong></p>
<p>From the <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Streams-and-File-Descriptors">GNU manual</a>: “<em>Streams provide a higher-level interface, layered on top of the primitive file descriptor facilities. The stream interface treats all kinds of files pretty much alike…The main advantage of using the stream interface is that the set of functions for performing actual input and output operations (as opposed to control operations) on streams is much richer and more powerful than the corresponding facilities for file descriptors. The file descriptor interface provides only simple functions for transferring blocks of characters, but the stream interface also provides powerful formatted input and output functions (<code>printf</code> and <code>scanf</code>) as well as functions for character- and line-oriented input and output.</em>”</p>
<p>There is also the issue of <strong>portability</strong>: “<em>(raw) file descriptors are not as portable as streams. You can expect any system running ISO C to support streams, but non-GNU systems may not support file descriptors at all, or may only implement a subset of the GNU functions that operate on file descriptor</em>”</p>
</blockquote>
<p><strong>file</strong> streams → opened/read/written/closed as streams</p>
<h4 id="file-stream-interface"><span class="header-section-number">9.3.2.1</span> File Stream Interface</h4>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>function</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fopen</code></td>
<td>same as <code>open</code> → but returns stream</td>
</tr>
<tr class="even">
<td><code>fclose</code></td>
<td>similar to <code>close</code> but for <code>FILE*</code></td>
</tr>
<tr class="odd">
<td><code>fread/ fwrite</code></td>
<td>similar to <code>read/ write</code></td>
</tr>
<tr class="even">
<td><code>feof</code></td>
<td>tells us if we are at <strong>end of file</strong></td>
</tr>
<tr class="odd">
<td><code>printf/fprintf</code></td>
<td>write to a stream <br> [<code>fprintf</code> to <strong>any</strong> stream not just <code>stdout</code>]</td>
</tr>
<tr class="even">
<td><code>scanf/fscanf</code></td>
<td>read from a stream <br> [<code>fscanf</code> read from <strong>any</strong> stream not just <code>stdin</code>]</td>
</tr>
<tr class="odd">
<td><code>fflush</code></td>
<td>“flush out” buffer associated with <strong>specific stream</strong></td>
</tr>
<tr class="even">
<td><code>fileno</code></td>
<td>get file descriptor, <code>fd</code>, associated with stream <code>FILE*</code></td>
</tr>
<tr class="odd">
<td><code>getline</code></td>
<td>read out <strong>one line</strong> (delineated by <code>\n</code>)</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Some notes:</p>
<ol type="1">
<li>access rights (while opening a file) that we’re asking for (reading or writing to the file), are specified in a more intuitive <code>mode</code> string, <em>e.g.</em>, <code>"r"</code> to read, <code>"r+"</code> for read/write, <em>etc.</em></li>
<li>streams provide the <code>feof</code> function that tells us if we are at the end of a file.</li>
</ol>
<p>Now, let’s look at our previous example of printing the <code>daffodils.txt</code> file in tweet lengths, this time using streams:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb233-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb233-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb233-3" title="3"></a>
<a class="sourceLine" id="cb233-4" title="4"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb233-5" title="5">{</a>
<a class="sourceLine" id="cb233-6" title="6">    <span class="co">// why do we need the +1?</span></a>
<a class="sourceLine" id="cb233-7" title="7">    <span class="dt">char</span> tweet[TWEET_LEN+<span class="dv">1</span>] ;</a>
<a class="sourceLine" id="cb233-8" title="8"></a>
<a class="sourceLine" id="cb233-9" title="9">    <span class="dt">FILE</span>* f = fopen( <span class="st">&quot;./daffodils.txt&quot;</span>, <span class="st">&quot;r&quot;</span> ) ;</a>
<a class="sourceLine" id="cb233-10" title="10">    <span class="cf">if</span>( f == NULL )</a>
<a class="sourceLine" id="cb233-11" title="11">    {</a>
<a class="sourceLine" id="cb233-12" title="12">        perror( <span class="st">&quot;File open failed!&quot;</span> ) ;</a>
<a class="sourceLine" id="cb233-13" title="13">        exit( EXIT_FAILURE ) ;</a>
<a class="sourceLine" id="cb233-14" title="14">    }</a>
<a class="sourceLine" id="cb233-15" title="15"></a>
<a class="sourceLine" id="cb233-16" title="16">    <span class="co">// read TWEET_LEN characters from the file</span></a>
<a class="sourceLine" id="cb233-17" title="17">    <span class="dt">int</span> ret = fread( tweet, TWEET_LEN, <span class="dv">1</span>, f ) ;</a>
<a class="sourceLine" id="cb233-18" title="18">    tweet[TWEET_LEN] = &#39;\<span class="dv">0</span><span class="er">&#39;</span> ;</a>
<a class="sourceLine" id="cb233-19" title="19"></a>
<a class="sourceLine" id="cb233-20" title="20">    <span class="co">// write it to stdout</span></a>
<a class="sourceLine" id="cb233-21" title="21">    fprintf( stdout, <span class="st">&quot;%s&quot;</span>, tweet ) ;</a>
<a class="sourceLine" id="cb233-22" title="22">    fflush(stdout) ;</a>
<a class="sourceLine" id="cb233-23" title="23"></a>
<a class="sourceLine" id="cb233-24" title="24">    fclose(f);</a>
<a class="sourceLine" id="cb233-25" title="25"></a>
<a class="sourceLine" id="cb233-26" title="26">    printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> ) ;</a>
<a class="sourceLine" id="cb233-27" title="27">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb233-28" title="28">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>inline_exec_tmp.c: In function main:
inline_exec_tmp.c:7:16: error: TWEET_LEN undeclared (first use in this function)
    7 |     char tweet[TWEET_LEN+1] ;
      |                ^~~~~~~~~
inline_exec_tmp.c:7:16: note: each undeclared identifier is reported only once for each function it appears in
inline_exec_tmp.c:13:9: warning: implicit declaration of function exit [-Wimplicit-function-declaration]
   13 |         exit( EXIT_FAILURE ) ;
      |         ^~~~
inline_exec_tmp.c:13:9: warning: incompatible implicit declaration of built-in function exit
inline_exec_tmp.c:3:1: note: include &lt;stdlib.h&gt; or provide a declaration of exit
    2 | #include &lt;assert.h&gt;
  +++ |+#include &lt;stdlib.h&gt;
    3 | 
inline_exec_tmp.c:13:15: error: EXIT_FAILURE undeclared (first use in this function)
   13 |         exit( EXIT_FAILURE ) ;
      |               ^~~~~~~~~~~~
make[1]: *** [Makefile:33: inline_exec_tmp] Error 1</code></pre>
<h4 id="streams-as-buffered-io"><span class="header-section-number">9.3.2.2</span> Streams as buffered I/O</h4>
<p>So it doesn’t seem like we’re getting much of use out of these streams compared to raw descriptors. Streams are an <em>optimization</em> over <code>read</code>/<code>write</code> as they <em>buffer</em> data.</p>
<p>Buffering essentially means that your <code>fwrite</code>s actually write data into a “buffer” in memory, and only when either you write out a <code>\n</code> or when the buffer gets large enough does a <code>write</code> get called to send the data to the system.</p>
<p>Why do this?</p>
<p>By buffering data in memory rather than making a <code>write</code> for each <code>fwrite</code>, we’re saving any <strong>overheads</strong> associated with each <code>write</code> (to be discussed in a couple of weeks).</p>
<p>However, this means that just because we called <code>printf</code>, doesn’t mean it will output immediately!</p>
<p>Lets see this how this works in practice:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb235-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb235-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb235-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb235-4" title="4"></a>
<a class="sourceLine" id="cb235-5" title="5"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb235-6" title="6">{</a>
<a class="sourceLine" id="cb235-7" title="7">    printf(<span class="st">&quot;hello world&quot;</span>);</a>
<a class="sourceLine" id="cb235-8" title="8">    _exit(EXIT_SUCCESS); <span class="co">/* this exits immediately without calling `atexit` functions */</span></a>
<a class="sourceLine" id="cb235-9" title="9"></a>
<a class="sourceLine" id="cb235-10" title="10">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb235-11" title="11">}</a></code></pre></div>
<p>Program output:</p>
<pre><code></code></pre>
<p>Well that’s not good!</p>
<p>The <em>buffered data</em> is copied into each process, then it is output when an <code>\n</code> is encountered.</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb237-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb237-2" title="2"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb237-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb237-4" title="4"></a>
<a class="sourceLine" id="cb237-5" title="5"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb237-6" title="6">{</a>
<a class="sourceLine" id="cb237-7" title="7">    printf(<span class="st">&quot;hello &quot;</span>);</a>
<a class="sourceLine" id="cb237-8" title="8">    write(STDOUT_FILENO, <span class="st">&quot;world &quot;</span>, <span class="dv">6</span>);</a>
<a class="sourceLine" id="cb237-9" title="9">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>); <span class="co">/* remember, streams output on \n */</span></a>
<a class="sourceLine" id="cb237-10" title="10"></a>
<a class="sourceLine" id="cb237-11" title="11">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb237-12" title="12">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>world hello </code></pre>
<p>Both <code>printf</code> and the <code>write</code> are, technically, to the standard output, but <code>printf</code> is to a <em>stream</em>. The <em>buffered</em> <code>printf</code> output is not written out immediately, thus ordering can get messed up.</p>
<p>Yikes.</p>
<p>Last example of the complexities of streams. What happens if you get a <strong>segfault!?</strong> Runtime errors can mess up expected behaviors.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb239-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb239-2" title="2"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb239-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb239-4" title="4"></a>
<a class="sourceLine" id="cb239-5" title="5"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb239-6" title="6">{</a>
<a class="sourceLine" id="cb239-7" title="7">    <span class="dt">int</span> a;</a>
<a class="sourceLine" id="cb239-8" title="8"></a>
<a class="sourceLine" id="cb239-9" title="9">    printf(<span class="st">&quot;hello &quot;</span>);</a>
<a class="sourceLine" id="cb239-10" title="10">    a = *(<span class="dt">int</span> *)NULL;</a>
<a class="sourceLine" id="cb239-11" title="11"></a>
<a class="sourceLine" id="cb239-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb239-13" title="13">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>make[1]: *** [Makefile:30: inline_exec] Segmentation fault</code></pre>
<p>Even though we fault <em>after</em> the <code>printf</code>, we don’t see the <code>printf</code>’s output!</p>
<p>We now know why: the <code>printf</code> wrote into a buffer, and <strong>didn’t yet <code>write</code> to the system</strong>! Thus the segmentation fault, that terminates the process, happens <strong>before the buffer is actually written!</strong></p>
<h4 id="flushing-stream-buffers"><span class="header-section-number">9.3.2.3</span> Flushing Stream Buffers</h4>
<p>It is imperative that streams give us some means to force the buffer to be output! Thus, streams provide a means of <em>flushing</em> the stream’s buffers, and sending them out to the system (e.g. using <code>write</code>).</p>
<ul>
<li><code>fflush</code> - flush out the buffer associated with a specific stream.</li>
</ul>
<p>Fixing the previous examples:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb241-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb241-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb241-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb241-4" title="4"></a>
<a class="sourceLine" id="cb241-5" title="5"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb241-6" title="6">{</a>
<a class="sourceLine" id="cb241-7" title="7">    printf(<span class="st">&quot;hello &quot;</span>);</a>
<a class="sourceLine" id="cb241-8" title="8">    fflush(stdout); <span class="co">// &quot;flush&quot; out the buffer to standard output</span></a>
<a class="sourceLine" id="cb241-9" title="9">    write(STDOUT_FILENO, <span class="st">&quot;world &quot;</span>, <span class="dv">6</span>);</a>
<a class="sourceLine" id="cb241-10" title="10">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>); <span class="co">/* remember, streams output on \n */</span></a>
<a class="sourceLine" id="cb241-11" title="11"></a>
<a class="sourceLine" id="cb241-12" title="12">    printf(<span class="st">&quot;hello world&quot;</span>);</a>
<a class="sourceLine" id="cb241-13" title="13">    fflush(stdout);</a>
<a class="sourceLine" id="cb241-14" title="14">    _exit(EXIT_SUCCESS); <span class="co">/* this exits immediately without calling `atexit` functions */</span></a>
<a class="sourceLine" id="cb241-15" title="15"></a>
<a class="sourceLine" id="cb241-16" title="16">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb241-17" title="17">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>hello world 
hello world</code></pre>
<div class="sourceCode" id="cb243"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb243-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb243-2" title="2"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb243-3" title="3"></a>
<a class="sourceLine" id="cb243-4" title="4"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb243-5" title="5">{</a>
<a class="sourceLine" id="cb243-6" title="6">    printf(<span class="st">&quot;hello world&quot;</span>);</a>
<a class="sourceLine" id="cb243-7" title="7">    fflush(stdout); <span class="co">// &quot;flush&quot; out the buffer to standard output</span></a>
<a class="sourceLine" id="cb243-8" title="8">    fork();</a>
<a class="sourceLine" id="cb243-9" title="9">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>); <span class="co">/* remember, streams output on \n */</span></a>
<a class="sourceLine" id="cb243-10" title="10"></a>
<a class="sourceLine" id="cb243-11" title="11">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb243-12" title="12">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>hello world
</code></pre>
<h4 id="other-useful-stream-functions"><span class="header-section-number">9.3.2.4</span> Other Useful Stream Functions</h4>
<p>A few other functions for streams that can be useful:</p>
<ul>
<li><code>fileno</code>: get the file descriptor number associated with a stream. This can be useful if you need to use an API that takes a descriptor, rather than a stream <code>* FILE</code>.</li>
<li><code>getline</code>: read out a line (delimited by a <code>\n</code>) from a stream. Since reading input, line at a time, is a pretty common thing, this is a useful function.</li>
</ul>
<div class="sourceCode" id="cb245"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb245-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb245-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb245-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb245-4" title="4"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb245-5" title="5"></a>
<a class="sourceLine" id="cb245-6" title="6"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb245-7" title="7">{</a>
<a class="sourceLine" id="cb245-8" title="8">    <span class="dt">FILE</span> *f = fopen(<span class="st">&quot;./05/prufrock.txt&quot;</span>, <span class="st">&quot;r&quot;</span>);</a>
<a class="sourceLine" id="cb245-9" title="9">    <span class="dt">size_t</span> s = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb245-10" title="10">    <span class="dt">char</span> *line = NULL;</a>
<a class="sourceLine" id="cb245-11" title="11">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb245-12" title="12"></a>
<a class="sourceLine" id="cb245-13" title="13">    assert(f);</a>
<a class="sourceLine" id="cb245-14" title="14">    printf(<span class="st">&quot;The new genre: abridged, tweet-worthy poetry...</span><span class="sc">\n\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb245-15" title="15">    <span class="cf">for</span> (i = <span class="dv">0</span>; getline(&amp;line, &amp;s, f) != -<span class="dv">1</span>; i++) {</a>
<a class="sourceLine" id="cb245-16" title="16">        <span class="cf">if</span> (i % <span class="dv">15</span> == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb245-17" title="17">            fwrite(line, <span class="dv">1</span>, strlen(line), stdout);</a>
<a class="sourceLine" id="cb245-18" title="18">            <span class="co">/* same as printf(&quot;%s&quot;, line); */</span></a>
<a class="sourceLine" id="cb245-19" title="19">        }</a>
<a class="sourceLine" id="cb245-20" title="20">    }</a>
<a class="sourceLine" id="cb245-21" title="21">    <span class="cf">if</span> (!feof(f)) {</a>
<a class="sourceLine" id="cb245-22" title="22">        perror(<span class="st">&quot;getline&quot;</span>);</a>
<a class="sourceLine" id="cb245-23" title="23">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb245-24" title="24">    }</a>
<a class="sourceLine" id="cb245-25" title="25">    free(line);</a>
<a class="sourceLine" id="cb245-26" title="26">    fclose(f);</a>
<a class="sourceLine" id="cb245-27" title="27"></a>
<a class="sourceLine" id="cb245-28" title="28">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb245-29" title="29">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>The new genre: abridged, tweet-worthy poetry...

 The Love Song of J. Alfred Prufrock
Of restless nights in one-night cheap hotels
Let fall upon its back the soot that falls from chimneys,
And for a hundred visions and revisions,
Disturb the universe?
Then how should I begin
Of lonely men in shirt-sleeves, leaning out of windows? ...
And I have seen the eternal Footman hold my coat, and snicker,

Am an attendant lord, one that will do
</code></pre>
<h2 id="accessing-directories"><span class="header-section-number">9.4</span> Accessing Directories</h2>
<p>Files aren’t the only thing we care to access in the system – what about directories! We want to be able to create directories, delete them, and be able to read their contents. These core operations are what underlies the implementation of the <code>ls</code> program, or, similarly, what happens when you double-click on a directory in a graphical file explorer!</p>
<ul>
<li><code>opendir</code>, <code>closedir</code> - Open (and close) a directory, and return a <em>directory stream</em>, a <code>DIR *</code>, to it, which is backed by a descriptor. Yes, another descriptor!</li>
<li><p><code>readdir</code> - This takes a <code>DIR *</code> to a directory, and returns a structure that includes the “current” file or directory in the directory. This includes the name of the returned object in <code>d_name</code>, and type (in the <code>d_type</code> field) which is one of:</p>
<ul>
<li><code>DT_BLK</code> - This is a block device.</li>
<li><code>DT_CHR</code> - This is a character device.</li>
<li><strong><code>DT_DIR</code> - This is a directory.</strong></li>
<li><code>DT_FIFO</code> - This is a named pipe (FIFO).</li>
<li><code>DT_LNK</code> - This is a symbolic link.</li>
<li><strong><code>DT_REG</code> - This is a regular file.</strong></li>
<li><code>DT_SOCK</code> - This is a UNIX domain socket.</li>
<li><code>DT_UNKNOWN</code> - The file type could not be determined.</li>
</ul>
The two main ones we care about are directories and files. Subsequent calls to <code>readdir</code> will return the “next” file or directory.</li>
<li><p><code>scandir</code> &amp; <code>glob</code> - Two functions that enable you to get directory contents based on some simple search patterns and logic. <code>scandir</code> lets you pass in a directory stream, and a couple of functions that are used to sort directory contents output, and filter it (enable you to say that you don’t want to look at some directory contents). <code>glob</code>, on the other hand, lets you search for “wildcards” designated by <code>*</code> to select all files/direcotries that match the string.</p></li>
</ul>
<div class="sourceCode" id="cb247"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb247-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb247-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb247-3" title="3"><span class="pp">#include </span><span class="im">&lt;dirent.h&gt;</span></a>
<a class="sourceLine" id="cb247-4" title="4"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb247-5" title="5"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb247-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb247-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb247-8" title="8"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb247-9" title="9"></a>
<a class="sourceLine" id="cb247-10" title="10"><span class="dt">long</span> file_size(<span class="dt">char</span> *dir, <span class="dt">char</span> *file);</a>
<a class="sourceLine" id="cb247-11" title="11"></a>
<a class="sourceLine" id="cb247-12" title="12"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb247-13" title="13">{</a>
<a class="sourceLine" id="cb247-14" title="14">    DIR *d = opendir(<span class="st">&quot;./05/&quot;</span>);</a>
<a class="sourceLine" id="cb247-15" title="15">    <span class="kw">struct</span> dirent *entry;</a>
<a class="sourceLine" id="cb247-16" title="16"></a>
<a class="sourceLine" id="cb247-17" title="17">    assert(d);</a>
<a class="sourceLine" id="cb247-18" title="18"></a>
<a class="sourceLine" id="cb247-19" title="19">    errno = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb247-20" title="20">    <span class="cf">while</span> ((entry = readdir(d)) != NULL) {</a>
<a class="sourceLine" id="cb247-21" title="21">        <span class="dt">char</span> *type;</a>
<a class="sourceLine" id="cb247-22" title="22"></a>
<a class="sourceLine" id="cb247-23" title="23">        <span class="cf">if</span> (entry-&gt;d_type == DT_DIR)      type = <span class="st">&quot;Directory&quot;</span>;</a>
<a class="sourceLine" id="cb247-24" title="24">        <span class="cf">else</span> <span class="cf">if</span> (entry-&gt;d_type == DT_REG) type = <span class="st">&quot;File&quot;</span>;</a>
<a class="sourceLine" id="cb247-25" title="25">        <span class="cf">else</span>                              type = <span class="st">&quot;Unknown&quot;</span>;</a>
<a class="sourceLine" id="cb247-26" title="26"></a>
<a class="sourceLine" id="cb247-27" title="27">        <span class="cf">if</span> (entry-&gt;d_type == DT_DIR || entry-&gt;d_type != DT_REG) {</a>
<a class="sourceLine" id="cb247-28" title="28">            printf(<span class="st">&quot;%10s: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, type, entry-&gt;d_name);</a>
<a class="sourceLine" id="cb247-29" title="29">        } <span class="cf">else</span> { <span class="co">/* entry-&gt;d_type == DT_REG */</span></a>
<a class="sourceLine" id="cb247-30" title="30">            printf(<span class="st">&quot;%10s: %s (size: %ld)</span><span class="sc">\n</span><span class="st">&quot;</span>, type, entry-&gt;d_name, file_size(<span class="st">&quot;05&quot;</span>, entry-&gt;d_name));</a>
<a class="sourceLine" id="cb247-31" title="31">        }</a>
<a class="sourceLine" id="cb247-32" title="32">    }</a>
<a class="sourceLine" id="cb247-33" title="33">    <span class="cf">if</span> (errno != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb247-34" title="34">        perror(<span class="st">&quot;Reading directory&quot;</span>);</a>
<a class="sourceLine" id="cb247-35" title="35">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb247-36" title="36">    }</a>
<a class="sourceLine" id="cb247-37" title="37">    closedir(d);</a>
<a class="sourceLine" id="cb247-38" title="38"></a>
<a class="sourceLine" id="cb247-39" title="39">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb247-40" title="40">}</a>
<a class="sourceLine" id="cb247-41" title="41"></a>
<a class="sourceLine" id="cb247-42" title="42"><span class="dt">long</span> file_size(<span class="dt">char</span> *dir, <span class="dt">char</span> *file)</a>
<a class="sourceLine" id="cb247-43" title="43">{</a>
<a class="sourceLine" id="cb247-44" title="44">    <span class="kw">struct</span> stat finfo;</a>
<a class="sourceLine" id="cb247-45" title="45">    <span class="dt">char</span> buf[<span class="dv">512</span>];</a>
<a class="sourceLine" id="cb247-46" title="46">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb247-47" title="47"></a>
<a class="sourceLine" id="cb247-48" title="48">    memset(buf, <span class="dv">0</span>, <span class="dv">512</span>); <span class="co">/* zero out the buffer to add &#39;\0&#39;s */</span></a>
<a class="sourceLine" id="cb247-49" title="49">    snprintf(buf, <span class="dv">512</span>, <span class="st">&quot;./%s/%s&quot;</span>, dir, file);</a>
<a class="sourceLine" id="cb247-50" title="50"></a>
<a class="sourceLine" id="cb247-51" title="51">    ret = stat(buf, &amp;finfo);</a>
<a class="sourceLine" id="cb247-52" title="52">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb247-53" title="53"></a>
<a class="sourceLine" id="cb247-54" title="54">    <span class="cf">return</span> finfo.st_size;</a>
<a class="sourceLine" id="cb247-55" title="55">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>      File: 150_01_lecture.md (size: 4245)
 Directory: ..
      File: 150_02_exercises.md (size: 2978)
      File: OLD_01_lecture copy_md (size: 21581)
      File: 14.02.files.other_methods.md (size: 11966)
      File: prufrock.txt (size: 6044)
 Directory: test_directory
      File: shelley_poems.txt (size: 283)
 Directory: figures
 Directory: .
      File: daffodils.txt (size: 869)
      File: 14.01.files.md (size: 9624)</code></pre>
<p>To make <em>changes</em> in the first system hierarchy, we need an additional set of functions.</p>
<ul>
<li><code>mkdir(path, mode)</code> - This function is used in, for example, the <code>mkdir</code> program. Don’t confuse the program you use in the shell, with the function you can call from C.</li>
<li><code>rmdir(path)</code> - Deletes a directory that is empty. This means that you have to <code>unlink</code> and <code>rmdir</code> the directory’s contents first.</li>
<li><code>rename(from, to)</code> - Change the name of file or directory from <code>from</code> to <code>to</code>. You can imagine this is used by the <code>mv</code> command line program.</li>
</ul>
<div class="sourceCode" id="cb249"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb249-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb249-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb249-3" title="3"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb249-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb249-5" title="5"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb249-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb249-7" title="7"></a>
<a class="sourceLine" id="cb249-8" title="8"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb249-9" title="9">{</a>
<a class="sourceLine" id="cb249-10" title="10">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb249-11" title="11">    <span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb249-12" title="12"></a>
<a class="sourceLine" id="cb249-13" title="13">    ret = mkdir(<span class="st">&quot;05/newdir&quot;</span>, <span class="bn">0700</span>);</a>
<a class="sourceLine" id="cb249-14" title="14">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb249-15" title="15">    fd = open(<span class="st">&quot;05/newdir/newfile&quot;</span>, O_RDWR | O_CREAT, <span class="bn">0700</span>);</a>
<a class="sourceLine" id="cb249-16" title="16">    assert(fd &gt;= <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb249-17" title="17">    ret = write(fd, <span class="st">&quot;new contents&quot;</span>, <span class="dv">13</span>);</a>
<a class="sourceLine" id="cb249-18" title="18">    assert(ret == <span class="dv">13</span>);</a>
<a class="sourceLine" id="cb249-19" title="19">    ret = rename(<span class="st">&quot;05/newdir&quot;</span>, <span class="st">&quot;05/newerdir&quot;</span>);</a>
<a class="sourceLine" id="cb249-20" title="20">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb249-21" title="21">    ret = unlink(<span class="st">&quot;05/newerdir/newfile&quot;</span>);</a>
<a class="sourceLine" id="cb249-22" title="22">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb249-23" title="23">    ret = rmdir(<span class="st">&quot;05/newerdir&quot;</span>);</a>
<a class="sourceLine" id="cb249-24" title="24">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb249-25" title="25"></a>
<a class="sourceLine" id="cb249-26" title="26">    printf(<span class="st">&quot;If there were no errors, we</span><span class="sc">\n\t</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb249-27" title="27">        <span class="st">&quot;1. created a directory, </span><span class="sc">\n\t</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb249-28" title="28">        <span class="st">&quot;2. a file in the directory, </span><span class="sc">\n\t</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb249-29" title="29">        <span class="st">&quot;3. change the directory name,</span><span class="sc">\n\t</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb249-30" title="30">        <span class="st">&quot;4. removed the file, and</span><span class="sc">\n\t</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb249-31" title="31">        <span class="st">&quot;5. removed the directory</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb249-32" title="32"></a>
<a class="sourceLine" id="cb249-33" title="33">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb249-34" title="34">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>If there were no errors, we
    1. created a directory, 
    2. a file in the directory, 
    3. change the directory name,
    4. removed the file, and
    5. removed the directory</code></pre>
<h2 id="exercises-2"><span class="header-section-number">9.5</span> Exercises</h2>
<p>Write a <code>tree</code> clone, with disk usage information. Though it isn’t installed, by default, tree outputs the filesystem at a specific directory:</p>
<pre><code>$ tree .
.
├── 01_lecture.md
├── 02_exercises.md
├── prufrock.txt
└── test_directory
    └── crickets.txt</code></pre>
<h3 id="task-1-markdown-tree"><span class="header-section-number">9.5.1</span> Task 1: Markdown Tree</h3>
<p>We’ll simplify the output to print out markdown lists with either <code>D</code> or <code>F</code> for directories or files. If we run the program in the <code>05</code> directory:</p>
<pre><code>$ ./t
- 01_lecture.md (20759)
- 02_exercises.md (1683)
- prufrock.txt (6044)
- test_directory
    - crickets.txt (26)</code></pre>
<p>Some starter code that focuses on printing out info for a single directory.</p>
<p><strong>Task: Change this code to print out the <em>hierarchy</em> of files and directories, rather than just the contents of a single directory.</strong></p>
<div class="sourceCode" id="cb253"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb253-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb253-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb253-3" title="3"><span class="pp">#include </span><span class="im">&lt;dirent.h&gt;</span></a>
<a class="sourceLine" id="cb253-4" title="4"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb253-5" title="5"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb253-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb253-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb253-8" title="8"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb253-9" title="9"></a>
<a class="sourceLine" id="cb253-10" title="10"><span class="co">/* helper functions */</span></a>
<a class="sourceLine" id="cb253-11" title="11"><span class="dt">void</span> indent(<span class="dt">int</span> n);</a>
<a class="sourceLine" id="cb253-12" title="12"><span class="dt">int</span> ignoredir(<span class="dt">char</span> *dir);</a>
<a class="sourceLine" id="cb253-13" title="13"><span class="dt">long</span> file_size(<span class="dt">char</span> *dir, <span class="dt">char</span> *file);</a>
<a class="sourceLine" id="cb253-14" title="14"></a>
<a class="sourceLine" id="cb253-15" title="15"><span class="co">/*</span></a>
<a class="sourceLine" id="cb253-16" title="16"><span class="co"> * Return the size of the directory (sum of all files inside).</span></a>
<a class="sourceLine" id="cb253-17" title="17"><span class="co"> * The easiest implementation here is recursive where this is called</span></a>
<a class="sourceLine" id="cb253-18" title="18"><span class="co"> * for each directory.</span></a>
<a class="sourceLine" id="cb253-19" title="19"><span class="co"> */</span></a>
<a class="sourceLine" id="cb253-20" title="20"><span class="dt">size_t</span></a>
<a class="sourceLine" id="cb253-21" title="21">print_dir(<span class="dt">char</span> *dir, <span class="dt">int</span> depth)</a>
<a class="sourceLine" id="cb253-22" title="22">{</a>
<a class="sourceLine" id="cb253-23" title="23">    DIR *d = opendir(dir);</a>
<a class="sourceLine" id="cb253-24" title="24">    <span class="kw">struct</span> dirent *entry;</a>
<a class="sourceLine" id="cb253-25" title="25"></a>
<a class="sourceLine" id="cb253-26" title="26">    assert(d);</a>
<a class="sourceLine" id="cb253-27" title="27">    errno = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb253-28" title="28"></a>
<a class="sourceLine" id="cb253-29" title="29">    <span class="co">/* Go through each dir/file in this directory! */</span></a>
<a class="sourceLine" id="cb253-30" title="30">    <span class="cf">while</span> ((entry = readdir(d)) != NULL) {</a>
<a class="sourceLine" id="cb253-31" title="31">        <span class="co">/* we&#39;ll ignore . and .. */</span></a>
<a class="sourceLine" id="cb253-32" title="32">        <span class="cf">if</span> (ignoredir(entry-&gt;d_name)) <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb253-33" title="33"></a>
<a class="sourceLine" id="cb253-34" title="34">        <span class="co">/* print out the proper indentation */</span></a>
<a class="sourceLine" id="cb253-35" title="35">        indent(depth);</a>
<a class="sourceLine" id="cb253-36" title="36">        <span class="cf">if</span> (entry-&gt;d_type == DT_DIR) {</a>
<a class="sourceLine" id="cb253-37" title="37">            printf(<span class="st">&quot;- D %s</span><span class="sc">\n</span><span class="st">&quot;</span>, entry-&gt;d_name);</a>
<a class="sourceLine" id="cb253-38" title="38">        } <span class="cf">else</span> <span class="cf">if</span> (entry-&gt;d_type == DT_REG) {</a>
<a class="sourceLine" id="cb253-39" title="39">            printf(<span class="st">&quot;- F %s (%ld)</span><span class="sc">\n</span><span class="st">&quot;</span>, entry-&gt;d_name, file_size(dir, entry-&gt;d_name));</a>
<a class="sourceLine" id="cb253-40" title="40">        }</a>
<a class="sourceLine" id="cb253-41" title="41">        <span class="co">/* we&#39;ll ignore everything that isn&#39;t a file or dir */</span></a>
<a class="sourceLine" id="cb253-42" title="42">    }</a>
<a class="sourceLine" id="cb253-43" title="43">    <span class="cf">if</span> (errno != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb253-44" title="44">        perror(<span class="st">&quot;Reading directory&quot;</span>);</a>
<a class="sourceLine" id="cb253-45" title="45">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb253-46" title="46">    }</a>
<a class="sourceLine" id="cb253-47" title="47">    closedir(d);</a>
<a class="sourceLine" id="cb253-48" title="48"></a>
<a class="sourceLine" id="cb253-49" title="49">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb253-50" title="50">}</a>
<a class="sourceLine" id="cb253-51" title="51"></a>
<a class="sourceLine" id="cb253-52" title="52"><span class="dt">int</span></a>
<a class="sourceLine" id="cb253-53" title="53">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb253-54" title="54">{</a>
<a class="sourceLine" id="cb253-55" title="55">    print_dir(<span class="st">&quot;./&quot;</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb253-56" title="56"></a>
<a class="sourceLine" id="cb253-57" title="57">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb253-58" title="58">}</a>
<a class="sourceLine" id="cb253-59" title="59"></a>
<a class="sourceLine" id="cb253-60" title="60"><span class="co">/* Indent `n` levels */</span></a>
<a class="sourceLine" id="cb253-61" title="61"><span class="dt">void</span></a>
<a class="sourceLine" id="cb253-62" title="62">indent(<span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb253-63" title="63">{</a>
<a class="sourceLine" id="cb253-64" title="64">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) printf(<span class="st">&quot;    &quot;</span>);</a>
<a class="sourceLine" id="cb253-65" title="65">}</a>
<a class="sourceLine" id="cb253-66" title="66"></a>
<a class="sourceLine" id="cb253-67" title="67"><span class="co">/* Should we ignore this directory? */</span></a>
<a class="sourceLine" id="cb253-68" title="68"><span class="dt">int</span></a>
<a class="sourceLine" id="cb253-69" title="69">ignoredir(<span class="dt">char</span> *dir)</a>
<a class="sourceLine" id="cb253-70" title="70">{</a>
<a class="sourceLine" id="cb253-71" title="71">    <span class="cf">return</span> strcmp(dir, <span class="st">&quot;.&quot;</span>) == <span class="dv">0</span> || strcmp(dir, <span class="st">&quot;..&quot;</span>) == <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb253-72" title="72">}</a>
<a class="sourceLine" id="cb253-73" title="73"></a>
<a class="sourceLine" id="cb253-74" title="74"><span class="dt">long</span></a>
<a class="sourceLine" id="cb253-75" title="75">file_size(<span class="dt">char</span> *dir, <span class="dt">char</span> *file)</a>
<a class="sourceLine" id="cb253-76" title="76">{</a>
<a class="sourceLine" id="cb253-77" title="77">    <span class="kw">struct</span> stat finfo;</a>
<a class="sourceLine" id="cb253-78" title="78">    <span class="dt">char</span> buf[<span class="dv">512</span>];</a>
<a class="sourceLine" id="cb253-79" title="79">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb253-80" title="80"></a>
<a class="sourceLine" id="cb253-81" title="81">    memset(buf, <span class="dv">0</span>, <span class="dv">512</span>); <span class="co">/* zero out the buffer to add &#39;\0&#39;s */</span></a>
<a class="sourceLine" id="cb253-82" title="82">    snprintf(buf, <span class="dv">512</span>, <span class="st">&quot;%s/%s&quot;</span>, dir, file);</a>
<a class="sourceLine" id="cb253-83" title="83"></a>
<a class="sourceLine" id="cb253-84" title="84">    ret = stat(buf, &amp;finfo);</a>
<a class="sourceLine" id="cb253-85" title="85">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb253-86" title="86"></a>
<a class="sourceLine" id="cb253-87" title="87">    <span class="cf">return</span> finfo.st_size;</a>
<a class="sourceLine" id="cb253-88" title="88">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>- D 09
- D 04
- F output_tmp.dat (0)
- D 01
- F Makefile (1971)
- F lectures.html (967897)
- D 99
- D 00
- D 11
- D 02
- D 10
- D 13
- D 03
- D 14
- D templates
- F .gitignore (890)
- D 12
- F inline_exec_tmp.c (1658)
- F theme.css (691)
- D 07
- F inline_exec_tmp (60160)
- F LICENSE (1522)
- D tools
- D .git
- D 06
- D figures
- F title.md (333)
- F README.md (35)
- F aggregate.md (251632)
- D 08
- D slides
- D 05</code></pre>
<h3 id="task-2-file-and-directory-sizes"><span class="header-section-number">9.5.2</span> Task 2: File and Directory Sizes</h3>
<p><strong>Task: Add output for the size of files, and the size of each directory – the sum of the size of all contained directories and files.</strong></p>
<p>Again, if we run the program in the <code>05</code> directory:</p>
<pre><code>$ ./t
- 01_lecture.md (20759)
- 02_exercises.md (1683)
- prufrock.txt (6044)
- test_directory
    - crickets.txt (26)
    (26)
(28512)</code></pre>
<p>The <code>test_directory</code> size is the <code>(26)</code>, while the <code>./</code> directory has size <code>(28512)</code>. Your specific sizes might differ.</p>
<h1 id="io-inter-process-communication"><span class="header-section-number">10</span> I/O: Inter-Process Communication</h1>
<p>We’ve seen that processes often coordinate through pipes, signals, and <code>wait</code>. This is necessary when coordinating between parents and children in shells (both on the terminal, and GUIs). These are useful when children have a common parent (thus can share pipes), and where the parent knows that the children want to communicate before they are <code>exec</code>ed. Modern systems require a lot of flexibility than this. Generally, we want a process to be able to decide who to coordinate with as they execute given their own goals. For example, the shell – when it executes a child – doesn’t know if it wants to have a GUI, thus needs to talk to the window server.</p>
<p>We require more dynamic, more flexible forms of coordination between processes. Generally, we call this coordination <em>Inter-Process Communication</em> or <em>IPC</em>. <em>When do we generally want more flexible forms of IPC</em> than pipes, signals, and wait?</p>
<ol type="1">
<li>If the parent doesn’t know what other processes with which a child wants IPC.</li>
<li>If the parent didn’t create the other process with which a child wants IPC.</li>
<li>The process with which we want IPC belongs to a different user.</li>
<li>The process with which we want IPC has access to special resources in the system (e.g. graphics cards, other hardware, or filesystem data).</li>
</ol>
<p>Even applications that are implemented as many processes often require IPC between those processes.</p>
<h2 id="ipc-example-modern-browsers"><span class="header-section-number">10.1</span> IPC Example: Modern Browsers</h2>
<p>Browsers all require a <em>lot</em> of IPC. Each tab is a separate process, and there is a single <em>browser management</em> process that manages the GUI and other browser resources. This is motivated by security concerns: a tab that fails or is compromised by an attacker cannot access the data of another tab! In the early (first 15-20 years) of browsers, this wasn’t the case, and you had to be careful about opening your banking webpage next to webpages that were suspect. The browser management process communicates with each of the child tab processes to send them user input (mouse clicks, keyboard input), and receive a bitmap to display on screen. Lets see this structure:</p>
<pre><code>$ ps aux | grep firefox
... 8029 ... /usr/lib/firefox/firefox -new-window
... 8151 ... /usr/lib/firefox/firefox -contentproc -childID 1 -isForBrowser ... 8029 ...
...</code></pre>
<p>I have an embarrassing number of tabs open, so I’ve taken the liberty of manually filtering this output. We can see that the process with pid <code>8029</code> is the parent, browser management process, and the process <code>8151</code> is a child managing a tab (note, you can see processes arranges as a process tree using <code>ps axjf</code>). There are many other children processes managing tabs.</p>
<p>Lets try and figure out how they communicate with each other. First, lets look at the file descriptors of the tab’s processes (the child).</p>
<pre><code>$ ls -l /proc/8151/fd/
0 -&gt; /dev/null
1 -&gt; socket:[100774]
...
11 -&gt; /memfd:mozilla-ipc
4 -&gt; socket:[107464]
5 -&gt; socket:[107467]
7 -&gt; pipe:[110438]</code></pre>
<p>We see that there is no standard input (<code>/dev/null</code> is “nothing”), and that there are a few means of IPC:</p>
<ul>
<li><code>pipe</code> - We know these!</li>
<li><code>memfd</code> - A Linux-specific way of sharing a range of memory between the processes. Stores to the memory can be seen by all sharing processes.</li>
<li><code>socket</code> - Another pipe-line channel in which bytes written into the socket can be read out on the other side. A key difference is that socket connections between processes can be created without requiring the inheritance of descriptors via <code>fork</code>.</li>
</ul>
<p>Lets look at the browser management process, and see what’s going on. Notably, we want to see how the tab’s processes communicate with it. Thus, lets look at the descriptors for the parent:</p>
<pre><code>$ ls -l /proc/8029/fd/ | awk &#39;{print $9 $10 $11}&#39;
110 -&gt; /home/ycombinator/.mozilla/.../https+++mail.google.com...data.sqlite
171 -&gt; /home/ycombinator/.mozilla/.../https+++www.youtube.com....data.sqlite
123 -&gt; /home/ycombinator/.mozilla/.../formhistory.sqlite
130 -&gt; /home/ycombinator/.mozilla/.../bookmarks.sqlite
58 -&gt; /home/ycombinator/.mozilla/.../cookies.sqlite
3 -&gt; /dev/dri/renderD128
43 -&gt; /dev/dri/card0
...
100 -&gt; /memfd:mozilla-ipc
60 -&gt; socket:[107464]
64 -&gt; socket:[107467]
82 -&gt; pipe:[110438]</code></pre>
<p>This is <em>heavily filtered</em>. The first, highlighted section shows that the browser management process uses a database (<code>sqlite</code>) to access a webpage’s data (see <code>gmail</code> and <code>youtube</code>), store form histories, bookmarks, and cookies. It also uses the <code>dri</code> device is part of the <a href="https://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure">Direct Rendering Infrastructure</a> which enables it to communicate with the X Window Server, and display what we see on screen. Finally, we see it uses the same means of IPC as the client, and if we carefully look at the <code>[ids]</code> of the sockets and pipes, we can see that they match those in the child tab process! We can see that the tab has multiple IPC channels open with the parent, and can access them with file descriptors.</p>
<h2 id="goals-of-ipc-mechanisms"><span class="header-section-number">10.2</span> Goals of IPC Mechanisms</h2>
<p>There are multiple IPC mechanisms in the system, and they all represent different trade-offs. They might be good for some things, and bad at others.</p>
<ul>
<li><strong>Transparent IPC.</strong> Do applications need to be changed at all to perform IPC? If not, they are <em>transparently</em> leveraging IPC. Shell-driven pipes have a huge benefit that they enable transparent IPC!</li>
<li><strong>Named IPC.</strong> If we want multiple process to communicate that can’t rely on a comment parent to coordinate that communication, they need a means to find an “name” the IPC mechanism. Named IPC is in conflict with transparent IPC as we likely need to use a specific API to access the IPC mechanism.</li>
<li><strong>Channel-based IPC.</strong> Often we want to send <em>messages</em> between processes such that a sent message, when received is removed from the channel – once read, it won’t be read again. This enables processes to receive some request, do some processing on it, then move on to the next request.</li>
<li><strong>Multi-client communication.</strong> We often want to create a process that can provide services to <em>multiple</em> other “client” processes. Clients request service, and the “server” process receives these requests, and provides replies.</li>
</ul>
<p>Lets assess <code>pipe</code>s in this taxonomy:</p>
<ul>
<li>✓ <strong>Transparent IPC.</strong> - Pipes are pervasive for a reason! They enable composition of programs via pipelines despite the programs not even knowing they are in the pipeline!</li>
<li>✗ <strong>Named IPC.</strong> - Na. The parent has to set it all up – lots of <code>dup</code>, <code>close</code>, and <code>pipe</code>.</li>
<li>✓ <strong>Channel-based IPC.</strong> - Data written to a pipe is removed by the reader.</li>
<li>✗ <strong>Multi-client communication.</strong> - Pipes are really there to pass a stream of data from one process to the other.</li>
</ul>
<h2 id="files-shared-memory"><span class="header-section-number">10.3</span> Files &amp; Shared Memory</h2>
<p>If the goal is to send data from one process to another, one option is found in the filesystem (FS): can’t we just use files to share? Toward this, we saw in the section on FS I/O that we can open a file, and <code>read</code> and <code>write</code> (or <code>fread</code>/<code>fwrite</code>) from it from <em>multiple</em> processes. This will certainly get data from one process to the other. However, it has a number of shortcomings:</p>
<ol type="1">
<li>If you want to pass a potentially infinite stream of data between processes (think <code>pipe</code>s), then we’d end up with an infinite file. That translates to your disk running out of space very quickly, with little benefit. Take-away: files are for a finite amount of data, not for an infinite stream of data.</li>
<li>Given this, processes must assume that the file has a specific format, and they have indication of if the other process has accessed/read data in the file. An example of a specific format: maybe the file is treated as a single string of a constant length.</li>
<li>There isn’t any indication about when other processes have modified the file, thus the processes might overwrite each other’s data<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>.</li>
</ol>
<p>To emphasize these problems, lets try and implement a channel in a file to send data between processes. We just want to send a simple string repetitively from one process to the other.</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb259-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb259-2" title="2"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb259-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb259-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb259-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb259-6" title="6"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb259-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb259-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb259-9" title="9"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb259-10" title="10"></a>
<a class="sourceLine" id="cb259-11" title="11"><span class="dt">int</span></a>
<a class="sourceLine" id="cb259-12" title="12">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb259-13" title="13">{</a>
<a class="sourceLine" id="cb259-14" title="14">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb259-15" title="15"></a>
<a class="sourceLine" id="cb259-16" title="16">    ret = creat(<span class="st">&quot;string_data&quot;</span>, <span class="bn">0777</span>);</a>
<a class="sourceLine" id="cb259-17" title="17">    assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-18" title="18"></a>
<a class="sourceLine" id="cb259-19" title="19">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb259-20" title="20">        <span class="dt">char</span> *msg[] = {<span class="st">&quot;penny for pawsident&quot;</span>, <span class="st">&quot;america for good doggies&quot;</span>};</a>
<a class="sourceLine" id="cb259-21" title="21">        <span class="dt">int</span> fd = open(<span class="st">&quot;string_data&quot;</span>, O_WRONLY);</a>
<a class="sourceLine" id="cb259-22" title="22">        assert(fd != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-23" title="23"></a>
<a class="sourceLine" id="cb259-24" title="24">        <span class="co">/* send the first message! */</span></a>
<a class="sourceLine" id="cb259-25" title="25">        ret = write(fd, msg[<span class="dv">0</span>], strlen(msg[<span class="dv">0</span>]) + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-26" title="26">        assert(ret == (<span class="dt">int</span>)strlen(msg[<span class="dv">0</span>]) + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-27" title="27">        <span class="co">/* send the second message! */</span></a>
<a class="sourceLine" id="cb259-28" title="28">        ret = lseek(fd, <span class="dv">0</span>, SEEK_SET);</a>
<a class="sourceLine" id="cb259-29" title="29">        ret = write(fd, msg[<span class="dv">1</span>], strlen(msg[<span class="dv">1</span>]) + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-30" title="30">        assert(ret == (<span class="dt">int</span>)strlen(msg[<span class="dv">1</span>]) + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-31" title="31"></a>
<a class="sourceLine" id="cb259-32" title="32">        close(fd);</a>
<a class="sourceLine" id="cb259-33" title="33">        exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb259-34" title="34">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb259-35" title="35">        <span class="dt">char</span> data[<span class="dv">32</span>];</a>
<a class="sourceLine" id="cb259-36" title="36">        <span class="dt">int</span> fd = open(<span class="st">&quot;string_data&quot;</span>, O_RDONLY);</a>
<a class="sourceLine" id="cb259-37" title="37">        assert(fd != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-38" title="38"></a>
<a class="sourceLine" id="cb259-39" title="39">        memset(data, <span class="dv">0</span>, <span class="dv">32</span>);</a>
<a class="sourceLine" id="cb259-40" title="40">        ret = read(fd, data, <span class="dv">32</span>);</a>
<a class="sourceLine" id="cb259-41" title="41">        assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-42" title="42">        printf(<span class="st">&quot;msg1: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, data);</a>
<a class="sourceLine" id="cb259-43" title="43"></a>
<a class="sourceLine" id="cb259-44" title="44">        ret = lseek(fd, <span class="dv">0</span>, SEEK_SET);</a>
<a class="sourceLine" id="cb259-45" title="45">        assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-46" title="46">        ret = read(fd, data, <span class="dv">32</span>);</a>
<a class="sourceLine" id="cb259-47" title="47">        assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb259-48" title="48">        printf(<span class="st">&quot;msg2: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, data);</a>
<a class="sourceLine" id="cb259-49" title="49">    }</a>
<a class="sourceLine" id="cb259-50" title="50">    wait(NULL);</a>
<a class="sourceLine" id="cb259-51" title="51">    unlink(<span class="st">&quot;string_data&quot;</span>);</a>
<a class="sourceLine" id="cb259-52" title="52"></a>
<a class="sourceLine" id="cb259-53" title="53">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb259-54" title="54">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>msg1: 
msg2: america for good doggies</code></pre>
<p>You can see that there are some problems here. If we run it many times, we can see that sometimes we don’t see any messages, sometimes we only see the first, sometimes we only see the second, and other times combinations of all three options. Thus, they are not useful for channel-based communication between multiple processes.</p>
<p>On the other side, files have a very <em>useful</em> properti that we’d like to use in a good solution to IPC: they <em>have a location in the FS</em> that the communicating processes can both use to find the file, thus avoiding the need for a shared parent.</p>
<ul>
<li>✗ <strong>Transparent IPC</strong> - We have to open the file explicitly.</li>
<li>✓ <strong>Named IPC.</strong> - Each file has a path in the filesystem.</li>
<li>✗ <strong>Channel-based IPC.</strong> - When we read out of a file, the data remains, making it hard to know what we’ve read, and what is yet to be written. A stream of messages placed into a file also will expend your disk!</li>
<li>✗ <strong>Multi-client communication.</strong> - It isn’t clear how multiple clients can convey separate requests, and can receive separate replies from a server.</li>
</ul>
<blockquote>
<p>An aside: you can use <code>mmap</code> to map a <em>file</em> into the address space, and if you map it <code>MAP_SHARED</code> (instead of <code>MAP_PRIVATE</code>), then the memory will be shared between processes. When one process does a store to the memory, the other process will see that store immediately! We can use this to pass data between processes, but we still have many of the problems above. How do we avoid conflicting modifications to the memory, get notifications that modifications have been made, and make sure that the data is formatted in an organized (finite) manner?</p>
</blockquote>
<h2 id="named-pipes"><span class="header-section-number">10.4</span> Named Pipes</h2>
<p>The core problem with files is that they aren’t channels that remove existing data when it is “consumed” (<code>read</code>). But they have the significant up-side that they have a “name” in the filesystem that multiple otherwise independent processes can use to access the communication medium.</p>
<p>Named pipes or FIFOs are like pipes in that one process can write into the FIFO, and another process can read from it. Thus, unlike files, they have the desirable property of channels in which data read from the channel is consumed. However, like files (and unlike pipes) they have a “name” in the filesystem – FIFOs appear in the filesystem along-side files. The <code>stat</code> function will let you know that a file is a FIFO if the <code>st_mode</code> is <code>S_IFIFO</code>. Since these pipes appear in the filesystem, they are called <strong>named pipes</strong>. Two processes that wish to communicate need only both know where in the filesystem they agree to find the named pipe.</p>
<p>Lets see an example of using named pipes:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb261-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb261-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb261-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb261-4" title="4"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb261-5" title="5"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb261-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb261-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb261-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb261-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb261-10" title="10"></a>
<a class="sourceLine" id="cb261-11" title="11"><span class="dt">void</span></a>
<a class="sourceLine" id="cb261-12" title="12">proc1(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb261-13" title="13">{</a>
<a class="sourceLine" id="cb261-14" title="14">    <span class="dt">int</span> fd, ret;</a>
<a class="sourceLine" id="cb261-15" title="15"></a>
<a class="sourceLine" id="cb261-16" title="16">    fd = open(<span class="st">&quot;office_hours&quot;</span>, O_WRONLY);</a>
<a class="sourceLine" id="cb261-17" title="17">    assert(fd != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb261-18" title="18"></a>
<a class="sourceLine" id="cb261-19" title="19">    ret = write(fd, <span class="st">&quot;halp!&quot;</span>, <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb261-20" title="20">    assert(ret == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb261-21" title="21">    close(fd);</a>
<a class="sourceLine" id="cb261-22" title="22">}</a>
<a class="sourceLine" id="cb261-23" title="23"></a>
<a class="sourceLine" id="cb261-24" title="24"><span class="dt">void</span></a>
<a class="sourceLine" id="cb261-25" title="25">proc2(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb261-26" title="26">{</a>
<a class="sourceLine" id="cb261-27" title="27">    <span class="dt">char</span> msg[<span class="dv">6</span>];</a>
<a class="sourceLine" id="cb261-28" title="28">    <span class="dt">int</span> fd, ret;</a>
<a class="sourceLine" id="cb261-29" title="29"></a>
<a class="sourceLine" id="cb261-30" title="30">    memset(msg, <span class="dv">0</span>, <span class="dv">6</span>);</a>
<a class="sourceLine" id="cb261-31" title="31">    fd = open(<span class="st">&quot;office_hours&quot;</span>, O_RDONLY);</a>
<a class="sourceLine" id="cb261-32" title="32">    assert(fd != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb261-33" title="33"></a>
<a class="sourceLine" id="cb261-34" title="34">    ret = read(fd, msg, <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb261-35" title="35">    assert(ret == <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb261-36" title="36">    close(fd);</a>
<a class="sourceLine" id="cb261-37" title="37"></a>
<a class="sourceLine" id="cb261-38" title="38">    printf(<span class="st">&quot;What I hear at office hours is </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st">.&quot;</span>, msg);</a>
<a class="sourceLine" id="cb261-39" title="39">    unlink(<span class="st">&quot;office_hours&quot;</span>);</a>
<a class="sourceLine" id="cb261-40" title="40">}</a>
<a class="sourceLine" id="cb261-41" title="41"></a>
<a class="sourceLine" id="cb261-42" title="42"><span class="dt">int</span></a>
<a class="sourceLine" id="cb261-43" title="43">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb261-44" title="44">{</a>
<a class="sourceLine" id="cb261-45" title="45">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb261-46" title="46"></a>
<a class="sourceLine" id="cb261-47" title="47">    <span class="co">/* This is how we create a FIFO. A FIFO version of creat. */</span></a>
<a class="sourceLine" id="cb261-48" title="48">    ret = mkfifo(<span class="st">&quot;office_hours&quot;</span>, <span class="bn">0777</span>);</a>
<a class="sourceLine" id="cb261-49" title="49">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb261-50" title="50"></a>
<a class="sourceLine" id="cb261-51" title="51">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb261-52" title="52">        proc1();</a>
<a class="sourceLine" id="cb261-53" title="53">        exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb261-54" title="54">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb261-55" title="55">        proc2();</a>
<a class="sourceLine" id="cb261-56" title="56">        wait(NULL);</a>
<a class="sourceLine" id="cb261-57" title="57">    }</a>
<a class="sourceLine" id="cb261-58" title="58"></a>
<a class="sourceLine" id="cb261-59" title="59">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb261-60" title="60">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>What I hear at office hours is &quot;halp!&quot;.</code></pre>
<p>There is one very awkward named pipe behavior. Processes attempting to <code>open</code> a named pipe will block (the <code>open</code> will not return) until processes have opened it separately as both <em>readable</em> and <em>writable</em>. This is awkward because how would a process <em>know</em> when another process might want to communicate with it? If a process gets IPC requests from many others (think the browser manager), then it doesn’t want to block awaiting a new communication; it wants to service the requests of other processes.</p>
<p>Regardless, we do see named pipes as a cool option: named pipes enable us to use the filesystem to identify the pipe used for IPC. This enables communicating processes without shared parents to leverage IPC. This enables pipes to live up to the UNIX motto: <em>everything is a file</em>.</p>
<h3 id="challenges-with-named-pipes-for-multi-client-communication"><span class="header-section-number">10.4.1</span> Challenges with Named Pipes for Multi-Client Communication</h3>
<p>Lets check out an example that demonstrates how using named pipes for communication between a single process and multiple <em>clients</em> has a number of challenges.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb263-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb263-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb263-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb263-4" title="4"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb263-5" title="5"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb263-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb263-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb263-8" title="8"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb263-9" title="9"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb263-10" title="10"></a>
<a class="sourceLine" id="cb263-11" title="11"><span class="co">/*</span></a>
<a class="sourceLine" id="cb263-12" title="12"><span class="co"> * Receive requests, and send them immediately as a response.</span></a>
<a class="sourceLine" id="cb263-13" title="13"><span class="co"> * You can imagine that interesting computation could be done</span></a>
<a class="sourceLine" id="cb263-14" title="14"><span class="co"> * to formulate a response.</span></a>
<a class="sourceLine" id="cb263-15" title="15"><span class="co"> */</span></a>
<a class="sourceLine" id="cb263-16" title="16"><span class="dt">void</span></a>
<a class="sourceLine" id="cb263-17" title="17">instructor(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb263-18" title="18">{</a>
<a class="sourceLine" id="cb263-19" title="19">    <span class="dt">int</span> req, resp, ret;</a>
<a class="sourceLine" id="cb263-20" title="20">    <span class="dt">char</span> msg[<span class="dv">32</span>];</a>
<a class="sourceLine" id="cb263-21" title="21"></a>
<a class="sourceLine" id="cb263-22" title="22">    req = open(<span class="st">&quot;requests&quot;</span>, O_RDONLY);</a>
<a class="sourceLine" id="cb263-23" title="23">    assert(req != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-24" title="24">    resp = open(<span class="st">&quot;responses&quot;</span>, O_WRONLY);</a>
<a class="sourceLine" id="cb263-25" title="25">    assert(resp != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-26" title="26"></a>
<a class="sourceLine" id="cb263-27" title="27">    <span class="cf">while</span> (<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb263-28" title="28">        ret = read(req, msg, <span class="dv">32</span>);</a>
<a class="sourceLine" id="cb263-29" title="29">        <span class="cf">if</span> (ret == <span class="dv">0</span>) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb263-30" title="30">        assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-31" title="31">        ret = write(resp, msg, ret);</a>
<a class="sourceLine" id="cb263-32" title="32">        <span class="cf">if</span> (ret == <span class="dv">0</span>) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb263-33" title="33">        assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-34" title="34">    }</a>
<a class="sourceLine" id="cb263-35" title="35"></a>
<a class="sourceLine" id="cb263-36" title="36">    close(req);</a>
<a class="sourceLine" id="cb263-37" title="37">    close(resp);</a>
<a class="sourceLine" id="cb263-38" title="38">}</a>
<a class="sourceLine" id="cb263-39" title="39"></a>
<a class="sourceLine" id="cb263-40" title="40"><span class="co">/*</span></a>
<a class="sourceLine" id="cb263-41" title="41"><span class="co"> * Make a &quot;request&quot; with our pid, and get a response,</span></a>
<a class="sourceLine" id="cb263-42" title="42"><span class="co"> * hopefully also our pid.</span></a>
<a class="sourceLine" id="cb263-43" title="43"><span class="co"> */</span></a>
<a class="sourceLine" id="cb263-44" title="44"><span class="dt">void</span></a>
<a class="sourceLine" id="cb263-45" title="45">student(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb263-46" title="46">{</a>
<a class="sourceLine" id="cb263-47" title="47">    <span class="dt">int</span> req, resp, ret;</a>
<a class="sourceLine" id="cb263-48" title="48">    <span class="dt">char</span> msg[<span class="dv">32</span>];</a>
<a class="sourceLine" id="cb263-49" title="49"></a>
<a class="sourceLine" id="cb263-50" title="50">    req = open(<span class="st">&quot;requests&quot;</span>, O_WRONLY);</a>
<a class="sourceLine" id="cb263-51" title="51">    assert(req != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-52" title="52">    resp = open(<span class="st">&quot;responses&quot;</span>, O_RDONLY);</a>
<a class="sourceLine" id="cb263-53" title="53">    assert(resp != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-54" title="54"></a>
<a class="sourceLine" id="cb263-55" title="55">    ret = snprintf(msg, <span class="dv">32</span>, <span class="st">&quot;%d&quot;</span>, getpid());</a>
<a class="sourceLine" id="cb263-56" title="56">    ret = write(req, msg, ret);</a>
<a class="sourceLine" id="cb263-57" title="57">    assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-58" title="58">    ret = read(resp, msg, <span class="dv">32</span>);</a>
<a class="sourceLine" id="cb263-59" title="59">    assert(ret != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-60" title="60"></a>
<a class="sourceLine" id="cb263-61" title="61">    printf(<span class="st">&quot;%d: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid(), msg);</a>
<a class="sourceLine" id="cb263-62" title="62"></a>
<a class="sourceLine" id="cb263-63" title="63">    close(req);</a>
<a class="sourceLine" id="cb263-64" title="64">    close(resp);</a>
<a class="sourceLine" id="cb263-65" title="65">}</a>
<a class="sourceLine" id="cb263-66" title="66"></a>
<a class="sourceLine" id="cb263-67" title="67"><span class="dt">void</span></a>
<a class="sourceLine" id="cb263-68" title="68">close_fifos(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb263-69" title="69">{</a>
<a class="sourceLine" id="cb263-70" title="70">    unlink(<span class="st">&quot;requests&quot;</span>);</a>
<a class="sourceLine" id="cb263-71" title="71">    unlink(<span class="st">&quot;responses&quot;</span>);</a>
<a class="sourceLine" id="cb263-72" title="72">}</a>
<a class="sourceLine" id="cb263-73" title="73"></a>
<a class="sourceLine" id="cb263-74" title="74"><span class="dt">int</span></a>
<a class="sourceLine" id="cb263-75" title="75">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb263-76" title="76">{</a>
<a class="sourceLine" id="cb263-77" title="77">    <span class="dt">int</span> ret, i;</a>
<a class="sourceLine" id="cb263-78" title="78">    pid_t pids[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb263-79" title="79"></a>
<a class="sourceLine" id="cb263-80" title="80">    <span class="co">/* clients write to this, server reads */</span></a>
<a class="sourceLine" id="cb263-81" title="81">    ret = mkfifo(<span class="st">&quot;requests&quot;</span>, <span class="bn">0777</span>);</a>
<a class="sourceLine" id="cb263-82" title="82">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb263-83" title="83">    <span class="co">/* server sends replies to this, clients read */</span></a>
<a class="sourceLine" id="cb263-84" title="84">    ret = mkfifo(<span class="st">&quot;responses&quot;</span>, <span class="bn">0777</span>);</a>
<a class="sourceLine" id="cb263-85" title="85">    assert(ret == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb263-86" title="86"></a>
<a class="sourceLine" id="cb263-87" title="87">    <span class="co">/* create 1 instructor that is lecturing */</span></a>
<a class="sourceLine" id="cb263-88" title="88">    <span class="cf">if</span> ((pids[<span class="dv">0</span>] = fork()) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb263-89" title="89">        instructor();</a>
<a class="sourceLine" id="cb263-90" title="90">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb263-91" title="91">    }</a>
<a class="sourceLine" id="cb263-92" title="92">    <span class="co">/* Create 2 students &quot;listening&quot; to the lecture */</span></a>
<a class="sourceLine" id="cb263-93" title="93">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++) {</a>
<a class="sourceLine" id="cb263-94" title="94">        <span class="cf">if</span> ((pids[i + <span class="dv">1</span>] = fork()) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb263-95" title="95">            student();</a>
<a class="sourceLine" id="cb263-96" title="96">            <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb263-97" title="97">        }</a>
<a class="sourceLine" id="cb263-98" title="98">    }</a>
<a class="sourceLine" id="cb263-99" title="99"></a>
<a class="sourceLine" id="cb263-100" title="100">    atexit(close_fifos);</a>
<a class="sourceLine" id="cb263-101" title="101">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-102" title="102">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) kill(pids[i], SIGTERM);</a>
<a class="sourceLine" id="cb263-103" title="103">    <span class="cf">while</span> (wait(NULL) != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb263-104" title="104"></a>
<a class="sourceLine" id="cb263-105" title="105">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb263-106" title="106">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>3499046: 3499046
3499047: 3499047</code></pre>
<p>If executed many times, you see the expected result:</p>
<pre><code>167907: 167907
167908: 167908</code></pre>
<p>…but also strange results:</p>
<pre><code>167941: 167940167941</code></pre>
<p>If this is executed many times, we see a few properties of named pipes.</p>
<ol type="1">
<li>There isn’t really a way to predict which student sees which data – this is determined by the concurrency of the system.</li>
<li>Sometimes a student is “starved” of data completely.</li>
<li>The instructor doesn’t have any control over <em>which</em> student should receive which data.</li>
</ol>
<figure>
<img src="./figures/fifo.png" alt="Using two named pipes, one per communication direction, to communicate between a server (right) and clients (left). The color of the arrows designates the client for whom the communication is relevant. Note that on the way back to the clients, we “lose” track of which client each reply is for. This simply isn’t tracked with named pipes." /><figcaption>Using two named pipes, one per communication direction, to communicate between a server (right) and clients (left). The color of the arrows designates the client for whom the communication is relevant. Note that on the way back to the clients, we “lose” track of which client each reply is for. This simply isn’t tracked with named pipes.</figcaption>
</figure>
<p><strong>Named pipes summary.</strong> These solve an important problem: how can we have multiple processes find a “pipe” to use for communication even if they don’t have a parent to coordinate that communication? They use a filesystem path/name to identify the pipe. However, they are not suitable for a single processes (a server) to communicate with multiple clients as they don’t enable the communication for each client to be separated in the server.</p>
<ul>
<li>✗ <strong>Transparent IPC.</strong> - we have to use the <code>mkfifo</code> API explicitly.</li>
<li>✓ <strong>Named IPC.</strong> - the named pipe is represented as a file in the filesystem.</li>
<li>✓ <strong>Channel-based IPC.</strong> - read data is removed from the pipe.</li>
<li>✗ <strong>Multi-client communication.</strong> - a server cannot tell the difference between clients, nor can they send responses to specific clients.</li>
</ul>
<h2 id="unix-domain-sockets"><span class="header-section-number">10.5</span> UNIX Domain Sockets</h2>
<p><em>Sockets</em> are the mechanism provided by UNIX to communicate over the <em>network</em>! However, they can also be used to communicate between processes on your system through <em>UNIX domain sockets</em>.</p>
<p>A few key concepts for domain sockets:</p>
<ol type="1">
<li>They are presented in the filesystem as a file, similar to named pipes. This enables them to be accessed by multiple communicating processes that don’t necessarily share a parent to coordinate that communication.</li>
<li>Each new <em>client</em> that attempts to connect to a <em>server</em> will be represented as a <em>separate descriptor</em> in the server, thus enabling the server to separate its communication with on, from the other. The goal is to create a descriptor for <em>each pair of communicating processes</em>.</li>
<li>Each descriptor to a domain socket is bi-directional – it can be <code>read</code> and <code>write</code>n to, thus making communication back and forth quite a bit easier.</li>
</ol>
<h3 id="domain-sockets-for-multi-client-communication"><span class="header-section-number">10.5.1</span> Domain sockets for Multi-Client Communication</h3>
<p>Lets look at an example were we want a server to receive a client’s requests as strings, and to reply with those same strings. This isn’t useful, per-say, but demonstrates how this communication can happen. Notably, we want to enable the server to communicate with different clients!</p>
<ul>
<li>A <em>server</em> receives IPC requests from <em>clients</em>. Note that this is similar to how a server on the internet serves webpages to multiple clients (and, indeed, the code is similar!).</li>
<li>The server’s functions include <code>socket</code>, <code>bind</code>, and <code>listen</code>. <code>socket</code> creates a domain socket file descriptor</li>
<li>The server creates a <em>separate descriptor</em> for each client using <code>accept</code>.</li>
<li>The client’s functions include <code>socket</code> and <code>connect</code>.</li>
</ul>
<p>Most of these functions are complex and have tons of options. Most of them have been distilled into the following functions in <code>06/domain_sockets.h</code>:</p>
<ul>
<li><code>int domain_socket_server_create(const char *file_name)</code> - Create a descriptor to the “server” end of the IPC channel identified by <code>file_name</code> in the filesystem, similar to the named pipes before.</li>
<li><code>int domain_socket_client_create(const char *file_name)</code> - Create a descriptor to the “client” end of the IPC channel identified by a file name. One constraint is that the <em>server must create the domain socket first</em>, or else this call (the <code>connect</code>) will fail.</li>
</ul>
<p>The server’s descriptor is not meant to be used for direct communication (i.e. should not be used for <code>read</code>, and <code>write</code>). Instead, it is used to <em>create new descriptors, one per client</em>! With a descriptor per-client, we have the fortunate ability to communicate explicitly with each client without the same problem of messages getting messed up in named pipes.</p>
<figure>
<img src="./figures/domain_sockets.png" alt="A sequence of using domain sockets to communicate between multiple clients and a server. (a) The single domain socket that clients can attempt to connect to. (b) The server using accept to create a new descriptor and channel for communication with the red client (thus the “red” channel). (c) Subsequent communication with that client is explicitly through that channel, so the server can send specifically to that client. (d) The server creates a separate channel for communication with the blue client." /><figcaption>A sequence of using domain sockets to communicate between multiple clients and a server. (a) The single domain socket that clients can attempt to <code>connect</code> to. (b) The server using <code>accept</code> to create a new descriptor and channel for communication with the red client (thus the “red” channel). (c) Subsequent communication with that client is explicitly through that channel, so the server can send specifically to that client. (d) The server creates a <em>separate</em> channel for communication with the blue client.</figcaption>
</figure>
<h4 id="setting-up-domain-sockets"><span class="header-section-number">10.5.1.1</span> Setting up Domain Sockets</h4>
<p>Two functions that both take an argument which is the domain socket name/path in the file system, and return a descriptor to the socket. For the most part, you can just use these functions in your code directly by using <code>06/domain_sockets.h</code>.</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb267-1" title="1"><span class="pp">#include </span><span class="im">&quot;06/domain_sockets.h&quot;</span></a>
<a class="sourceLine" id="cb267-2" title="2"></a>
<a class="sourceLine" id="cb267-3" title="3"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb267-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb267-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb267-6" title="6"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb267-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb267-8" title="8"></a>
<a class="sourceLine" id="cb267-9" title="9"><span class="dt">void</span></a>
<a class="sourceLine" id="cb267-10" title="10">unlink_domain_socket(<span class="dt">int</span> status, <span class="dt">void</span> *filename)</a>
<a class="sourceLine" id="cb267-11" title="11">{</a>
<a class="sourceLine" id="cb267-12" title="12">    unlink(filename);</a>
<a class="sourceLine" id="cb267-13" title="13">    free(filename);</a>
<a class="sourceLine" id="cb267-14" title="14">}</a>
<a class="sourceLine" id="cb267-15" title="15"></a>
<a class="sourceLine" id="cb267-16" title="16"><span class="pp">#define MAX_BUF_SZ 128</span></a>
<a class="sourceLine" id="cb267-17" title="17"></a>
<a class="sourceLine" id="cb267-18" title="18"><span class="dt">void</span></a>
<a class="sourceLine" id="cb267-19" title="19">server(<span class="dt">int</span> num_clients, <span class="dt">char</span> *filename)</a>
<a class="sourceLine" id="cb267-20" title="20">{</a>
<a class="sourceLine" id="cb267-21" title="21">    <span class="dt">char</span> buf[MAX_BUF_SZ];</a>
<a class="sourceLine" id="cb267-22" title="22">    <span class="dt">int</span> new_client, amnt, i, socket_desc;</a>
<a class="sourceLine" id="cb267-23" title="23"></a>
<a class="sourceLine" id="cb267-24" title="24">    socket_desc = domain_socket_server_create(filename);</a>
<a class="sourceLine" id="cb267-25" title="25">    <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) exit(EXIT_FAILURE); <span class="co">/* should do proper cleanup */</span></a>
<a class="sourceLine" id="cb267-26" title="26">    on_exit(unlink_domain_socket, strdup(filename));</a>
<a class="sourceLine" id="cb267-27" title="27"></a>
<a class="sourceLine" id="cb267-28" title="28">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb267-29" title="29"><span class="co">     * Service `num_clients` number of clients, one at a time.F</span></a>
<a class="sourceLine" id="cb267-30" title="30"><span class="co">     * For many servers, this might be an infinite loop.</span></a>
<a class="sourceLine" id="cb267-31" title="31"><span class="co">     */</span></a>
<a class="sourceLine" id="cb267-32" title="32">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; num_clients; i++) {</a>
<a class="sourceLine" id="cb267-33" title="33">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb267-34" title="34"><span class="co">         * We use this new descriptor to communicate with *this* client.</span></a>
<a class="sourceLine" id="cb267-35" title="35"><span class="co">         * This is the key function that enables us to create per-client</span></a>
<a class="sourceLine" id="cb267-36" title="36"><span class="co">         * descriptors. It only returns when a client is ready to communicate.</span></a>
<a class="sourceLine" id="cb267-37" title="37"><span class="co">         */</span></a>
<a class="sourceLine" id="cb267-38" title="38">        <span class="cf">if</span> ((new_client = accept(socket_desc, NULL, NULL)) == -<span class="dv">1</span>) exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb267-39" title="39">        printf(<span class="st">&quot;Server: New client connected with new file descriptor %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, new_client);</a>
<a class="sourceLine" id="cb267-40" title="40">        fflush(stdout);</a>
<a class="sourceLine" id="cb267-41" title="41"></a>
<a class="sourceLine" id="cb267-42" title="42">        amnt = read(new_client, buf, MAX_BUF_SZ - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb267-43" title="43">        <span class="cf">if</span> (amnt == -<span class="dv">1</span>) exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb267-44" title="44">        buf[amnt] = &#39;\<span class="dv">0</span><span class="er">&#39;</span>; <span class="co">/* ensure null termination of the string */</span></a>
<a class="sourceLine" id="cb267-45" title="45">        printf(<span class="st">&quot;Server received message (sz %d): </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st">. Replying!</span><span class="sc">\n</span><span class="st">&quot;</span>, amnt, buf);</a>
<a class="sourceLine" id="cb267-46" title="46">        fflush(stdout);</a>
<a class="sourceLine" id="cb267-47" title="47"></a>
<a class="sourceLine" id="cb267-48" title="48">        <span class="co">/* send the client a reply */</span></a>
<a class="sourceLine" id="cb267-49" title="49">        <span class="cf">if</span> (write(new_client, buf, amnt) &lt; <span class="dv">0</span>) exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb267-50" title="50">        <span class="co">/* Done with communication with this client */</span></a>
<a class="sourceLine" id="cb267-51" title="51">        close(new_client);</a>
<a class="sourceLine" id="cb267-52" title="52">    }</a>
<a class="sourceLine" id="cb267-53" title="53">    close(socket_desc);</a>
<a class="sourceLine" id="cb267-54" title="54"></a>
<a class="sourceLine" id="cb267-55" title="55">    exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb267-56" title="56">}</a>
<a class="sourceLine" id="cb267-57" title="57"></a>
<a class="sourceLine" id="cb267-58" title="58"><span class="dt">void</span></a>
<a class="sourceLine" id="cb267-59" title="59">client(<span class="dt">char</span> *filename)</a>
<a class="sourceLine" id="cb267-60" title="60">{</a>
<a class="sourceLine" id="cb267-61" title="61">    <span class="dt">char</span> msg[MAX_BUF_SZ];</a>
<a class="sourceLine" id="cb267-62" title="62">    <span class="dt">int</span>  amnt = <span class="dv">0</span>, socket_desc;</a>
<a class="sourceLine" id="cb267-63" title="63"></a>
<a class="sourceLine" id="cb267-64" title="64">    socket_desc = domain_socket_client_create(filename);</a>
<a class="sourceLine" id="cb267-65" title="65">    <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb267-66" title="66">    printf(<span class="st">&quot;1. Client %d connected to server.</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid());</a>
<a class="sourceLine" id="cb267-67" title="67">    fflush(stdout);</a>
<a class="sourceLine" id="cb267-68" title="68"></a>
<a class="sourceLine" id="cb267-69" title="69">    snprintf(msg, MAX_BUF_SZ - <span class="dv">1</span>, <span class="st">&quot;Citizen %d: Penny for Pawsident!&quot;</span>, getpid());</a>
<a class="sourceLine" id="cb267-70" title="70">    amnt = write(socket_desc, msg, strlen(msg) + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb267-71" title="71">    <span class="cf">if</span> (amnt &lt; <span class="dv">0</span>) exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb267-72" title="72">    printf(<span class="st">&quot;2. Client %d request sent message to server.</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid());</a>
<a class="sourceLine" id="cb267-73" title="73">    fflush(stdout);</a>
<a class="sourceLine" id="cb267-74" title="74"></a>
<a class="sourceLine" id="cb267-75" title="75">    <span class="cf">if</span> (read(socket_desc, msg, amnt) &lt; <span class="dv">0</span>) exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb267-76" title="76">    msg[amnt] = &#39;\<span class="dv">0</span><span class="er">&#39;</span>;</a>
<a class="sourceLine" id="cb267-77" title="77">    printf(<span class="st">&quot;3. Client %d reply received from server: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid(), msg);</a>
<a class="sourceLine" id="cb267-78" title="78">    fflush(stdout);</a>
<a class="sourceLine" id="cb267-79" title="79"></a>
<a class="sourceLine" id="cb267-80" title="80">    close(socket_desc);</a>
<a class="sourceLine" id="cb267-81" title="81"></a>
<a class="sourceLine" id="cb267-82" title="82">    exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb267-83" title="83">}</a>
<a class="sourceLine" id="cb267-84" title="84"></a>
<a class="sourceLine" id="cb267-85" title="85"><span class="dt">int</span></a>
<a class="sourceLine" id="cb267-86" title="86">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb267-87" title="87">{</a>
<a class="sourceLine" id="cb267-88" title="88">    <span class="dt">char</span> *channel_name = <span class="st">&quot;pennys_channel&quot;</span>;</a>
<a class="sourceLine" id="cb267-89" title="89">    <span class="dt">int</span> nclients = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb267-90" title="90">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb267-91" title="91"></a>
<a class="sourceLine" id="cb267-92" title="92">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) server(nclients, channel_name);</a>
<a class="sourceLine" id="cb267-93" title="93">    <span class="co">/* wait for the server to create the domain socket */</span></a>
<a class="sourceLine" id="cb267-94" title="94">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb267-95" title="95">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; nclients; i++) {</a>
<a class="sourceLine" id="cb267-96" title="96">        <span class="cf">if</span> (fork() == <span class="dv">0</span>) client(channel_name);</a>
<a class="sourceLine" id="cb267-97" title="97">    }</a>
<a class="sourceLine" id="cb267-98" title="98">    <span class="co">/* wait for all of the children */</span></a>
<a class="sourceLine" id="cb267-99" title="99">    <span class="cf">while</span> (wait(NULL) != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb267-100" title="100"></a>
<a class="sourceLine" id="cb267-101" title="101">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb267-102" title="102">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Server: New client connected with new file descriptor 4.
1. Client 3499067 connected to server.
2. Client 3499067 request sent message to server.
Server received message (sz 38): &quot;Citizen 3499067: Penny for Pawsident!&quot;. Replying!
3. Client 3499067 reply received from server: Citizen 3499067: Penny for Pawsident!
Server: New client connected with new file descriptor 4.
1. Client 3499068 connected to server.
2. Client 3499068 request sent message to server.
Server received message (sz 38): &quot;Citizen 3499068: Penny for Pawsident!&quot;. Replying!
3. Client 3499068 reply received from server: Citizen 3499068: Penny for Pawsident!</code></pre>
<p>The server’s call to <code>accept</code> is the key difference of domain sockets from named pipes. It enables us to have per-client descriptors we can use to separately communicate (via <code>read</code>/<code>write</code>) to each client.</p>
<ul>
<li>✗ <strong>Transparent IPC.</strong> - We have to explicitly use the socket APIs.</li>
<li>✓ <strong>Named IPC.</strong> - Uses a file name to name the domain socket.</li>
<li>✓ <strong>Channel-based IPC.</strong> - When data is read, it is removed from the socket.</li>
<li>✓ <strong>Multi-client communication.</strong> - The server separates each client’s communication into separate descriptors.</li>
</ul>
<blockquote>
<p>Aside: Sockets are the main way to communicate over the network (i.e. to chat with the Internet). The APIs you’d use to create network sockets are the same, it simply requires setting up the <code>socket</code> and the <code>bind</code>ing of the socket in a network-specific manner.</p>
</blockquote>
<h2 id="ipc-exercises"><span class="header-section-number">10.6</span> IPC Exercises</h2>
<p>Find the programs:</p>
<ul>
<li><a href="https://github.com/gwu-cs-sysprog/lectures/blob/main/06/domain_socket_server.c"><code>06/domain_socket_server.c</code></a> - a sample server.</li>
<li><a href="https://github.com/gwu-cs-sysprog/lectures/blob/main/06/domain_socket_client.c"><code>06/domain_socket_client.c</code></a> - a sample client.</li>
</ul>
<p>Both require the <a href="https://github.com/gwu-cs-sysprog/lectures/blob/main/06/domain_sockets.h"><code>06/domain_sockets.h</code></a> header file. You <em>must</em> run the server first to create the domain socket “file”. If you run the server, and it complains that “server domain socket creation”, then you might need to <code>rm</code> the domain socket file on the command line first. It already exists from a previous run of the server, so the server cannot create it again!</p>
<p>Your job is to try to figure what in the hey these do! Answer the following questions:</p>
<ul>
<li>Describe what the server does to handle each client request.</li>
<li>How many clients can the server handle at a time?</li>
<li>Is the number of clients limited by the server <code>wait</code>ing on client/child processes? Recall when talking about background tasks in a shell that the <code>wait</code> is key to the system’s concurrency/behavior.</li>
<li>Describe what the client does. What data does it send to the server?</li>
<li>Describe the behavior when you use the client with the server.</li>
</ul>
<p>The programs can be compiled directly with <code>gcc</code> (e.g. <code>gcc domain_socket_server.c -o server; gcc domain_socket_client.c -o client</code>). Use these programs on the command line to send data from the client to server.</p>
<ul>
<li>How can you use the client and server programs to send data between them?</li>
<li>How can you make multiple clients connect to the server?</li>
</ul>
<h1 id="reinforcing-ideas-assorted-exercises-and-event-notification"><span class="header-section-number">11</span> Reinforcing Ideas: Assorted Exercises and Event Notification</h1>
<p>In the following, if you aren’t <em>positive</em> of the answer, please run the program! Note that we’re omitting error checking in these programs to keep them terse. Remember that in your programs, you must check and react to all errors. This will require you to use the <code>man</code> pages to look up the required <code>#include</code>s. If the output doesn’t match a high-level intuition, how would you modify the program to match the intuition? What are all of the potential output of the following programs? Why?</p>
<h3 id="fork-and-stream-behavior"><span class="header-section-number">11.0.1</span> <code>fork</code> and Stream Behavior</h3>
<div class="sourceCode" id="cb269"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb269-1" title="1">fork();</a>
<a class="sourceLine" id="cb269-2" title="2">fork();</a>
<a class="sourceLine" id="cb269-3" title="3">printf(<span class="st">&quot;z&quot;</span>);</a></code></pre></div>
<div class="sourceCode" id="cb270"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb270-1" title="1">printf(<span class="st">&quot;z&quot;</span>);</a>
<a class="sourceLine" id="cb270-2" title="2">fork();</a>
<a class="sourceLine" id="cb270-3" title="3">fork();</a></code></pre></div>
<div class="sourceCode" id="cb271"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb271-1" title="1">printf(<span class="st">&quot;z&quot;</span>);</a>
<a class="sourceLine" id="cb271-2" title="2">fork();</a>
<a class="sourceLine" id="cb271-3" title="3">write(STDOUT_FILENO, <span class="st">&quot;.&quot;</span>, <span class="dv">1</span>);</a></code></pre></div>
<h3 id="wait-behavior"><span class="header-section-number">11.0.2</span> Wait Behavior</h3>
<div class="sourceCode" id="cb272"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb272-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb272-2" title="2"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb272-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb272-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb272-5" title="5"></a>
<a class="sourceLine" id="cb272-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb272-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb272-8" title="8">{</a>
<a class="sourceLine" id="cb272-9" title="9">    pid_t child;</a>
<a class="sourceLine" id="cb272-10" title="10">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb272-11" title="11">    <span class="dt">int</span> wait_param = <span class="dv">0</span>;     <span class="co">/* or WNOHANG */</span></a>
<a class="sourceLine" id="cb272-12" title="12">    <span class="dt">int</span> output_w_write = <span class="dv">0</span>; <span class="co">/* or 1 */</span></a>
<a class="sourceLine" id="cb272-13" title="13"></a>
<a class="sourceLine" id="cb272-14" title="14">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++) {</a>
<a class="sourceLine" id="cb272-15" title="15">        child = fork();</a>
<a class="sourceLine" id="cb272-16" title="16">        <span class="cf">if</span> (child == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb272-17" title="17">            sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb272-18" title="18">            <span class="cf">if</span> (output_w_write) write(STDOUT_FILENO, <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb272-19" title="19">            <span class="cf">else</span>                printf(<span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb272-20" title="20">            exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb272-21" title="21">        }</a>
<a class="sourceLine" id="cb272-22" title="22">        waitpid(child, NULL, wait_param);</a>
<a class="sourceLine" id="cb272-23" title="23">        write(STDOUT_FILENO, <span class="st">&quot;Post-fork</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb272-24" title="24">    }</a>
<a class="sourceLine" id="cb272-25" title="25">    <span class="co">/* ...are we done here? */</span></a>
<a class="sourceLine" id="cb272-26" title="26"></a>
<a class="sourceLine" id="cb272-27" title="27">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb272-28" title="28">}</a></code></pre></div>
<ul>
<li>What if change <code>wait_param</code> to equal <code>WNOHANG</code>?</li>
<li>What if we change <code>output_w_write</code> to <code>1</code>?</li>
<li>Why do we need to reap children? Why would this actually matter?</li>
</ul>
<h3 id="read-behavior"><span class="header-section-number">11.0.3</span> <code>read</code> Behavior</h3>
<div class="sourceCode" id="cb273"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb273-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb273-2" title="2"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb273-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb273-4" title="4"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb273-5" title="5"></a>
<a class="sourceLine" id="cb273-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb273-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb273-8" title="8">{</a>
<a class="sourceLine" id="cb273-9" title="9">    pid_t child;</a>
<a class="sourceLine" id="cb273-10" title="10">    <span class="dt">int</span> fds[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb273-11" title="11">    <span class="dt">char</span> *msg = <span class="st">&quot;What type of doggo is Penny?</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb273-12" title="12"></a>
<a class="sourceLine" id="cb273-13" title="13">    pipe(fds);</a>
<a class="sourceLine" id="cb273-14" title="14"></a>
<a class="sourceLine" id="cb273-15" title="15">    <span class="cf">if</span> ((child = fork()) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb273-16" title="16">        <span class="co">/* recall: `cat` reads its stdin, and outputs it to stdout */</span></a>
<a class="sourceLine" id="cb273-17" title="17">        <span class="dt">char</span> *args[] = {<span class="st">&quot;cat&quot;</span>, NULL};</a>
<a class="sourceLine" id="cb273-18" title="18"></a>
<a class="sourceLine" id="cb273-19" title="19">        close(STDIN_FILENO);</a>
<a class="sourceLine" id="cb273-20" title="20">        dup2(fds[<span class="dv">0</span>], STDIN_FILENO);</a>
<a class="sourceLine" id="cb273-21" title="21">        execvp(args[<span class="dv">0</span>], args);</a>
<a class="sourceLine" id="cb273-22" title="22">    }</a>
<a class="sourceLine" id="cb273-23" title="23">    write(fds[<span class="dv">1</span>], msg, strlen(msg));</a>
<a class="sourceLine" id="cb273-24" title="24">    printf(<span class="st">&quot;100%% good girl.&quot;</span>);</a>
<a class="sourceLine" id="cb273-25" title="25">    wait(NULL);</a>
<a class="sourceLine" id="cb273-26" title="26"></a>
<a class="sourceLine" id="cb273-27" title="27">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb273-28" title="28">}</a></code></pre></div>
<ul>
<li>There are <em>multiple</em> bugs here. Find them and squish ’em.</li>
</ul>
<h3 id="signals-1"><span class="header-section-number">11.0.4</span> Signals</h3>
<p>What is the following doing?</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb274-1" title="1"><span class="pp">#include </span><span class="im">&lt;execinfo.h&gt;</span></a>
<a class="sourceLine" id="cb274-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb274-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb274-4" title="4"><span class="pp">#include </span><span class="im">&lt;signal.h&gt;</span><span class="pp"> </span><span class="co">/* sigaction and SIG* */</span></a>
<a class="sourceLine" id="cb274-5" title="5"></a>
<a class="sourceLine" id="cb274-6" title="6"><span class="dt">void</span></a>
<a class="sourceLine" id="cb274-7" title="7">bt(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb274-8" title="8">{</a>
<a class="sourceLine" id="cb274-9" title="9">    <span class="dt">void</span> *bt[<span class="dv">128</span>];</a>
<a class="sourceLine" id="cb274-10" title="10">    <span class="dt">char</span> **symbs;</a>
<a class="sourceLine" id="cb274-11" title="11">    <span class="dt">int</span> nfns, i;</a>
<a class="sourceLine" id="cb274-12" title="12"></a>
<a class="sourceLine" id="cb274-13" title="13">    nfns = backtrace(bt, <span class="dv">128</span>);</a>
<a class="sourceLine" id="cb274-14" title="14">    symbs = backtrace_symbols(bt, nfns);</a>
<a class="sourceLine" id="cb274-15" title="15">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; nfns; i++) {</a>
<a class="sourceLine" id="cb274-16" title="16">        printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, symbs[i]);</a>
<a class="sourceLine" id="cb274-17" title="17">    }</a>
<a class="sourceLine" id="cb274-18" title="18">    free(symbs);</a>
<a class="sourceLine" id="cb274-19" title="19">}</a>
<a class="sourceLine" id="cb274-20" title="20"></a>
<a class="sourceLine" id="cb274-21" title="21"><span class="dt">void</span></a>
<a class="sourceLine" id="cb274-22" title="22">bar(<span class="dt">int</span> *val)</a>
<a class="sourceLine" id="cb274-23" title="23">{</a>
<a class="sourceLine" id="cb274-24" title="24">    *val = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb274-25" title="25">    bt();</a>
<a class="sourceLine" id="cb274-26" title="26">}</a>
<a class="sourceLine" id="cb274-27" title="27"></a>
<a class="sourceLine" id="cb274-28" title="28"><span class="dt">void</span></a>
<a class="sourceLine" id="cb274-29" title="29">foo(<span class="dt">int</span> *val)</a>
<a class="sourceLine" id="cb274-30" title="30">{</a>
<a class="sourceLine" id="cb274-31" title="31">    bar(val);</a>
<a class="sourceLine" id="cb274-32" title="32">}</a>
<a class="sourceLine" id="cb274-33" title="33"></a>
<a class="sourceLine" id="cb274-34" title="34"><span class="dt">void</span></a>
<a class="sourceLine" id="cb274-35" title="35">sig_fault_handler(<span class="dt">int</span> signal_number, siginfo_t *info, <span class="dt">void</span> *context)</a>
<a class="sourceLine" id="cb274-36" title="36">{</a>
<a class="sourceLine" id="cb274-37" title="37">    printf(<span class="st">&quot;Fault triggered at address %p.</span><span class="sc">\n</span><span class="st">&quot;</span>, info-&gt;si_addr);</a>
<a class="sourceLine" id="cb274-38" title="38">    bt();</a>
<a class="sourceLine" id="cb274-39" title="39">    exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb274-40" title="40"></a>
<a class="sourceLine" id="cb274-41" title="41">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb274-42" title="42">}</a>
<a class="sourceLine" id="cb274-43" title="43"></a>
<a class="sourceLine" id="cb274-44" title="44"><span class="dt">int</span></a>
<a class="sourceLine" id="cb274-45" title="45">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb274-46" title="46">{</a>
<a class="sourceLine" id="cb274-47" title="47">    sigset_t masked;</a>
<a class="sourceLine" id="cb274-48" title="48">    <span class="kw">struct</span> sigaction siginfo;</a>
<a class="sourceLine" id="cb274-49" title="49">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb274-50" title="50">    <span class="dt">int</span> val;</a>
<a class="sourceLine" id="cb274-51" title="51"></a>
<a class="sourceLine" id="cb274-52" title="52">    sigemptyset(&amp;masked);</a>
<a class="sourceLine" id="cb274-53" title="53">    sigaddset(&amp;masked, SIGSEGV);</a>
<a class="sourceLine" id="cb274-54" title="54">    siginfo = (<span class="kw">struct</span> sigaction) {</a>
<a class="sourceLine" id="cb274-55" title="55">        .sa_sigaction = sig_fault_handler,</a>
<a class="sourceLine" id="cb274-56" title="56">        .sa_mask      = masked,</a>
<a class="sourceLine" id="cb274-57" title="57">        .sa_flags     = SA_RESTART | SA_SIGINFO <span class="co">/* we&#39;ll see this later */</span></a>
<a class="sourceLine" id="cb274-58" title="58">    };</a>
<a class="sourceLine" id="cb274-59" title="59"></a>
<a class="sourceLine" id="cb274-60" title="60">    <span class="cf">if</span> (sigaction(SIGSEGV, &amp;siginfo, NULL) == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb274-61" title="61">        perror(<span class="st">&quot;sigaction error&quot;</span>);</a>
<a class="sourceLine" id="cb274-62" title="62">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb274-63" title="63">    }</a>
<a class="sourceLine" id="cb274-64" title="64"></a>
<a class="sourceLine" id="cb274-65" title="65">    foo(&amp;val);</a>
<a class="sourceLine" id="cb274-66" title="66">    printf(<span class="st">&quot;---</span><span class="sc">\n</span><span class="st">Moving on...</span><span class="sc">\n</span><span class="st">---</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb274-67" title="67">    fflush(stdout);</a>
<a class="sourceLine" id="cb274-68" title="68">    foo(NULL);</a>
<a class="sourceLine" id="cb274-69" title="69"></a>
<a class="sourceLine" id="cb274-70" title="70">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb274-71" title="71">}</a></code></pre></div>
<ul>
<li>What are the various aspects of the output? What do the numbers mean? What do the strings mean?</li>
<li>Explain what is happening <em>before</em> the “Moving on…”.</li>
<li>Explain what is happening <em>after</em> the “Moving on…”.</li>
<li>There is a lot of information there (lines being output) that aren’t useful to the programmer. Make the output more useful by printing only the parts of the output that a programmer would find useful.</li>
</ul>
<h3 id="communication-with-multiple-clients"><span class="header-section-number">11.0.5</span> Communication with Multiple Clients</h3>
<p>Communicating with multiple clients is hard. Domain sockets are complicated, but there are challenges around blocking on <code>read</code>s. What if one client is very “slow”, and we block waiting for them?</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb275-1" title="1"><span class="pp">#include </span><span class="im">&quot;06/domain_sockets.h&quot;</span></a>
<a class="sourceLine" id="cb275-2" title="2"></a>
<a class="sourceLine" id="cb275-3" title="3"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb275-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb275-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb275-6" title="6"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb275-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb275-8" title="8"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb275-9" title="9"></a>
<a class="sourceLine" id="cb275-10" title="10"><span class="dt">void</span></a>
<a class="sourceLine" id="cb275-11" title="11">panic(<span class="dt">char</span> *msg)</a>
<a class="sourceLine" id="cb275-12" title="12">{</a>
<a class="sourceLine" id="cb275-13" title="13">    perror(msg);</a>
<a class="sourceLine" id="cb275-14" title="14">    exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb275-15" title="15">}</a>
<a class="sourceLine" id="cb275-16" title="16"></a>
<a class="sourceLine" id="cb275-17" title="17"><span class="dt">void</span></a>
<a class="sourceLine" id="cb275-18" title="18">client(<span class="dt">char</span> *filename, <span class="dt">int</span> slowdown)</a>
<a class="sourceLine" id="cb275-19" title="19">{</a>
<a class="sourceLine" id="cb275-20" title="20">    <span class="dt">int</span> i, socket_desc;</a>
<a class="sourceLine" id="cb275-21" title="21">    <span class="dt">char</span> b;</a>
<a class="sourceLine" id="cb275-22" title="22"></a>
<a class="sourceLine" id="cb275-23" title="23">    socket_desc = domain_socket_client_create(filename);</a>
<a class="sourceLine" id="cb275-24" title="24">    <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb275-25" title="25">        perror(<span class="st">&quot;domain socket client create&quot;</span>);</a>
<a class="sourceLine" id="cb275-26" title="26">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb275-27" title="27">    }</a>
<a class="sourceLine" id="cb275-28" title="28"></a>
<a class="sourceLine" id="cb275-29" title="29">    <span class="co">/* delay after creating connection, but before communicating */</span></a>
<a class="sourceLine" id="cb275-30" title="30">    sleep(slowdown);</a>
<a class="sourceLine" id="cb275-31" title="31">    <span class="cf">if</span> (write(socket_desc, <span class="st">&quot;.&quot;</span>, <span class="dv">1</span>) == -<span class="dv">1</span>) panic(<span class="st">&quot;client write&quot;</span>);</a>
<a class="sourceLine" id="cb275-32" title="32">    <span class="cf">if</span> (read(socket_desc, &amp;b, <span class="dv">1</span>) == -<span class="dv">1</span>)   panic(<span class="st">&quot;client read&quot;</span>);</a>
<a class="sourceLine" id="cb275-33" title="33">    printf(<span class="st">&quot;c: %c</span><span class="sc">\n</span><span class="st">&quot;</span>, b);</a>
<a class="sourceLine" id="cb275-34" title="34"></a>
<a class="sourceLine" id="cb275-35" title="35">    close(socket_desc);</a>
<a class="sourceLine" id="cb275-36" title="36">    exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb275-37" title="37">}</a>
<a class="sourceLine" id="cb275-38" title="38"></a>
<a class="sourceLine" id="cb275-39" title="39"><span class="dt">void</span></a>
<a class="sourceLine" id="cb275-40" title="40">client_slow(<span class="dt">char</span> *filename)</a>
<a class="sourceLine" id="cb275-41" title="41">{</a>
<a class="sourceLine" id="cb275-42" title="42">    client(filename, <span class="dv">3</span>);</a>
<a class="sourceLine" id="cb275-43" title="43">}</a>
<a class="sourceLine" id="cb275-44" title="44"></a>
<a class="sourceLine" id="cb275-45" title="45"><span class="dt">void</span></a>
<a class="sourceLine" id="cb275-46" title="46">client_fast(<span class="dt">char</span> *filename)</a>
<a class="sourceLine" id="cb275-47" title="47">{</a>
<a class="sourceLine" id="cb275-48" title="48">    client(filename, <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb275-49" title="49">}</a>
<a class="sourceLine" id="cb275-50" title="50"></a>
<a class="sourceLine" id="cb275-51" title="51"><span class="dt">int</span></a>
<a class="sourceLine" id="cb275-52" title="52">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb275-53" title="53">{</a>
<a class="sourceLine" id="cb275-54" title="54">    <span class="dt">char</span> *ds = <span class="st">&quot;domain_socket&quot;</span>;</a>
<a class="sourceLine" id="cb275-55" title="55">    <span class="dt">int</span> socket_desc, i;</a>
<a class="sourceLine" id="cb275-56" title="56"></a>
<a class="sourceLine" id="cb275-57" title="57">    socket_desc = domain_socket_server_create(ds);</a>
<a class="sourceLine" id="cb275-58" title="58">    <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb275-59" title="59">        <span class="co">/* remove the previous domain socket file if it exists */</span></a>
<a class="sourceLine" id="cb275-60" title="60">        unlink(ds);</a>
<a class="sourceLine" id="cb275-61" title="61">        socket_desc = domain_socket_server_create(ds);</a>
<a class="sourceLine" id="cb275-62" title="62">        <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) panic(<span class="st">&quot;server domain socket creation&quot;</span>);</a>
<a class="sourceLine" id="cb275-63" title="63">    }</a>
<a class="sourceLine" id="cb275-64" title="64"></a>
<a class="sourceLine" id="cb275-65" title="65">    <span class="co">/* </span><span class="al">TODO</span><span class="co">: change this order. What changes? */</span></a>
<a class="sourceLine" id="cb275-66" title="66">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) client_slow(ds);</a>
<a class="sourceLine" id="cb275-67" title="67">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) client_fast(ds);</a>
<a class="sourceLine" id="cb275-68" title="68"></a>
<a class="sourceLine" id="cb275-69" title="69">    <span class="co">/* handle two clients, one after the other */</span></a>
<a class="sourceLine" id="cb275-70" title="70">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; i++) {</a>
<a class="sourceLine" id="cb275-71" title="71">        <span class="dt">int</span> ret, new_client, i;</a>
<a class="sourceLine" id="cb275-72" title="72">        <span class="dt">char</span> b;</a>
<a class="sourceLine" id="cb275-73" title="73"></a>
<a class="sourceLine" id="cb275-74" title="74">        new_client = accept(socket_desc, NULL, NULL);</a>
<a class="sourceLine" id="cb275-75" title="75">        <span class="cf">if</span> (new_client == -<span class="dv">1</span>) panic(<span class="st">&quot;server accept&quot;</span>);</a>
<a class="sourceLine" id="cb275-76" title="76"></a>
<a class="sourceLine" id="cb275-77" title="77">        <span class="co">/* read from, then write to the client! */</span></a>
<a class="sourceLine" id="cb275-78" title="78">        <span class="cf">if</span> (read(new_client, &amp;b, <span class="dv">1</span>) == -<span class="dv">1</span>)   panic(<span class="st">&quot;server read&quot;</span>);</a>
<a class="sourceLine" id="cb275-79" title="79">        <span class="cf">if</span> (write(new_client, <span class="st">&quot;*&quot;</span>, <span class="dv">1</span>) == -<span class="dv">1</span>) panic(<span class="st">&quot;server write&quot;</span>);</a>
<a class="sourceLine" id="cb275-80" title="80">        close(new_client);</a>
<a class="sourceLine" id="cb275-81" title="81">    }</a>
<a class="sourceLine" id="cb275-82" title="82"></a>
<a class="sourceLine" id="cb275-83" title="83">    close(socket_desc);</a>
<a class="sourceLine" id="cb275-84" title="84">    <span class="co">/* reap all children */</span></a>
<a class="sourceLine" id="cb275-85" title="85">    <span class="cf">while</span> (wait(NULL) != -<span class="dv">1</span>) ;</a>
<a class="sourceLine" id="cb275-86" title="86"></a>
<a class="sourceLine" id="cb275-87" title="87">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb275-88" title="88">}</a></code></pre></div>
<ul>
<li>See the TODO in the <code>main</code>. When you change the order, what do you see?</li>
<li>Is there generally a problem when we use both fast and slow clients?</li>
</ul>
<h2 id="revisiting-ipc-with-multiple-clients"><span class="header-section-number">11.1</span> Revisiting IPC with Multiple Clients</h2>
<h3 id="system-services"><span class="header-section-number">11.1.1</span> System Services</h3>
<p>The <code>systemctl</code> command enables you to understand many of the services on the system (of which there are many: <code>systemctl --list-units | wc -l</code> yields <code>244</code> on my system).</p>
<pre><code>$ systemctl --list-units
...
  cups.service           loaded active     running   CUPS Scheduler
...
  gdm.service            loaded active     running   GNOME Display Manager
...
  ssh.service            loaded active     running   OpenBSD Secure Shell server
...
  NetworkManager.service loaded active     running   Network Manager
...
  openvpn.service        loaded active     exited    OpenVPN service
...</code></pre>
<p>I’ve pulled out a few selections that are easier to relate to:</p>
<ul>
<li>CUPS which is the service used to receive print jobs.</li>
<li><a href="https://en.wikipedia.org/wiki/GNOME_Display_Manager">GDM</a> which manages your <em>graphical logins</em> on Ubuntu.</li>
<li>OpenSSH which manages your <em>remote</em> logins through <code>ssh</code>.</li>
<li>NetworkManager that you interact with when you select which wifi hotspot to use.</li>
<li>OpenVPN which handles your VPN logins to the school network. You can see that the service is currently “exited” as I’m not running VPN now.</li>
</ul>
<p>Each of these services communicates with many clients using domain sockets.</p>
<h3 id="understanding-descriptor-events-with-poll"><span class="header-section-number">11.1.2</span> Understanding Descriptor Events with <code>poll</code></h3>
<p>Each of these services is a process that any client send requests to. We’ve seen that domain sockets can help us to talk to many different clients as each is represented with a separate file descriptor. How does the service process know <em>which of the file descriptors</em> has information available on it? Imagine the following case:</p>
<ol type="1">
<li>a client, <em>A</em>, connects to a service.</li>
<li>a client, <em>B</em>, connects to the same service.</li>
<li><em>B</em> immediately sends a request, while <em>A</em> goes into a <code>sleep(100)</code> (or, more realistically, simply does some expensive computation).</li>
</ol>
<p>If the server issues a <code>read</code> on the descriptor for <em>A</em>, it will block for 100 seconds! Worse, it won’t service <em>B</em> despite it making a request immediately. Why are we waiting for a slow client when there is a fast client with data already available? Yikes.</p>
<p>We’d really like a facility that can tell us <em>which</em> descriptor’s have data and are ready to be read from, and which are ready to be written to! Luckily, UNIX comes to the rescue with its <em>event notification</em> APIs. These are APIs that let us understand when a file descriptor has an <em>event</em> (i.e. a client writes to it) and is now readable or writable. These include three functions: <code>poll</code>, <code>select</code>, and (the more modern) <code>epoll</code>. Lets look at how to use <code>poll</code>!</p>
<h3 id="event-loops-and-poll"><span class="header-section-number">11.1.3</span> Event Loops and <code>poll</code></h3>
<p>Lets look at some pseudocode for using <code>poll</code>.</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb277-1" title="1">fdinfo[NUM_FDS] <span class="op">=</span> {</a>
<a class="sourceLine" id="cb277-2" title="2">    <span class="co"># initialized to all fds of interest, listening for read and write events</span></a>
<a class="sourceLine" id="cb277-3" title="3">}</a>
<a class="sourceLine" id="cb277-4" title="4"><span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb277-5" title="5">    poll(fdinfo, NUM_FDS, <span class="dv">-1</span>) <span class="co"># -1 = no timeout</span></a>
<a class="sourceLine" id="cb277-6" title="6">    <span class="cf">for</span> fdi <span class="kw">in</span> fdinfo:</a>
<a class="sourceLine" id="cb277-7" title="7">        <span class="co"># check and respond to each of the possible events</span></a>
<a class="sourceLine" id="cb277-8" title="8">        <span class="cf">if</span> fdi.revents <span class="op">&amp;</span> (POLLHUP <span class="op">|</span> POLLERR):</a>
<a class="sourceLine" id="cb277-9" title="9">            <span class="co"># process closed fds</span></a>
<a class="sourceLine" id="cb277-10" title="10">        <span class="cf">if</span> fdi.revents <span class="op">&amp;</span> POLLIN:</a>
<a class="sourceLine" id="cb277-11" title="11">            <span class="co"># read off of, or accept on the file desciptor</span></a>
<a class="sourceLine" id="cb277-12" title="12">        <span class="cf">if</span> fdi.revents <span class="op">&amp;</span> POLLOUT:</a>
<a class="sourceLine" id="cb277-13" title="13">            <span class="co"># write to the file desciptor</span></a></code></pre></div>
<p>This yields what is called an <em>event loop</em> – we loop, each time processing a single event. You see event loops in most GUIs (where each event is a key/mouse press), and in web programming where javascript callbacks are executed by the browser’s event loop. Importantly, <em>we only process descriptors that have events, thus can avoid blocking on descriptors that don’t have available data!</em> This solves our previous problem: a server won’t block awaiting communication with a client that is delayed, or never writes to a channel, instead only <code>read</code>ing/<code>write</code>ing to descriptors that are ready.</p>
<h3 id="poll-api"><span class="header-section-number">11.1.4</span> <code>poll</code> API</h3>
<ul>
<li><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout)</code> - We pass in an array of <code>struct pollfd</code>s of length <code>nfds</code>, with each entry corresponding to a single file descriptor we want to get information about. The <code>timeout</code> is in milliseconds, and enables <code>poll</code> to return after that amount of time returns even if none of the file descriptors has an event. A negative <code>timeout</code> is interpreted as “infinite”, while <code>0</code> means that <code>poll</code> will return immediately with any current events.</li>
</ul>
<p>Lets check out the <code>struct pollfd</code>:</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb278-1" title="1"><span class="kw">struct</span> pollfd {</a>
<a class="sourceLine" id="cb278-2" title="2">    <span class="dt">int</span>   fd;         <span class="co">/* file descriptor */</span></a>
<a class="sourceLine" id="cb278-3" title="3">    <span class="dt">short</span> events;     <span class="co">/* requested events */</span></a>
<a class="sourceLine" id="cb278-4" title="4">    <span class="dt">short</span> revents;    <span class="co">/* returned events */</span></a>
<a class="sourceLine" id="cb278-5" title="5">};</a></code></pre></div>
<p>When we make the <code>poll</code> call, we populate the <code>fd</code> and <code>events</code> fields with the file descriptors we’re interested in, and which events we’re interested in retrieving. <code>events</code> is a “bitmap” which means each bit in the value denotes a different type of event, and we bitwise <em>or</em> event types together when writing them into <code>events</code>. These event types include:</p>
<ul>
<li><code>POLLIN</code> - is there data available to be <code>read</code>? If the file descriptor is the domain socket that we use for <code>accept</code>, then this <code>POLLIN</code> means that a new client request is ready to <code>accept</code>.</li>
<li><code>POLLOUT</code> - is there data available to be <code>write</code>n?</li>
</ul>
<p>We can almost always set <code>events = POLLIN | POLLOUT</code> as we wait to wait for both.</p>
<p>When <code>poll</code> returns, we determine which events happened by looking at the contents of the <code>revents</code> field. In addition to <code>POLLIN</code> and <code>POLLOUT</code> which tell us if data is ready to be <code>read</code> or <code>written</code>, we have the following:</p>
<ul>
<li><code>POLLHUP</code> - The other side of the pipe closed its descriptor! Subsequent <code>read</code>s to the descriptor will return <code>0</code>. We can likely <code>close</code> our descriptor.</li>
<li><code>POLLERR</code> - Again, there was some sort of a problem with the descriptor, and we should likely <code>close</code> it, terminating communication.</li>
</ul>
<h3 id="example-poll-code"><span class="header-section-number">11.1.5</span> Example <code>poll</code> Code</h3>
<p>Lets put this all together. For simplicity, in this example, we’ll assume that we can always <code>write</code> to a descriptor without blocking. This isn’t generally true if you’re writing large amounts of data, and in “real code” you’d also want to handle <code>POLLOUT</code> appropriately.</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb279-1" title="1"><span class="pp">#include </span><span class="im">&quot;06/domain_sockets.h&quot;</span></a>
<a class="sourceLine" id="cb279-2" title="2"></a>
<a class="sourceLine" id="cb279-3" title="3"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb279-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb279-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb279-6" title="6"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb279-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb279-8" title="8"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb279-9" title="9"><span class="pp">#include </span><span class="im">&lt;poll.h&gt;</span></a>
<a class="sourceLine" id="cb279-10" title="10"></a>
<a class="sourceLine" id="cb279-11" title="11"><span class="dt">void</span></a>
<a class="sourceLine" id="cb279-12" title="12">panic(<span class="dt">char</span> *msg)</a>
<a class="sourceLine" id="cb279-13" title="13">{</a>
<a class="sourceLine" id="cb279-14" title="14">    perror(msg);</a>
<a class="sourceLine" id="cb279-15" title="15">    exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb279-16" title="16">}</a>
<a class="sourceLine" id="cb279-17" title="17"></a>
<a class="sourceLine" id="cb279-18" title="18"><span class="dt">void</span></a>
<a class="sourceLine" id="cb279-19" title="19">client(<span class="dt">char</span> *filename)</a>
<a class="sourceLine" id="cb279-20" title="20">{</a>
<a class="sourceLine" id="cb279-21" title="21">    <span class="dt">int</span> i, socket_desc;</a>
<a class="sourceLine" id="cb279-22" title="22"></a>
<a class="sourceLine" id="cb279-23" title="23">    sleep(<span class="dv">1</span>); <span class="co">/* await the domain socket creation by the server */</span></a>
<a class="sourceLine" id="cb279-24" title="24">    socket_desc = domain_socket_client_create(filename);</a>
<a class="sourceLine" id="cb279-25" title="25">    <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb279-26" title="26">        perror(<span class="st">&quot;domain socket client create&quot;</span>);</a>
<a class="sourceLine" id="cb279-27" title="27">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb279-28" title="28">    }</a>
<a class="sourceLine" id="cb279-29" title="29"></a>
<a class="sourceLine" id="cb279-30" title="30">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++) {</a>
<a class="sourceLine" id="cb279-31" title="31">        <span class="dt">char</span> b;</a>
<a class="sourceLine" id="cb279-32" title="32">        <span class="cf">if</span> (write(socket_desc, <span class="st">&quot;.&quot;</span>, <span class="dv">1</span>) == -<span class="dv">1</span>) panic(<span class="st">&quot;client write&quot;</span>);</a>
<a class="sourceLine" id="cb279-33" title="33">        <span class="cf">if</span> (read(socket_desc, &amp;b, <span class="dv">1</span>) == -<span class="dv">1</span>)   panic(<span class="st">&quot;client read&quot;</span>);</a>
<a class="sourceLine" id="cb279-34" title="34">        printf(<span class="st">&quot;c %d: %c</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid(), b);</a>
<a class="sourceLine" id="cb279-35" title="35">    }</a>
<a class="sourceLine" id="cb279-36" title="36"></a>
<a class="sourceLine" id="cb279-37" title="37">    close(socket_desc);</a>
<a class="sourceLine" id="cb279-38" title="38">    exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb279-39" title="39">}</a>
<a class="sourceLine" id="cb279-40" title="40"></a>
<a class="sourceLine" id="cb279-41" title="41"><span class="co">/* we can track max 16 fds */</span></a>
<a class="sourceLine" id="cb279-42" title="42"><span class="pp">#define MAX_FDS 16</span></a>
<a class="sourceLine" id="cb279-43" title="43"></a>
<a class="sourceLine" id="cb279-44" title="44"><span class="dt">void</span></a>
<a class="sourceLine" id="cb279-45" title="45">server(<span class="dt">char</span> *filename)</a>
<a class="sourceLine" id="cb279-46" title="46">{</a>
<a class="sourceLine" id="cb279-47" title="47">    <span class="dt">int</span> socket_desc, num_fds = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb279-48" title="48">    <span class="kw">struct</span> pollfd poll_fds[MAX_FDS];</a>
<a class="sourceLine" id="cb279-49" title="49"></a>
<a class="sourceLine" id="cb279-50" title="50">    <span class="co">/*** Initialize the domain socket and its pollfd ***/</span></a>
<a class="sourceLine" id="cb279-51" title="51">    socket_desc = domain_socket_server_create(filename);</a>
<a class="sourceLine" id="cb279-52" title="52">    <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb279-53" title="53">        unlink(filename); <span class="co">/* remove the previous domain socket file if it exists */</span></a>
<a class="sourceLine" id="cb279-54" title="54">        socket_desc = domain_socket_server_create(filename);</a>
<a class="sourceLine" id="cb279-55" title="55">        <span class="cf">if</span> (socket_desc &lt; <span class="dv">0</span>) panic(<span class="st">&quot;server domain socket creation&quot;</span>);</a>
<a class="sourceLine" id="cb279-56" title="56">    }</a>
<a class="sourceLine" id="cb279-57" title="57"></a>
<a class="sourceLine" id="cb279-58" title="58">    <span class="co">/* Initialize all pollfd structs to 0 */</span></a>
<a class="sourceLine" id="cb279-59" title="59">    memset(poll_fds, <span class="dv">0</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> pollfd) * MAX_FDS);</a>
<a class="sourceLine" id="cb279-60" title="60">    poll_fds[<span class="dv">0</span>] = (<span class="kw">struct</span> pollfd) {</a>
<a class="sourceLine" id="cb279-61" title="61">        .fd     = socket_desc,</a>
<a class="sourceLine" id="cb279-62" title="62">        .events = POLLIN,</a>
<a class="sourceLine" id="cb279-63" title="63">    };</a>
<a class="sourceLine" id="cb279-64" title="64">    num_fds++;</a>
<a class="sourceLine" id="cb279-65" title="65"></a>
<a class="sourceLine" id="cb279-66" title="66">    <span class="co">/*** The event loop ***/</span></a>
<a class="sourceLine" id="cb279-67" title="67">    <span class="cf">while</span> (<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb279-68" title="68">        <span class="dt">int</span> ret, new_client, i;</a>
<a class="sourceLine" id="cb279-69" title="69"></a>
<a class="sourceLine" id="cb279-70" title="70">        <span class="co">/*** Poll; if we don&#39;t get a client for a second, exit ***/</span></a>
<a class="sourceLine" id="cb279-71" title="71">        ret = poll(poll_fds, num_fds, <span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb279-72" title="72">        <span class="cf">if</span> (ret == -<span class="dv">1</span>) panic(<span class="st">&quot;poll error&quot;</span>);</a>
<a class="sourceLine" id="cb279-73" title="73">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb279-74" title="74"><span class="co">         * If we timeout, break out of the loop.</span></a>
<a class="sourceLine" id="cb279-75" title="75"><span class="co">         * This isn&#39;t what you&#39;d normally do as servers stick around!</span></a>
<a class="sourceLine" id="cb279-76" title="76"><span class="co">         */</span></a>
<a class="sourceLine" id="cb279-77" title="77">        <span class="cf">if</span> (ret == <span class="dv">0</span>) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb279-78" title="78"></a>
<a class="sourceLine" id="cb279-79" title="79">        <span class="co">/*** Accept file descriptor has a new client connecting! ***/</span></a>
<a class="sourceLine" id="cb279-80" title="80">        <span class="cf">if</span> (poll_fds[<span class="dv">0</span>].revents &amp; POLLIN) {</a>
<a class="sourceLine" id="cb279-81" title="81">            <span class="cf">if</span> ((new_client = accept(socket_desc, NULL, NULL)) == -<span class="dv">1</span>) panic(<span class="st">&quot;server accept&quot;</span>);</a>
<a class="sourceLine" id="cb279-82" title="82">            <span class="co">/* add a new file descriptor! */</span></a>
<a class="sourceLine" id="cb279-83" title="83">            poll_fds[num_fds] = (<span class="kw">struct</span> pollfd) {</a>
<a class="sourceLine" id="cb279-84" title="84">                .fd = new_client,</a>
<a class="sourceLine" id="cb279-85" title="85">                .events = POLLIN</a>
<a class="sourceLine" id="cb279-86" title="86">            };</a>
<a class="sourceLine" id="cb279-87" title="87">            num_fds++;</a>
<a class="sourceLine" id="cb279-88" title="88">            poll_fds[<span class="dv">0</span>].revents = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb279-89" title="89">            printf(<span class="st">&quot;server: created client connection %d</span><span class="sc">\n</span><span class="st">&quot;</span>, new_client);</a>
<a class="sourceLine" id="cb279-90" title="90">        }</a>
<a class="sourceLine" id="cb279-91" title="91">        <span class="co">/*** Communicate with clients! ***/</span></a>
<a class="sourceLine" id="cb279-92" title="92">        <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt; num_fds; i++) {</a>
<a class="sourceLine" id="cb279-93" title="93">            <span class="cf">if</span> (poll_fds[i].revents &amp; (POLLHUP | POLLERR)) {</a>
<a class="sourceLine" id="cb279-94" title="94">                printf(<span class="st">&quot;server: closing client connection %d</span><span class="sc">\n</span><span class="st">&quot;</span>, poll_fds[i].fd);</a>
<a class="sourceLine" id="cb279-95" title="95">                poll_fds[i].revents = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb279-96" title="96">                close(poll_fds[i].fd);</a>
<a class="sourceLine" id="cb279-97" title="97">                <span class="co">/* replace the fd to fill the gap */</span></a>
<a class="sourceLine" id="cb279-98" title="98">                poll_fds[i] = poll_fds[num_fds - <span class="dv">1</span>];</a>
<a class="sourceLine" id="cb279-99" title="99">                num_fds--;</a>
<a class="sourceLine" id="cb279-100" title="100">                <span class="co">/* make sure to check the fd we used to fill the gap */</span></a>
<a class="sourceLine" id="cb279-101" title="101">                i--;</a>
<a class="sourceLine" id="cb279-102" title="102"></a>
<a class="sourceLine" id="cb279-103" title="103">                <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb279-104" title="104">            }</a>
<a class="sourceLine" id="cb279-105" title="105">            <span class="cf">if</span> (poll_fds[i].revents &amp; POLLIN) {</a>
<a class="sourceLine" id="cb279-106" title="106">                <span class="dt">char</span> b;</a>
<a class="sourceLine" id="cb279-107" title="107"></a>
<a class="sourceLine" id="cb279-108" title="108">                poll_fds[i].revents = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb279-109" title="109">                <span class="co">/* our server is simply sending a &#39;*&#39; for each input character */</span></a>
<a class="sourceLine" id="cb279-110" title="110">                <span class="cf">if</span> (read(poll_fds[i].fd, &amp;b, <span class="dv">1</span>) == -<span class="dv">1</span>) panic(<span class="st">&quot;server read&quot;</span>);</a>
<a class="sourceLine" id="cb279-111" title="111">                <span class="cf">if</span> (write(poll_fds[i].fd, <span class="st">&quot;*&quot;</span>, <span class="dv">1</span>) == -<span class="dv">1</span>) panic(<span class="st">&quot;server write&quot;</span>);</a>
<a class="sourceLine" id="cb279-112" title="112">            }</a>
<a class="sourceLine" id="cb279-113" title="113">        }</a>
<a class="sourceLine" id="cb279-114" title="114">    }</a>
<a class="sourceLine" id="cb279-115" title="115">    close(socket_desc);</a>
<a class="sourceLine" id="cb279-116" title="116"></a>
<a class="sourceLine" id="cb279-117" title="117">    exit(EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb279-118" title="118">}</a>
<a class="sourceLine" id="cb279-119" title="119"></a>
<a class="sourceLine" id="cb279-120" title="120"><span class="dt">int</span></a>
<a class="sourceLine" id="cb279-121" title="121">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb279-122" title="122">{</a>
<a class="sourceLine" id="cb279-123" title="123">    <span class="dt">char</span> *ds = <span class="st">&quot;domain_socket&quot;</span>;</a>
<a class="sourceLine" id="cb279-124" title="124"></a>
<a class="sourceLine" id="cb279-125" title="125">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) client(ds);</a>
<a class="sourceLine" id="cb279-126" title="126">    <span class="cf">if</span> (fork() == <span class="dv">0</span>) client(ds);</a>
<a class="sourceLine" id="cb279-127" title="127">    server(ds);</a>
<a class="sourceLine" id="cb279-128" title="128"></a>
<a class="sourceLine" id="cb279-129" title="129">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb279-130" title="130">}</a></code></pre></div>
<h1 id="libraries"><span class="header-section-number">12</span> Libraries</h1>
<p>Up till now, we’ve been focusing on UNIX programming APIs, and how to interact with various aspects of the system. Part of this discussion has been how various programs can be orchestrated to cooperate. Pipelines enable larger functionalities to be composed out of multiple programs in which the output of one goes to the input of the next. System servers provide services to clients that use IPC to harness their functionality. This enables servers that control system resources (like wifi) to let many clients have limited and controlled access to those resources.</p>
<p>The next few chapters dive under the hood of processes. We’ll investigate</p>
<ol type="1">
<li>how programs are represented and how to understand their format,</li>
<li>how programs are organized and can share code, and</li>
<li>how they interact with the system.</li>
</ol>
<p>How do we think about our system’s programs? We’re used to writing our own programs, and like to think of the code we write being relatively self-contained. In contrast, quite a bit of <em>system programming</em> is about providing functionality that can be used by <em>any program on the system</em>. What if you wanted to implement the world’s best key-value store, and wanted to enable anyone to use your implementation!?</p>
<p>We think of these <em>shared</em> functionalities as falling into one of two categories:</p>
<ol type="1">
<li><em>Libraries</em> that represent bodies of code that can be pull into our applications. You’re already quite used to these! <code>libc</code> is the core library that provides all of the functions that we use when we include many of the headers in the class, for example, <code>#include &lt;stdlib.h&gt;</code>, <code>#include &lt;stdio.h&gt;</code>, or <code>#include &lt;string.h&gt;</code>.</li>
<li><em>Services</em> which track different aspects of the system, and provide information to our programs. They tend to be programs that are always running on your system, and your programs can communicate with them to harness their functionality. These include services that receive print requests, that service <code>ssh</code> sessions, that provide your <code>vpn</code> connection, and that display your graphical user interface, and many other functions. We’ve already seen many of the IPC and communication foundations that make these tick.</li>
</ol>
<p>This chapter, we’ll focus on libraries as a foundation for sharing software in systems.</p>
<h2 id="libraries---goals-and-overview"><span class="header-section-number">12.1</span> Libraries - Goals and Overview</h2>
<p>Before we start, consider:</p>
<ul>
<li>When you <code>#include</code> a ton of files, do you think that all of the related functionality is compiled into your program? That would mean that <em>every</em> program has the functionality compiled into it.</li>
<li>If so, how much memory and disk space do you think that will take?</li>
<li>Do you think there are other options? What might they be?</li>
</ul>
<p>Visually, this is what it would look like to compile with “libraries” that are defined as normal <code>*.o</code> files.</p>
<figure>
<img src="figures/08_naivelib.svg" alt="We know how to generate *.o files, and to combine them together as shown here. If some other people’s code that we depend on (e.g. string.h functionality) is provided as *.o files, we could compile with it as such. The questions above should let you think about the trade-offs with this approach." /><figcaption>We know how to generate <code>*.o</code> files, and to combine them together as shown here. If some other people’s code that we depend on (e.g. <code>string.h</code> functionality) is provided as <code>*.o</code> files, we could compile with it as such. The questions above should let you think about the trade-offs with this approach.</figcaption>
</figure>
<p>The <em>goals</em> of libraries are to:</p>
<ul>
<li>Enable programs to leverage shared implementations of specific functionality (e.g. the contents of <code>string.h</code>).</li>
<li>Provide a uniform set of programming APIs to programs.</li>
<li>Attempt to save memory by making all programs in the system as small as possible by not taking memory for all of the library code in each program.</li>
<li>Enable the system to upgrade both libraries and programs (for example, if a security compromise is found).</li>
</ul>
<p>Libraries are collections of functionality that can be used by many different programs. They are code that expand the functionality of programs. This differs from services which are separate programs. Libraries have two core components that mirror what we understand about C:</p>
<ol type="1">
<li><em>header files</em> that share the types of the library API functions and data, and</li>
<li>the <em>code to implement</em> those APIs.</li>
</ol>
<p>Lets set up some visual nomenclature.</p>
<figure>
<img src="figures/08_libfiles.svg" alt="We’ll talk about the files that are part of your normal programs (the *.c and *.o on the left), those that are part of the library, and files to represent the library." /><figcaption>We’ll talk about the files that are part of your normal programs (the <code>*.c</code> and <code>*.o</code> on the left), those that are part of the library, and files to represent the library.</figcaption>
</figure>
<p>There are two main ways library code is integrated into programs:</p>
<ul>
<li><strong>Static libraries.</strong> These are added into your program <em>when you compile it</em>.</li>
<li><strong>Shared or dynamic libraries.</strong> These are integrated into your program, dynamically, <em>when you run the program</em>.</li>
</ul>
<p>We’ll discuss each of these in subsequent sections</p>
<h2 id="libraries---header-files"><span class="header-section-number">12.2</span> Libraries - Header Files</h2>
<p>We can see most of the header files in <code>/usr/include</code>, within which you’ll find some familiar files:</p>
<pre><code>$ ls /usr/include/std*
/usr/include/stdc-predef.h  /usr/include/stdint.h  /usr/include/stdio_ext.h  /usr/include/stdio.h  /usr/include/stdlib.h</code></pre>
<p>Yes, this means that you have the source code for much of the standard library at your fingertips! But how does <code>gcc</code> know to find all of these files when we use <code>#include &lt;...&gt;</code>? The following <code>gcc</code> incantation gives us a good idea:</p>
<pre><code>$ gcc -xc -E -v -
...
#include &lt;...&gt; search starts here:
 /usr/lib/gcc/x86_64-linux-gnu/9/include
 /usr/local/include
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
</code></pre>
<p>These are all of the “include paths” that are searched, by default, when we do an <code>#include &lt;&gt;</code>.</p>
<blockquote>
<p>Aside: In <code>Makefiles</code>, we often want to add to tell the compiler to look for header files in our own files Thus, we update the include paths by adding multiple <code>-I&lt;dir&gt;</code> options to the <code>gcc</code> command line. We can see how this works:</p>
<pre><code>$ gcc -I. -xc -E -v -
...
#include &lt;...&gt; search starts here:
.
/usr/lib/gcc/x86_64-linux-gnu/9/include
...</code></pre>
<p>The include paths are searched in order, so you can see that when we explicitly tell <code>gcc</code> to include a directory <code>-I.</code> here, we’re asking to to check in the current directory (<code>.</code>) first.</p>
</blockquote>
<h2 id="linking-undefined-symbols-to-references-across-objects"><span class="header-section-number">12.3</span> Linking Undefined Symbols to References Across Objects</h2>
<p>Before we proceed to figure out how multiple <code>*.o</code> <em>objects</em> are combined into an executable, lets learn what it means for one object to depend on another for some functionality. To understand this, we have to understand how object files (<code>*.o</code>) and binaries think about symbols and linking them together.</p>
<p>When your program uses a library’s API, the library’s code is <em>linked</em> into your program. Linking is the act of taking any symbols that are referenced, but not defined in your object (<code>*.o</code>) files, and the definition of those symbols in the objects that provide them. A <em>symbol</em> is a functions or global variable in your program. Each symbol has a representation in your object files so that they can be referenced across objects. We have to understanding the linking operation to dive into how libraries can be added into, thus accessible from your program. Lets peek into how our objects think about the world using a number of programs that can introspect on the objects including <code>nm</code>, <code>objdump</code>, and <code>readelf</code>.</p>
<p>As an example, lets look at your <code>ptrie</code> implementation. We know that each of the tests (in <code>tests/0?-*.c</code>) depends on your ptrie implementation in <code>ptrie.c</code>. What does that look like?</p>
<pre><code>$ nm tests/01-add.o
                 U _GLOBAL_OFFSET_TABLE_
000000000000022a T main
                 U printf
                 U ptrie_add
                 U ptrie_allocate
                 U ptrie_free
                 U __stack_chk_fail
0000000000000000 t sunit_execute
0000000000000000 d test
0000000000000184 T test_add
0000000000000144 T test_alloc</code></pre>
<p>The left column is the address of the symbol, and the character in the middle column gives us some information about the symbol:</p>
<ul>
<li><code>T</code> - this symbol is part of the code of the <code>*.o</code> file, and is visible outside of the object (i.e. it isn’t <code>static</code>). Capital letters mean that the symbol is visible outside the object which simply means it can be linked with another object.</li>
<li><code>t</code> - this symbol is part of the code, but is <em>not visible</em> outside of the object (it is <code>static</code>).</li>
<li><code>D</code> - a global variable that is visible.</li>
<li><code>d</code> - a global variable that is not visible.</li>
<li><code>U</code> - an <em>undefined symbol</em> that must be provided by another object file.</li>
</ul>
<p>For other symbol types, see <code>man nm</code>.</p>
<p>We can see what we’d expect: the test defines its own functions for (e.g. <code>main</code>, <code>test_add</code>), but requires the <code>ptrie_*</code> functions and <code>printf</code> to be provided by another object file. Now lets check out the <code>ptrie</code> objects.</p>
<pre><code>$nm ptrie.o
...
                 U calloc
                 U free
...
                 U printf
00000000000005ae T ptrie_add
00000000000003fc t ptrie_add_internal
0000000000000016 T ptrie_allocate
0000000000000606 T ptrie_autocomplete
00000000000000f8 T ptrie_free
...
                 U putchar
                 U puts
                 U strcmp
                 U strdup
                 U strlen</code></pre>
<p>We can see that the <code>ptrie.o</code> object depends on other objects for all of the functions we’re using from <code>stdio.h</code>, <code>stdlib.h</code>, and <code>string.h</code>, provides all of the functions that are part of the public API (e.g. <code>ptrie_add</code>), and some other symbols (e.g. <code>ptrie_add_internal</code>) that <em>cannot be linked</em> to other object files.</p>
<p>After we link the <code>ptrie</code> into the test (with <code>gcc ... tests/01_add.o ptrie.o -o tests/01_add.test</code>),</p>
<pre><code>$ nm tests/01_add.test | grep alloc
                 U calloc@@GLIBC_2.2.5
0000000000001566 T ptrie_allocate
00000000000013ad T test_alloc</code></pre>
<p>Now we can see that there are no longer any undefined references (<code>U</code>) to <code>ptrie_allocate</code>, so the test object has now found that symbol within the <code>ptrie.o</code> object. Additionally, we can see that some symbols (e.g. <code>calloc</code> here) are still undefined and have some mysterious <code>@@...</code> information associated with them. You might guess that this somehow tells us that the function should be provided by the standard C library (<code>glibc</code> on Ubuntu).</p>
<p>Lets see another example visually using the <code>libexample/*</code> files:</p>
<figure>
<img src="figures/08_objectsymbs.svg" alt="The program on the left depends on the functionality of the object on the right, the library. We can see from the nm output that the left has undefined symbols for bar which is defined in the library. On the right, we can see the symbols defined in the object (with T, saying it is part of the text, or code, i.e. a function). Both are compiled together into an executable binary, prog_naive which shows that the reference from prog.o is resolved or linked with the definition in example.o." /><figcaption>The program on the left depends on the functionality of the object on the right, the library. We can see from the <code>nm</code> output that the left has undefined symbols for <code>bar</code> which is defined in the library. On the right, we can see the symbols defined in the object (with <code>T</code>, saying it is part of the text, or code, i.e. a function). Both are compiled together into an executable binary, <code>prog_naive</code> which shows that the reference from <code>prog.o</code> is <em>resolved</em> or linked with the definition in <code>example.o</code>.</figcaption>
</figure>
<p><em>Where are we?</em> OK, lets summarize so far. Objects can have <em>undefined symbol references</em> that get <em>linked</em> to the symbols when combined with the objects in which they are defined. How is this linking implemented?</p>
<p><strong>Question: What does a file <em>format</em> mean?</strong> <strong>We talk about the format of webpages being <code>html</code>, images, being <code>png</code>, documents being <code>docx</code> or <code>pdf</code>.</strong> <strong>What do these formats mean?</strong> <strong>What is the format of object and executable binaries?</strong></p>
<h3 id="elf-object-format"><span class="header-section-number">12.3.1</span> ELF Object Format</h3>
<p>First, we have to understand something that is a little <em>amazing</em>: all of our objects and binaries have a defined file format called the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format</a> (ELF)<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a>.</p>
<figure>
<img src="figures/elf.png" alt="A representation of the ELF binary program format by Ange_Albertini." /><figcaption>A representation of the ELF binary program format by <a href="https://github.com/corkami/pics">Ange_Albertini</a>.</figcaption>
</figure>
<p>We can confirm that these files are ELF with</p>
<pre><code>$ xxd ptrie.o | head -n 1
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............</code></pre>
<p><code>xxd</code> dumps out a file in hexadecimal format, and <code>head</code> just lets us filter out only the first line (i.e. at the head). The first characters in most formats often denote the <em>type</em> of file, in this case an ELF file.</p>
<p>This reveals a cool truth: <strong>programs are data</strong>, plain and simple. They happen to be data of a very specific format, ELF. <code>nm</code>, <code>readelf</code>, and <code>objdump</code> are all programs that simply understand how to dive into the ELF format, parse, and display the information.</p>
<p>As programs are simply data encapsulated in the ELF format, we can start to understand what it means to <em>link</em> two objects together.</p>
<figure>
<img src="figures/08_linking.svg" alt="An example demonstrating what it means to link two objects together. In this case, we can see the ELF object tells us where in the prog.o binary the reference to bar is, and gcc patchs up prog.o as part of linking to reference bar in example.o." /><figcaption>An example demonstrating what it means to <em>link</em> two objects together. In this case, we can see the ELF object tells us where in the <code>prog.o</code> binary the reference to <code>bar</code> is, and gcc patchs up <code>prog.o</code> as part of linking to reference <code>bar</code> in <code>example.o</code>.</figcaption>
</figure>
<p>An in-depth explanation follows. Now we get to an interesting part of the ELF objects:</p>
<pre><code>$ readelf -r tests/01_add.o | grep ptrie
000000000151  001500000004 R_X86_64_PLT32    0000000000000000 ptrie_allocate - 4
000000000179  001600000004 R_X86_64_PLT32    0000000000000000 ptrie_free - 4
000000000191  001500000004 R_X86_64_PLT32    0000000000000000 ptrie_allocate - 4
0000000001dd  001800000004 R_X86_64_PLT32    0000000000000000 ptrie_add - 4
00000000021f  001600000004 R_X86_64_PLT32    0000000000000000 ptrie_free - 4</code></pre>
<p>The <code>-r</code> flag here outputs the “relocation” entries of the elf object.</p>
<p>This output says that there are number of references to the <code>ptrie_*</code> functions in the code, and enumerates each of them. You can imagine that these are simply all of the places in the code that these functions are called. The first column gives us the offset into the ELF object where the reference to the function is made – in this case where it is called. For example, at the offset <code>0x151</code><a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a> into the ELF object, we have a call to <code>ptrie_allocate</code>. This is important because the <code>tests/01_add.o</code> does not know where the <code>ptrie_allocate</code> function is yet. It will only know that when it links with the <code>ptrie</code> implementation!</p>
<p>Lets check out what this looks like in the ELF object’s code. For this, we’ll use <code>objdump</code>’s ability to dump out the “assembly code” for the object file. It also will try and print out the C code that corresponds to the assembly, which is pretty cool.</p>
<pre><code>$ objdump -S tests/01_add.o
...
sunit_ret_t
test_alloc(void)
{
 144:   f3 0f 1e fa             endbr64
 148:   55                      push   %rbp
 149:   48 89 e5                mov    %rsp,%rbp
 14c:   48 83 ec 10             sub    $0x10,%rsp
    struct ptrie *pt;

    pt = ptrie_allocate();
 150:   e8 00 00 00 00          callq  155 &lt;test_alloc+0x11&gt;
 155:   48 89 45 f0             mov    %rax,-0x10(%rbp)
...</code></pre>
<p>I’ve printed out the addresses in the object around offset <code>0x151</code> because the first reference to <code>ptrie_allocate</code> is made there (see <code>readelf</code> output above). We can see an instruction to <code>call</code> <code>test_alloc</code>. However, you can see that the address that the binary has for that function is <code>00 00 00 00</code>, or <code>NULL</code>! This is what it means for a function to be undefined (recall: the <code>nm</code> output for the symbol is <code>U</code>).</p>
<p>Now we can understand what a <em>linker</em>’s job is:</p>
<blockquote>
<p><strong>What does a Linker do?</strong> A linker takes all of the undefined <em>references</em> to symbols from the <em>relocation records</em>, and rewrites the binary to populate those references with the address of that symbol (here updating <code>00 00 00 00</code> to the actual address of <code>test_alloc</code>).</p>
</blockquote>
<p>In our <code>Makefile</code>s, we always use <code>gcc</code> both for compiling <code>*.c</code> files into objects, but also linking objects together into a binary.</p>
<h3 id="linking-summary"><span class="header-section-number">12.3.2</span> Linking Summary</h3>
<p>Lets back up and collect our thoughts.</p>
<ul>
<li>Our programs are collections of a number of ELF object files.</li>
<li>We’ve seen that some symbols in an object file are <em>undefined</em> if they are functions or variables that are not defined in a <code>.c</code> file.</li>
<li>Though their types are defined in header files, their implementation must be found somewhere.</li>
<li>Each reference to an undefined symbol has a <em>relation entry</em> that enables the linker to update the reference once it knows the ELF object that provides it.</li>
<li>When another ELF exports the symbol that is undefined elsewhere, they can be <em>linked</em> to turn the function calls of undefined functions into function calls, and references to global variables be actual pointers to memory.</li>
</ul>
<p>This is the <em>foundation for creating large programs out of small pieces</em>, and to enable some of those pieces to be <em>shared between programs</em>.</p>
<p>We’ll also see that libraries enable an opportunity to <em>save memory</em>. For example,</p>
<ul>
<li>static libraries enable only the object files that are needed by a program to be compiled into it, and</li>
<li>dynamic libraries enable the code for a library to be <em>shared</em> between all processes that execute it in the system.</li>
</ul>
<h2 id="static-libraries"><span class="header-section-number">12.4</span> Static Libraries</h2>
<p>A static library is simply a collection of ELF object (<code>*.o</code>) files created with <code>gcc -c</code>. They are collected together into a static library file that has the name <code>lib*.a</code>. You can think of these files as a <code>.zip</code> or <code>.tar</code> file containing the ELF objects.</p>
<p>Static libraries of the form <code>lib*.a</code> and are created with the <code>ar</code> (archive) program from a collection of objects. An example from the <code>ptrie</code> library (expanded from its <code>Makefile</code>) that creates <code>libptrie.a</code>:</p>
<pre><code>$ ar -crs libptrie.a *.o</code></pre>
<p>So a static library is just a collection of ELF objects created by our compilation process. If we are writing a program that wants to <em>use</em> a library, first you make sure to include its header file(s). Then, when compiling, we have to tell the compiler which library we want to link with by using a few compiler flags:</p>
<pre><code>$ gcc -o tests/01_add.test 01_add.o -L. -lptrie</code></pre>
<p>The last two flags are the relevant ones:</p>
<ul>
<li><code>-L.</code> says “look for static libraries in the current directory (i.e. <code>.</code>)” – other directories can be included, and a few default directories are used, and</li>
<li><code>-lptrie</code> says “please link me with the <code>ptrie</code> library” which should be found in one of the given directories and is found in a file called <code>libptrie.a</code>.</li>
</ul>
<p>Note that the linker already searches a few directories for libraries (i.e. default <code>-L</code> paths):</p>
<pre><code>$ gcc -print-search-dirs | grep libraries | sed &#39;s/libraries: =//&#39; | tr -s &quot;:&quot; &#39;\n&#39;
/usr/lib/gcc/x86_64-linux-gnu/9/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/9/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/lib/../lib/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/9/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib/
/lib/x86_64-linux-gnu/9/
/lib/x86_64-linux-gnu/
/lib/../lib/
/usr/lib/x86_64-linux-gnu/9/
/usr/lib/x86_64-linux-gnu/
/usr/lib/../lib/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/lib/
/usr/lib/gcc/x86_64-linux-gnu/9/../../../
/lib/
/usr/lib/</code></pre>
<p>As many of these paths are in directories that any user can access, this is how the functionality of these libraries can be accessed by any program wishing to use them. As we compile our <code>ptrie</code> library as a static library, you’ve already seen one example of these in use.</p>
<figure>
<img src="figures/08_staticlib.svg" alt="How static libraries are created, and interact with our programs. The .a files include all library objects, but only those that are needed by the program are compiled into it.x" /><figcaption>How static libraries are created, and interact with our programs. The <code>.a</code> files include all library objects, but only those that are needed by the program are compiled into it.x</figcaption>
</figure>
<h3 id="saving-memory-with-static-libraries"><span class="header-section-number">12.4.1</span> Saving Memory with Static Libraries</h3>
<p>Static libraries do provide some facilities for trying to shrink the amount of memory required for library code. If this was all done naively, then all of the object files in a static library could get loaded into a program with which it is linked. This means that for <span class="math inline"><em>N</em></span> programs that link with a library whose objects take <span class="math inline"><em>X</em></span> bytes, we’ll have <span class="math inline"><em>N</em> × <em>X</em></span> bytes devoted to storing programs on disk, and running the programs in memory (if they all run at the same time). Some static libraries can be quite large.</p>
<p>Instead, static libraries are smarter. If a static library contains multiple <code>.o</code> files, <em>only those object files that define symbols that are undefined in the program being linked with, are compiled into the program</em>. This means that when designing a static library, you often want to break it into multiple <code>.o</code> files along the lines of different functionalities that separately used by different programs<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a>.</p>
<figure>
<img src="figures/08_staticmem.svg" alt="A graphical depiction of how library memory gets added into a program using static libraries. The program is only dependent on a single object within the library, so we only need to compile that object into the resulting executable program." /><figcaption>A graphical depiction of how library memory gets added into a program using static libraries. The program is only dependent on a single object within the library, so we only need to compile that object into the resulting executable program.</figcaption>
</figure>
<p>Some projects take this quite far. For example <a href="https://www.musl-libc.org/">musl libc</a> is a libc replacement, and it separates almost every single function into a separate object file (i.e. in a separate <code>.c</code> file!) so that only the exact functions that are called are linked into the program.</p>
<h2 id="shareddynamic-libraries"><span class="header-section-number">12.5</span> Shared/Dynamic Libraries</h2>
<p>Shared or dynamic libraries (for brevity, I’ll call them only “dynamic libraries”, but both terms are commonly used) are linked into a program <em>at runtime</em> when the program starts executing as part of <code>exec</code>.</p>
<p>Recall that even executable binaries might still have undefined references to symbols. For example, see <code>calloc</code> in the example below:</p>
<pre><code>$ nm tests/01_add.test | grep calloc
                 U calloc@@GLIBC_2.2.5</code></pre>
<p>Though we can execute the program <code>tests/01_add.test</code>, it has references to functions that don’t exist in the program! How can we possibly execute a program that has undefined functions; won’t the calls to <code>calloc</code> here be <code>NULL</code> pointer dereferences?</p>
<p>To understand how dynamic linking works, lets look at the output of a program that tells us about dynamic library dependencies, <code>ldd</code>.</p>
<pre><code>$ ldd tests/01_add.test
        linux-vdso.so.1 (0x00007ffff3734000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb502adf000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fb502cfa000)</code></pre>
<p><code>ldd</code> also simply parses through the ELF program, and determines which dynamic libraries are required by the program. For now, we’ll ignore the <code>linux-vdso</code>, but the other two entries are interesting. We can see that the C standard library, <code>libc</code> is being provided by <code>/lib/x86_64-linux-gnu/libc.so.6</code>. These are both dynamic libraries, as are most <code>*.so.?*</code> and <code>*.so</code> files. If we check out that object we see that it provides <code>calloc</code>.</p>
<pre><code>$ objdump -T /lib/x86_64-linux-gnu/libc.so.6  | grep calloc
000000000009ec90 g    DF .text  0000000000000395  GLIBC_2.2.5 __libc_calloc
000000000009ec90  w   DF .text  0000000000000395  GLIBC_2.2.5 calloc</code></pre>
<p>So this library provides the symbols we require (i.e. the <code>calloc</code> function)!</p>
<h3 id="compiling-and-executing-with-dynamic-libraries"><span class="header-section-number">12.5.1</span> Compiling and Executing with Dynamic Libraries</h3>
<p>If we want our program to use a dynamic library, we have to compile it quite similarly to when we wanted to use static libraries:</p>
<pre><code>$ gcc -o dyn_prog *.o -L. -lptrie</code></pre>
<p>So everything is somewhat normal here; we’re saying “look for the library in this directory”, and compile me with the <code>ptrie</code> library. To create the dynamic library:</p>
<pre><code>$ gcc -Wall -Wextra -fpic -I. -c -o ptrie.o ptrie.c
$ gcc -shared -o libptrie.so ptrie.o</code></pre>
<p>The first line is the normal way to create an object file from C, but includes a new flag, <code>-fpic</code>. This tells the compiler to generate <a href="https://en.wikipedia.org/wiki/Position-independent_code">“Position Independent Code”, or PIC</a>, which is code that can, seemingly magically, be executed when the code is loaded into any address! The dynamic library cannot assume which addresses it will be loaded into as many dynamic libraries might be loaded into an executable, thus the PIC requirement.</p>
<p>The second line creates the dynamic (shared) library. By convention, all dynamic libraries end with <code>.so</code> which you can think of as “shared object”. This is the line that is dynamic-library equivalent to the <code>ar</code> command for static libraries.</p>
<p>Now we have a binary that has been told were the library is; lets execute it!</p>
<pre><code>$ ./dyn_prog
./dyn_prog: error while loading shared libraries: libptrie.so: cannot open shared object file: No such file or directory</code></pre>
<p>Whaaaaaa? If we dive in a little bit, we can see:</p>
<pre><code>$ nm ./dyn_prog | grep ptrie_alloc
                 U ptrie_alloc</code></pre>
<p>But I thought that we wanted all symbols to be defined when we create a binary? Why is the library’s <code>ptrie_alloc</code> not linked into the program? We can see that not all symbols are defined in a program when we are using dynamic libraries as they are <em>linked when we try and run the program</em>!</p>
<p>We now can see the main practical difference between static and dynamic libraries:</p>
<ul>
<li>Static libraries are compiled into the program when you compile with the <code>-lptrie</code> directive.</li>
<li>Dynamic libraries not <em>not</em> compiled into the program, and are instead <em>linked</em> into the program when it is executed (i.e. at the time of <code>exec</code>).</li>
</ul>
<p>We can start to see why the program wont execute when we look at its dynamic library dependencies:</p>
<pre><code>$ ldd ./dyn_prog
        linux-vdso.so.1 (0x00007ffdf3ca0000)
        libptrie.so =&gt; not found
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff9921e8000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ff9923f8000)</code></pre>
<p>It isn’t finding <code>libptrie.so</code>!</p>
<p>To execute the program, we have to properly set an <em>environment variable</em> that will tell the program, when it is executed, where to look for the dynamic library:</p>
<pre><code>$ LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH ./dyn_prog
...success...</code></pre>
<p>This is some strange shell syntax. <code>LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH</code> essentially says "The environment variable called <code>LD_LIBRARY_PATH</code> should be updated to prepend the diretory <code>./</code> onto the front of it. This is conceptually similar to something like <code>lib_path = "./:" + lib_path</code> in a language that supports string concatenation. When <code>./dyn_prog</code> is executed, the updated <code>LD_LIBRARY_PATH</code> environment variable is visible in that program using the normal <code>getenv</code>. So there is some part of the initialization of <code>./dyn_prog</code> that looks at this environment variable to figure out where to look for the dynamic library.</p>
<p>To confirm why we can now execute the program, we can again look at the library dependencies:</p>
<pre><code>$ LD_LIBRARY_PATH=./:$LD_LIBRARY_PATH ldd prog_dynamic
        linux-vdso.so.1 (0x00007ffc939f8000)
        libptrie.so =&gt; ./libptrie.so (0x00007f70d316f000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f70d2f66000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f70d3236000)</code></pre>
<p>If we expand the <code>LD_LIBRARY_PATH</code> to include the current directory, the program can find the library.</p>
<p>If we want to see the <a href="https://stackoverflow.com/questions/9922949/how-to-print-the-ldlinker-search-path">default paths</a> that are searched for dynamic libraries:</p>
<pre><code>$ ldconfig -v 2&gt;/dev/null | grep -v ^$&#39;\t&#39;
/usr/local/lib:
/lib/x86_64-linux-gnu:
/lib32:
/libx32:
/lib:</code></pre>
<p>In fact, <code>ldconfig -v</code> will also print out all of the potential default dynamic libraries we can link with.</p>
<figure>
<img src="figures/08_dynamiclib.svg" alt="Using dynamic libraries to compile a program. Additional flags are required when compiling the library files (for PIC), and we must tell the system that the library is dynamic when compiling using the -shared flag. But even then, the executable doesn’t have the library functionality linked into it. Only when we execute the program does ld dynamically link in the library. For ld to know where to look for te library, we also have to tell it additional paths in which to look using an environment variable." /><figcaption>Using dynamic libraries to compile a program. Additional flags are required when compiling the library files (for PIC), and we must tell the system that the library is dynamic when compiling using the <code>-shared</code> flag. But even then, the executable doesn’t have the library functionality linked into it. Only when we execute the program does <code>ld</code> dynamically link in the library. For <code>ld</code> to know where to look for te library, we also have to tell it additional paths in which to look using an environment variable.</figcaption>
</figure>
<h3 id="exec-with-dynamic-linking"><span class="header-section-number">12.5.2</span> <code>exec</code> with Dynamic Linking</h3>
<p>How does the <code>libc.so</code> library get linked into our program? Diving in a little bit further, we see that <code>ld</code> is our program’s “interpreter”:</p>
<pre><code>$ readelf --program-headers tests/01_add.test
Elf file type is DYN (Shared object file)
Entry point 0x1180
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000008e8 0x00000000000008e8  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x0000000000000e55 0x0000000000000e55  R E    0x1000
...</code></pre>
<p>A lot is going on here, but we see the reference to <code>ld-linux-x86-64.so.2</code> that we saw previously in the <code>ldd</code> output. We can now see that the library (that I’ll call simply <code>ld</code>) is a “program interpreter” (see “<code>Requesting program interpreter: /lib64/ld-linux-x86-64.so.2</code>”) for our program<a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a>. This is the core of understanding how our program can execute while having undefined references to functions provided by another library.</p>
<p>When we call <code>exec</code>, we believe that the program we execute takes over the current process and starts executing. This is not true! Instead, if a program interpreter is defined for our program (as we see: it is), the interpreter program’s memory is loaded along side our program, but then the interpreter is executed instead of our program! It is given access to our program’s ELF object, and <code>ld</code>’s job is to finish linking and loading our program. We have to add <code>./</code> to the <code>LD_LIBRARY_PATH</code> to make the program execute because <strong><code>ld</code> reads that environment variable when it is trying to link and load in your program</strong>!</p>
<h3 id="diving-into-dynamic-linking-at-exec"><span class="header-section-number">12.5.3</span> Diving into Dynamic Linking at <code>exec</code></h3>
<p>But wait. Why does <code>exec</code> end up loading <code>ld</code>, which then loads our program? Why load <code>ld</code> to link our program instead of just running our program? Because <code>ld</code> <em>also</em> loads and links all of the dynamic libraries (<code>.so</code>s) that our program depends on!!!</p>
<p>We can confirm that <code>ld</code> is loaded into our program by executing it in <code>gdb</code>, blocking it on breakpoint, and outputting its memory maps (<code>cat /proc/262648/maps</code> on my system):</p>
<pre><code>555555554000-555555555000 r--p 00000000 08:02 527420                     /home/gparmer/repos/gwu-cs-sysprog/22/hw_solns/02/tests/01_add.test
555555555000-555555556000 r-xp 00001000 08:02 527420                     /home/gparmer/repos/gwu-cs-sysprog/22/hw_solns/02/tests/01_add.test
555555556000-555555557000 r--p 00002000 08:02 527420                     /home/gparmer/repos/gwu-cs-sysprog/22/hw_solns/02/tests/01_add.test
555555557000-555555558000 r--p 00002000 08:02 527420                     /home/gparmer/repos/gwu-cs-sysprog/22/hw_solns/02/tests/01_add.test
555555558000-555555559000 rw-p 00003000 08:02 527420                     /home/gparmer/repos/gwu-cs-sysprog/22/hw_solns/02/tests/01_add.test
7ffff7dbe000-7ffff7de3000 r--p 00000000 08:02 2235639                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
7ffff7de3000-7ffff7f5b000 r-xp 00025000 08:02 2235639                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
7ffff7f5b000-7ffff7fa5000 r--p 0019d000 08:02 2235639                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
7ffff7fa5000-7ffff7fa6000 ---p 001e7000 08:02 2235639                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
7ffff7fa6000-7ffff7fa9000 r--p 001e7000 08:02 2235639                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
7ffff7fa9000-7ffff7fac000 rw-p 001ea000 08:02 2235639                    /usr/lib/x86_64-linux-gnu/libc-2.31.so
7ffff7fac000-7ffff7fb2000 rw-p 00000000 00:00 0
7ffff7fc9000-7ffff7fcd000 r--p 00000000 00:00 0                          [vvar]
7ffff7fcd000-7ffff7fcf000 r-xp 00000000 00:00 0                          [vdso]
7ffff7fcf000-7ffff7fd0000 r--p 00000000 08:02 2235423                    /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7fd0000-7ffff7ff3000 r-xp 00001000 08:02 2235423                    /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7ff3000-7ffff7ffb000 r--p 00024000 08:02 2235423                    /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7ffc000-7ffff7ffd000 r--p 0002c000 08:02 2235423                    /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7ffd000-7ffff7ffe000 rw-p 0002d000 08:02 2235423                    /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0
7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</code></pre>
<p>Recall that this dumps all of the memory segments of the process.</p>
<p>There are two important observations:</p>
<ul>
<li><code>/usr/lib/x86_64-linux-gnu/libc-2.31.so</code> is present in the process so somehow got linked and loaded into the process.</li>
<li><code>/usr/lib/x86_64-linux-gnu/ld-2.31.so</code> is also present in the process; indeed it was the first code to execute in the process!</li>
</ul>
<h3 id="dynamic-loading-summary"><span class="header-section-number">12.5.4</span> Dynamic Loading Summary</h3>
<p>Lets summarize the algorithm for executing a dynamically loaded program.</p>
<ol type="1">
<li><code>exec</code> is called to execute a new program.</li>
<li>The program’s ELF file is parsed, and if a “program interpreter” is set, the interpreter is instead executed.</li>
<li>In most cases, the interpreter is <code>ld</code>, and it is loaded into the process along with the target program.</li>
<li><p>Execution is started at <code>ld</code>, and it:</p>
<ol type="1">
<li>Loads all of the dynamic libraries required by the program, looking at the <code>LD_LIBRARY_PATH</code> environment variable to help look for them.</li>
<li>Links the program such that all of its references to library symbols (i.e. <code>calloc</code> above) are set to point to library functions.</li>
<li>Executes the initialization procedures (and eventually <code>main</code>) of our program.</li>
</ol></li>
</ol>
<p>This is all quite complex. Why would we ever want all of this complexity over the simplicity of static libraries?</p>
<h3 id="saving-memory-with-dynamic-libraries"><span class="header-section-number">12.5.5</span> Saving Memory with Dynamic Libraries</h3>
<p>First, lets look at how much memory a library takes up.</p>
<pre><code>$ ls -lh /usr/lib/x86_64-linux-gnu/libc-2.31.so
-rwxr-xr-x 1 root root 2.0M Dec 16  2020 /usr/lib/x86_64-linux-gnu/libc-2.31.so</code></pre>
<p>So <code>libc</code> takes around 2MiB. Other libraries take quite a bit more:</p>
<ul>
<li>Graphics card drivers (e.g. <code>libradeonsi_dri.so</code> is 23 MiB)</li>
<li>Databases clients (e.g. <code>libmysqlclient.so</code> is 7.2 MiB)</li>
<li>Languages (e.g. firefox’s javascript engine, <code>libmozjs.so</code> is 11 MiB, and webkit’s <code>libjavascriptcoregtk.so</code> is 26 MiB)</li>
<li>…</li>
</ul>
<p>If <span class="math inline"><em>N</em></span> programs must load in multiple libraries (totaling, say, <span class="math inline"><em>X</em></span> MiB), then <span class="math inline"><em>N</em> × <em>X</em></span> MiB is consumed. For context, my system is currently running 269 programs (<code>ps aux | wc -l</code>), so this memory can add up!</p>
<p>Dynamic libraries enable us to do a lot better. The contents memory for the library is the same regardless the process it is present in, and an Operating System has a neat trick: it can make the same memory appear in multiple processes if it is identical <em>and</em> cannot be modified<a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a>. As such, dynamic libraries typically only require memory for each library <em>once</em> in the system (only <span class="math inline"><em>X</em></span>), as opposed for each process.</p>
<figure>
<img src="figures/08_dynamicmem.svg" alt="A graphical depiction of how library memory gets added into a program using dynamic libraries. The libraries are only linked into the processes when they are executed. When that happens, the same memory for the library is mmaped into each process, thus the system only requires memory for a single copy of the library." /><figcaption>A graphical depiction of how library memory gets added into a program using dynamic libraries. The libraries are only linked into the processes when they are executed. When that happens, the same memory for the library is <code>mmap</code>ed into each process, thus the system only requires memory for a <em>single</em> copy of the library.</figcaption>
</figure>
<h2 id="static-vs.-dynamic-library-memory-usage-summary"><span class="header-section-number">12.6</span> Static vs. Dynamic Library Memory Usage Summary</h2>
<p>When a program is linked with a static library, the result is relatively small as only the objects in the library that are necessary are linked into the program. When executed as a process, the memory consumed will only include the necessary objects of the library. In contrast, a program that uses a dynamic library links in the entire library at runtime into a process. Thus, for a <em>single process</em>, a static library approach is almost always going to be more memory-efficient.</p>
<p>However, in a system with <em>many</em> executing processes, the per-library memory, rather than per-process memory, will result in significantly less memory consumption. Requiring only a <em>single copy</em> of a <em>larger</em> dynamic library shared between all processes, uses less memory than <em>multiple copies</em> of <em>smaller</em> compilations of the library in each program.</p>
<h1 id="organizing-software-with-dynamic-libraries-exercises-and-programming"><span class="header-section-number">13</span> Organizing Software with Dynamic Libraries: Exercises and Programming</h1>
<p>Lets dive a little deeper into how software is structured on our system, and the trade-offs that different libraries make in the system.</p>
<h2 id="exercise-understanding-library-memory-consumption"><span class="header-section-number">13.1</span> Exercise: Understanding Library Memory Consumption</h2>
<p>Lets investigate the <code>libexample</code> from the figures in last week’s lectures. See the <a href="https://github.com/gwu-cs-sysprog/lectures/tree/main/08/libexample"><code>08/libexample/</code> directory</a> for examples of using normal linking (<code>make naive</code>), static library linking (<code>make static</code>), and dynamic library linking (<code>make dynamic</code>). The source includes:</p>
<ul>
<li><code>prog</code> and <code>prog2</code> that are programs that use libraries.</li>
<li><code>example.c</code> is a single file that creates the first library which generates <code>libexample.a</code> and <code>libexample.so</code>.</li>
<li><code>example2.c</code> and <code>example2b.c</code> are the files that create the second library which generates <code>libexample2.a</code> and <code>libexample2.so</code>.</li>
</ul>
<p>Each of the library objects uses around <em>750KB</em> of memory. To help you set the <code>LD_LIBRARY_PATH</code> to execute the dynamic libraries, you can run the dynamic library examples using</p>
<pre><code>$ ./run_dyn.sh ./prog_dynamic</code></pre>
<ol type="1">
<li>Use <code>nm</code> and <code>ldd</code> to understand which libraries and object files within those libraries each of the programs require.</li>
<li>Use <code>ls -lh</code> to see the size of each of the resulting executable programs. Explain the differences in sizes.</li>
</ol>
<h2 id="library-trade-offs"><span class="header-section-number">13.2</span> Library Trade-offs</h2>
<ul>
<li><em>Question:</em> What types of systems might want to always use only static libraries?</li>
<li><em>Question:</em> What types of systems might want to always use only dynamic libraries?</li>
<li><em>Question:</em> OSX uses dynamically linked libraries for a few common and frequently used libraries (like <code>libc</code>), and static libraries for the rest. Why?</li>
</ul>
<h2 id="programming-dynamic-libraries"><span class="header-section-number">13.3</span> Programming Dynamic Libraries</h2>
<p>We saw how libraries enable the sharing of functionality between programs. Static libraries are convenient, and only required objects are linked with your program at compile time. In contrast, dynamic libraries are linked at runtime <em>before</em> the <code>main</code> of your program executes.</p>
<h3 id="plugins-and-dynamic-library-apis"><span class="header-section-number">13.3.1</span> Plugins and Dynamic Library APIs</h3>
<p>In addition to enabling shared library code, dynamic libraries also enable explicit means to load libraries programmatically. Namely, UNIX provdes an API that enables your process to <em>load</em> a dynamic library into itself. This is kinda crazy: a running process with a set of code and data can add a library with more code and data into itself dynamically. This effectively means that your program can change its own code as it executes by adding and removing dynamic libraries. Being able to load library code into your process as your program executes (at runtime) is an instance of <em>self-modifying code</em>, and it enables a few very cool features including:</p>
<ul>
<li><em>dynamic update of services</em> in which new versions of key computations in a service can be dynamically loaded in (and old versions eventually removed),</li>
<li><em>plugin architectures</em> enable different interesting functionalities to be loaded into a process to provide unique functionalities – some of the most popular image and video processing programs (e.g. <code>ffmpeg</code>) enable different formats to be handled with separate dynamic libraries, thus enabling the processing of any image or video by simply loading a new library, and</li>
<li><em>languages</em>, such as <code>python</code>, dynamically load libraries (many or most are written in C) into a process when the python code <code>import</code>s them. Since the <code>import</code>s are part of the code, the corresponding dynamic libraries must be loaded by the python runtime dynamically. This enables your dynamic (slow) python code to load and leverage fast C libraries.</li>
</ul>
<figure>
<img src="figures/09_dl_uses.svg" alt="Example programmatic uses of dynamic libraries." /><figcaption>Example programmatic uses of dynamic libraries.</figcaption>
</figure>
<p>This API is provided by the linker (<code>ld.so</code>) that loaded the elf object for the currently executing process. What does the API that enables this dynamic loading look like?</p>
<ul>
<li><code>handle = dlopen(file_path, flags)</code> - Open and load in a dynamic library. This returns a handle to the library that you should pass into the latter functions. You can read about the <code>flags</code> in <code>man dlopen</code>. Unless otherwise noted, I’d recommend using <code>RTLD_NOW | RTLD_LOCAL</code><a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>. Returns <code>NULL</code> if it cannot find the dynamic library.</li>
<li><code>dlclose(handle)</code> - Close and unload a library that was previously loaded.</li>
<li><code>symb_ptr = dlsym(handle, symbol)</code> - pass in a <code>symbol</code> which is a string holding a function or variable name in the dynamic library. It should return a pointer to that symbol, which you can then call (if it is a function pointer), or dereference if it is a variable.</li>
</ul>
<div class="sourceCode" id="cb307"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb307-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb307-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb307-3" title="3"><span class="pp">#include </span><span class="im">&lt;dlfcn.h&gt;</span></a>
<a class="sourceLine" id="cb307-4" title="4"></a>
<a class="sourceLine" id="cb307-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb307-6" title="6">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb307-7" title="7">{</a>
<a class="sourceLine" id="cb307-8" title="8">    <span class="dt">void</span> *handle;</a>
<a class="sourceLine" id="cb307-9" title="9">    <span class="kw">typedef</span> <span class="dt">int</span> *(*bar_fn_t)(<span class="dt">int</span> a);</a>
<a class="sourceLine" id="cb307-10" title="10">    bar_fn_t bar;</a>
<a class="sourceLine" id="cb307-11" title="11">    <span class="dt">int</span> *ret;</a>
<a class="sourceLine" id="cb307-12" title="12"></a>
<a class="sourceLine" id="cb307-13" title="13">    <span class="co">/* Open a dynamic library: the example is in ../08/libexample/ */</span></a>
<a class="sourceLine" id="cb307-14" title="14">    handle = dlopen(<span class="st">&quot;08/libexample/libexample.so&quot;</span>, RTLD_NOW | RTLD_LOCAL);</a>
<a class="sourceLine" id="cb307-15" title="15">    <span class="cf">if</span> (!handle) <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb307-16" title="16"></a>
<a class="sourceLine" id="cb307-17" title="17">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb307-18" title="18"><span class="co">     * Lets find the function &quot;bar&quot; in that dynamic library.</span></a>
<a class="sourceLine" id="cb307-19" title="19"><span class="co">     * We know that `bar` is the function: int *bar(int a)</span></a>
<a class="sourceLine" id="cb307-20" title="20"><span class="co">     */</span></a>
<a class="sourceLine" id="cb307-21" title="21">    bar = dlsym(handle, <span class="st">&quot;bar&quot;</span>);</a>
<a class="sourceLine" id="cb307-22" title="22">    <span class="cf">if</span> (!bar) <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb307-23" title="23"></a>
<a class="sourceLine" id="cb307-24" title="24">    <span class="co">/* bar allocates an int, populates it with the argument + 2 and returns it */</span></a>
<a class="sourceLine" id="cb307-25" title="25">    ret = bar(<span class="dv">40</span>);</a>
<a class="sourceLine" id="cb307-26" title="26">    printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, *ret);</a>
<a class="sourceLine" id="cb307-27" title="27">    free(ret);</a>
<a class="sourceLine" id="cb307-28" title="28"></a>
<a class="sourceLine" id="cb307-29" title="29">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb307-30" title="30">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>42</code></pre>
<p>As <code>dlsym</code> returns a pointer to the symbol passed in (as a string), it means that you end up seeing a <em>lot</em> of function pointers when you’re using plugin infrastructures. See (a) in the image below.</p>
<p>We can also use <code>dlsym</code> to ask for a symbol in <em>any of the installed libraries</em>. To do so, we pass in the “special pseudo-handles” <code>RTLD_DEFAULT</code> or <code>RTLD_NEXT</code>.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb309-1" title="1"><span class="pp">#define _GNU_SOURCE </span><span class="co">/* added this due to `man 3 dlsym` */</span></a>
<a class="sourceLine" id="cb309-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb309-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb309-4" title="4"><span class="pp">#include </span><span class="im">&lt;dlfcn.h&gt;</span></a>
<a class="sourceLine" id="cb309-5" title="5"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb309-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb309-7" title="7"></a>
<a class="sourceLine" id="cb309-8" title="8"><span class="dt">int</span></a>
<a class="sourceLine" id="cb309-9" title="9">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb309-10" title="10">{</a>
<a class="sourceLine" id="cb309-11" title="11">    <span class="kw">typedef</span> <span class="dt">int</span> (*write_fn_t)(<span class="dt">int</span> fd, <span class="dt">char</span> *buf, <span class="dt">size_t</span> s);</a>
<a class="sourceLine" id="cb309-12" title="12">    write_fn_t w;</a>
<a class="sourceLine" id="cb309-13" title="13">    <span class="dt">char</span> *buf = <span class="st">&quot;Look at me! Diving into your dynamic libraries...pulling out the symbols</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb309-14" title="14"></a>
<a class="sourceLine" id="cb309-15" title="15">    <span class="co">/* Now lets find `write`! */</span></a>
<a class="sourceLine" id="cb309-16" title="16">    w = dlsym(RTLD_DEFAULT, <span class="st">&quot;write&quot;</span>);</a>
<a class="sourceLine" id="cb309-17" title="17">    <span class="cf">if</span> (!w) <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb309-18" title="18">    w(STDOUT_FILENO, buf, strlen(buf));</a>
<a class="sourceLine" id="cb309-19" title="19"></a>
<a class="sourceLine" id="cb309-20" title="20">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb309-21" title="21">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>Look at me! Diving into your dynamic libraries...pulling out the symbols</code></pre>
<p>Though this example doesn’t have much of a point, as we can directly call <code>write</code>, thus have to go through the symbol we retrieved from <code>dlsym</code>, See (b) in the image below.</p>
<figure>
<img src="figures/09_dl_api.svg" alt="Three programmatic means to interact with dynamic libraries." /><figcaption>Three programmatic means to interact with dynamic libraries.</figcaption>
</figure>
<h3 id="interposing-libraries-on-library-apis"><span class="header-section-number">13.3.2</span> Interposing Libraries on Library APIs</h3>
<p>One powerful mechanism that dynamic libraries enable is to <em>interpose</em> on library function calls. Your program might believe that it calls <code>malloc</code> when it invokes the function “malloc”, but you can orchestrate it so that it instead calls a <code>malloc</code> in your library! You can then, if you choose, invoke the normal library calls, thus why this is known as <em>interposing</em> on the library calls. But how?</p>
<p>The environment variable <code>LD_PRELOAD</code> can be used to specify a dynamic library to load into the process to <em>interpose</em> on any library calls. A trivial use of this might be to <em>log</em> (i.e. write out to a file) all of a set of library calls. We’ll use it to add intelligence on the memory allocation paths.</p>
<p>When we use <code>LD_PRELOAD=lib</code>, the symbols in the dynamic library that we specify in <code>lib</code> have priority over those of other libraries. Thus, if we include a <code>malloc</code> function definition, when the application calls <code>malloc</code>, it will call <em>our</em> malloc! In the image above, (c) demonstrates using <code>LD_PRELOAD</code>.</p>
<p>In <a href="https://github.com/gwu-cs-sysprog/lectures/tree/main/09/malloclog/"><code>malloclog</code></a>, we can see a library that interposes on <code>malloc</code> and <code>free</code>, and prints information to standard error. This includes the following:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb311-1" title="1"><span class="kw">typedef</span> <span class="dt">void</span> *(*malloc_fn_t)(<span class="dt">size_t</span> s);</a>
<a class="sourceLine" id="cb311-2" title="2"><span class="dt">static</span> malloc_fn_t malloc_fn;</a>
<a class="sourceLine" id="cb311-3" title="3"></a>
<a class="sourceLine" id="cb311-4" title="4"><span class="co">/* This `malloc` will override libc&#39;s `malloc` */</span></a>
<a class="sourceLine" id="cb311-5" title="5"><span class="dt">void</span> *</a>
<a class="sourceLine" id="cb311-6" title="6">malloc(<span class="dt">size_t</span> sz)</a>
<a class="sourceLine" id="cb311-7" title="7">{</a>
<a class="sourceLine" id="cb311-8" title="8">    <span class="dt">void</span> *mem;</a>
<a class="sourceLine" id="cb311-9" title="9"></a>
<a class="sourceLine" id="cb311-10" title="10">    <span class="co">/* if we don&#39;t yet know where libc&#39;s malloc is, look it up! */</span></a>
<a class="sourceLine" id="cb311-11" title="11">    <span class="cf">if</span> (malloc_fn == NULL) {</a>
<a class="sourceLine" id="cb311-12" title="12">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb311-13" title="13"><span class="co">         * Lets find the `malloc` function in libc! The `RTLD_NEXT`s</span></a>
<a class="sourceLine" id="cb311-14" title="14"><span class="co">         * specify that we don&#39;t want to find our *own* `malloc`, we&#39;d like to</span></a>
<a class="sourceLine" id="cb311-15" title="15"><span class="co">         * search starting with the *next* library.</span></a>
<a class="sourceLine" id="cb311-16" title="16"><span class="co">         */</span></a>
<a class="sourceLine" id="cb311-17" title="17">        malloc_fn = dlsym(RTLD_NEXT, <span class="st">&quot;malloc&quot;</span>);</a>
<a class="sourceLine" id="cb311-18" title="18">        assert(malloc_fn);</a>
<a class="sourceLine" id="cb311-19" title="19">    }</a>
<a class="sourceLine" id="cb311-20" title="20">    <span class="co">/* call libc&#39;s `malloc` here! */</span></a>
<a class="sourceLine" id="cb311-21" title="21">    mem = malloc_fn(sz);</a>
<a class="sourceLine" id="cb311-22" title="22">    fprintf(stderr, <span class="st">&quot;malloc(%ld) -&gt; %p</span><span class="sc">\n</span><span class="st">&quot;</span>, sz, mem);</a>
<a class="sourceLine" id="cb311-23" title="23"></a>
<a class="sourceLine" id="cb311-24" title="24">    <span class="cf">return</span> mem;</a>
<a class="sourceLine" id="cb311-25" title="25">}</a></code></pre></div>
<p>We do the same for <code>free</code>, and should do the same also for <code>calloc</code> and other memory allocation functions.</p>
<p><strong>Question:</strong> Why can’t we just call <code>malloc</code> directly instead of doing this complex thing with <code>dlsym</code>?</p>
<p>We can use it on a simple program that simply calls <code>malloc</code> and <code>free</code> on the allocated memory. To test this out, in <a href="https://github.com/gwu-cs-sysprog/lectures/tree/main/09/malloclog/"><code>malloclog</code></a>:</p>
<pre><code>$ make
$ LD_PRELOAD=./libmalloclog.so ./main.bin
malloc(4) -&gt; 0x55fe6cd492a0
free(0x55fe6cd492a0)
...</code></pre>
<p>This shows us that dynamic libraries are <em>programmable</em> and that we can use them in interesting ways to coordinate between libraries, provide new functionalities, and to interpose on functionalities. For example, many of the largest companies use <code>LD_PRELOAD</code> to swap out the <code>malloc</code> implementation for one that is higher performance.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>What else can you think to do with the ability to interpose on <em>any</em> library functions?</li>
<li>How might we implement some of the <code>valgrind</code> functionality using the ability to interpose on library functions?</li>
</ul>
<p>Note that running a program that uses <code>LD_PRELOAD</code> environment variables are more difficult to use in <code>gdb</code>. The <a href="https://github.com/gwu-cs-sysprog/lectures/tree/main/09/malloclog/ldpreload_w_gdb.sh"><code>ldpreload_w_gdb.sh</code></a> script demonstrates how to use both technologies together.</p>
<h1 id="system-calls-and-memory-management"><span class="header-section-number">14</span> System Calls and Memory Management</h1>
<p>We’ve talked about the many resources that are provided by the <em>system</em>. These include files, pipes, and domain sockets. But we’ve been vague about what the system is. Though we’ll leave the details for a later course, lets dive in to what constitutes the “system” a little bit.</p>
<h2 id="system-calls"><span class="header-section-number">14.1</span> System Calls</h2>
<p>We’ve claimed many times that <em>the system</em> provides pipes, domain sockets, files, the file system, etc… What is “the system”? First, lets start from what we know: is this system just a dynamic library? To some extent this makes sense.</p>
<p><strong>Question:</strong></p>
<ul>
<li>The dynamic libraries we’ve seen provide many of the functions we’ve used, so why <em>couldn’t</em> they provide <em>all</em> of the functionality we require!? For example, why can’t <code>read</code>, <code>open</code>, etc… all be simply provided solely by dynamic libraries?</li>
</ul>
<p>A few observations:</p>
<ol type="1">
<li>Dynamic libraries are loaded into a process, but <em>what provides the process itself</em>?</li>
<li>Some resources, like <code>pipe</code>s, <em>involve multiple processes</em>, thus there must be something in the system beyond specific processes.</li>
<li><em>Hardware is limited</em> – a system only has a limited amount of DRAM (memory) – and something has to determine how to hand it out to processes.</li>
</ol>
<figure>
<img src="figures/10_kernel_syscalls.svg" alt="The OS kernel’s relationship to processes and libraries. Each OS has a kernel, in this case the Linux Kernel. The kernel provides resources such as file systems, channels (domain sockets, pipes, etc…), and it implements processes (including fork, exec, wait, etc…). The kernel is separated from processes so that a failure in a process won’t spread beyond the process. This means that when a process wants to interact with the kernel, it must make a special system call. This behaves like a function call, but it maintains isolation of the kernel from the process. This is a system with four processes. The second is making a write system call, the third is using printf which is implemented in libc as part of the stream API in stdio.h. The stream implementation makes a write system call to send the data to the kernel (e.g. to display on our terminal). On the far right, we can see a process that doesn’t even have any libraries and makes system calls directly." /><figcaption>The OS kernel’s relationship to processes and libraries. Each OS has a kernel, in this case the Linux Kernel. The kernel provides resources such as file systems, channels (domain sockets, <code>pipe</code>s, etc…), and it implements processes (including <code>fork</code>, <code>exec</code>, <code>wait</code>, etc…). The kernel is separated from processes so that a failure in a process won’t spread beyond the process. This means that when a process wants to interact with the kernel, it must make a special <em>system call</em>. This behaves like a function call, but it maintains isolation of the kernel from the process. This is a system with four processes. The second is making a <code>write</code> system call, the third is using <code>printf</code> which is implemented in <code>libc</code> as part of the stream API in <code>stdio.h</code>. The stream implementation makes a <code>write</code> system call to send the data to the kernel (e.g. to display on our terminal). On the far right, we can see a process that doesn’t even have any libraries and makes system calls directly.</figcaption>
</figure>
<p>The <em>system</em>, as we’ve discussed it so far, is called the <em>kernel</em>. One of the main components of every operating system is the kernel. Every process in the system uses the kernel’s functionality. It provides the logic for <em>most</em> of the calls we’ve learned in the class, <code>fork</code>, <code>exec</code>, <code>pipe</code>, <code>read</code>, <code>write</code>, <code>open</code>, <code>creat</code>, etc… and also most of the resources we’ve discussed including channels, domain sockets, pipes, files, and the filesystem. It is some of the most trusted code on the system. If it has a bug, the whole system can crash – or worse!</p>
<p>We have to be able to call functions in the kernel from any process. This means we want to make what seem like function calls to the kernel. And we want to make sure that the faults of one process don’t spread to another! This means that somehow the kernel must be isolated from each process.</p>
<p><strong>System calls</strong> are the mechanism that behaves like a function call (and looks like one to us!), but that switches over to the kernel. System calls are a special instruction in the instruction set architecture (Intel x86 or ARM) that triggers the switch to the kernel. When the kernel’s done with its functionality, it can return (via a special instruction) to the process.</p>
<p>So system calls <em>behave</em> like function calls, but inherently involves <em>switches</em> from the process and to the kernel and back.</p>
<p><strong>Question:</strong></p>
<ul>
<li>So why does UNIX decide what functionality to put in a library, and what to put in the kernel?</li>
</ul>
<h3 id="system-calls-and-processes"><span class="header-section-number">14.1.1</span> System Calls and Processes</h3>
<p>In UNIX, system calls are available in <code>unistd.h</code>, so whenever you include that file to use a function, you know the function is likely a direct system call! You can also tell if a UNIX function is a system call by looking at the <em>sections</em> of <code>man</code> (from <code>man man</code>):</p>
<pre><code>MANUAL SECTIONS
    The standard sections of the manual include:

    1      User Commands
    2      System Calls
    3      C Library Functions
    4      Devices and Special Files
    5      File Formats and Conventions
    6      Games et. al.
    7      Miscellanea
    8      System Administration tools and Daemons</code></pre>
<p><strong>Questions:</strong></p>
<ul>
<li>Do <code>man write</code>. What is this documentation for?</li>
<li><p>Do <code>man 2 write</code>. What is this documentation for? What does the <code>2</code> mean?</p>
<p>You can always tell which section you’re looking at in the header line of the <code>man</code> output: <code>WRITE(2)</code> shows that we’re reading about <code>write</code> in the “System Calls” section.</p></li>
<li><p>Is <code>malloc</code> a system call or a C Library Function?</p></li>
</ul>
<p>We know what a system call looks like, as we’ve used them many times throughout the class. Lets look at the various ways to make the same system call. First, the normal way:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb314-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb314-2" title="2"></a>
<a class="sourceLine" id="cb314-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb314-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb314-5" title="5">{</a>
<a class="sourceLine" id="cb314-6" title="6">    write(<span class="dv">1</span>, <span class="st">&quot;hello world</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="dv">12</span>);</a>
<a class="sourceLine" id="cb314-7" title="7"></a>
<a class="sourceLine" id="cb314-8" title="8">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb314-9" title="9">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>hello world</code></pre>
<p>The C standard library even provides you a “generic” way to invoke <em>any</em> system call. The <code>syscall</code> function lets you make an integer-identified system call. Each system call on the system is identified with a unique integer. In this case, we’ll use <code>SYS_write</code>.</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb316-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb316-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/syscall.h&gt;</span></a>
<a class="sourceLine" id="cb316-3" title="3"></a>
<a class="sourceLine" id="cb316-4" title="4"><span class="dt">int</span></a>
<a class="sourceLine" id="cb316-5" title="5">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb316-6" title="6">{</a>
<a class="sourceLine" id="cb316-7" title="7">    syscall(SYS_write, <span class="dv">1</span>, <span class="st">&quot;hello world</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="dv">12</span>);</a>
<a class="sourceLine" id="cb316-8" title="8"></a>
<a class="sourceLine" id="cb316-9" title="9">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb316-10" title="10">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>hello world</code></pre>
<p>Lets look at a few of these integer values to see what’s happening here:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb318-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb318-2" title="2"><span class="pp">#include </span><span class="im">&lt;sys/syscall.h&gt;</span></a>
<a class="sourceLine" id="cb318-3" title="3"></a>
<a class="sourceLine" id="cb318-4" title="4"><span class="dt">int</span></a>
<a class="sourceLine" id="cb318-5" title="5">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb318-6" title="6">{</a>
<a class="sourceLine" id="cb318-7" title="7">    printf(<span class="st">&quot;write: %d</span><span class="sc">\n</span><span class="st">read:  %d</span><span class="sc">\n</span><span class="st">open:  %d</span><span class="sc">\n</span><span class="st">close: %d</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb318-8" title="8">        SYS_write, SYS_read, SYS_open, SYS_close);</a>
<a class="sourceLine" id="cb318-9" title="9"></a>
<a class="sourceLine" id="cb318-10" title="10">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb318-11" title="11">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>write: 1
read:  0
open:  2
close: 3</code></pre>
<p>Note, these integer values are <em>not</em> related to descriptors (e.g. <code>STDIN_FILENO == 0</code>). The system calls in Linux (and in all operating systems!) are each assigned an integer with which to identify them. You can see all of the <a href="https://filippo.io/linux-syscall-table/">system calls and their integer numbers</a>, and some documentation in <a href="https://manpages.debian.org/unstable/manpages-dev/syscalls.2.en.html"><code>man syscalls</code> (link)</a>.</p>
<p><strong>Exercise:</strong></p>
<ul>
<li>Find three interesting system calls that you didn’t know about.</li>
</ul>
<p>OK, now lets do a little more of a deep-dive. You won’t be familiar with the Intel’s/AMD’s x86-64 assembly language that follows, but the comments on the right give you the jist.</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb320-1" title="1">.<span class="bu">data</span>                <span class="co">; Add some global variables - our &quot;hello world&quot; message</span></a>
<a class="sourceLine" id="cb320-2" title="2"><span class="fu">msg:</span></a>
<a class="sourceLine" id="cb320-3" title="3">    .ascii <span class="st">&quot;hello world\n&quot;</span></a>
<a class="sourceLine" id="cb320-4" title="4">    len = . - msg    <span class="co">; magic length computation &quot;here&quot; - start of `msg`</span></a>
<a class="sourceLine" id="cb320-5" title="5"></a>
<a class="sourceLine" id="cb320-6" title="6">.text                <span class="co">; The code starts here!</span></a>
<a class="sourceLine" id="cb320-7" title="7">    .global _start</a>
<a class="sourceLine" id="cb320-8" title="8"></a>
<a class="sourceLine" id="cb320-9" title="9"><span class="fu">_start:</span>              <span class="co">; Note: the %rxx values are registers, $x are constants</span></a>
<a class="sourceLine" id="cb320-10" title="10">    <span class="bu">movq</span><span class="bn">  $1,   </span>%<span class="kw">rax</span> <span class="co">; Syscall&#39;s integer value, 1 == write, now set up the arguments...</span></a>
<a class="sourceLine" id="cb320-11" title="11">    <span class="bu">movq</span><span class="bn">  $1,   </span>%<span class="kw">rdi</span> <span class="co">; Arg 1: file descriptor 1</span></a>
<a class="sourceLine" id="cb320-12" title="12">    <span class="bu">movq</span>  <span class="dv">$</span>msg, %<span class="kw">rsi</span> <span class="co">; Arg 2: the string!</span></a>
<a class="sourceLine" id="cb320-13" title="13">    <span class="bu">movq</span>  <span class="dv">$</span>len, %<span class="kw">rdx</span> <span class="co">; Arg 3: the length of the string</span></a>
<a class="sourceLine" id="cb320-14" title="14">    <span class="bu">syscall</span>          <span class="co">; Kick off the system call instruction!</span></a>
<a class="sourceLine" id="cb320-15" title="15"></a>
<a class="sourceLine" id="cb320-16" title="16">    <span class="bu">movq</span><span class="bn">  $60,  </span>%<span class="kw">rax</span> <span class="co">; System call #60 == exit</span></a>
<a class="sourceLine" id="cb320-17" title="17">    xorq  %<span class="kw">rdi</span>, %<span class="kw">rdi</span> <span class="co">; Arg 1: xor(x, x) == 0, pass NULL as argument!</span></a>
<a class="sourceLine" id="cb320-18" title="18">    <span class="bu">syscall</span></a></code></pre></div>
<p>We compile this assembly with <code>make</code> (in <code>10/</code>). Program output:</p>
<pre><code>hello world</code></pre>
<p>We can see that the requirements of making a system call are quite minimal! A special instruction (on x86-64, <code>syscall</code>) provides the magical incantation to make what feels like a function call <em>to the kernel</em>.</p>
<p>How does this work? Recall that ELF, the file format for objects and programs includes many pieces of information necessary to execute the program. Among them, the <em>starting or entry address</em> which is the initial instruction to start executing when the program runs.</p>
<pre><code>$ readelf -a ./asm_syscall  | grep &quot;Entry&quot;
  Entry point address:               0x401000
$ readelf -a ./asm_syscall  | grep &quot;401000&quot;
  Entry point address:               0x401000
...
     6: 0000000000401000     0 NOTYPE  GLOBAL DEFAULT    1 _start</code></pre>
<p>We can see that the “entry point address” for the binary is <code>0x401000</code>, and we can see that the <code>_start</code> symbol has that address. The <code>exec</code> logic of the kernel will set the program to start executing at that <code>_start</code> address.</p>
<p>Note that this same analysis rings true for the normal C system call code above (not only for the assembly)! The <code>_start</code> function is where all execution starts in each program. This explains why our program above labels its code with <code>_start</code>!</p>
<h2 id="observing-system-calls"><span class="header-section-number">14.2</span> Observing System Calls</h2>
<p>The <code>strace</code> program lets us monitor the system calls a program makes. Running int on the assembly program above:</p>
<pre><code>$ strace ./asm_syscall
execve(&quot;./asm_syscall&quot;, [&quot;./asm_syscall&quot;], 0x7fff3c06ae10 /* 50 vars */) = 0
write(1, &quot;hello world\n&quot;, 12hello world
)           = 12
exit(0)                                 = ?
+++ exited with 0 +++</code></pre>
<p>This likely has what you’d expect: We see the <code>exec</code> that kicks off the program, the <code>write</code>, and, finally, the <code>exit</code>. You’d likely expect the same from the normal C program that also writes out <code>hello world</code>.</p>
<pre><code>$ trace ./normal_syscall
execve(&quot;./normal_syscall&quot;, [&quot;./normal_syscall&quot;], 0x7ffc036c1520 /* 50 vars */) = 0
brk(NULL)                               = 0x5638ed59d000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffd8bfb49c0) = -1 EINVAL (Invalid argument)
access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=138102, ...}) = 0
mmap(NULL, 138102, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7efddf831000
close(3)                                = 0
openat(AT_FDCWD, &quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3
read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\360A\2\0\0\0\0\0&quot;..., 832) = 832
pread64(3, &quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;..., 784, 64) = 784
pread64(3, &quot;\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&quot;, 32, 848) = 32
pread64(3, &quot;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\237\333t\347\262\27\320l\223\27*\202C\370T\177&quot;..., 68, 880) = 68
fstat(3, {st_mode=S_IFREG|0755, st_size=2029560, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7efddf82f000
pread64(3, &quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;..., 784, 64) = 784
pread64(3, &quot;\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&quot;, 32, 848) = 32
pread64(3, &quot;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\237\333t\347\262\27\320l\223\27*\202C\370T\177&quot;..., 68, 880) = 68
mmap(NULL, 2037344, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7efddf63d000
mmap(0x7efddf65f000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7efddf65f000
mmap(0x7efddf7d7000, 319488, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19a000) = 0x7efddf7d7000
mmap(0x7efddf825000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7efddf825000
mmap(0x7efddf82b000, 13920, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7efddf82b000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7efddf830540) = 0
mprotect(0x7efddf825000, 16384, PROT_READ) = 0
mprotect(0x5638eb775000, 4096, PROT_READ) = 0
mprotect(0x7efddf880000, 4096, PROT_READ) = 0
munmap(0x7efddf831000, 138102)          = 0
write(1, &quot;hello world\n&quot;, 12hello world
)           = 12
exit_group(0)                           = ?
+++ exited with 0 +++</code></pre>
<p>Whaaaaa!? If you look carefully, at the bottom we see the expected output. But we also see a <em>lot</em> of system calls previous to that. Between when we start execution at <code>_start</code>, and when we execute in <code>main</code>, quite a lot happens.</p>
<p><strong>Question:</strong></p>
<ul>
<li>What do you think is causing all of these system calls? What is the program doing before running <code>main</code>?</li>
</ul>
<figure>
<img src="figures/10_bootup_syscalls.svg" alt="Why are there so many system calls in a simple C program? Lets compare what happens in the C versus assembly programs. The process on the left is normal_syscall above, while asm_syscall is on the right. The assembly system call avoids much of the C runtime support, thus starts execution at _start, and makes system calls directly. In contrast, the C program starts execution in the dynamic linker ld (i.e. at _start in ld) – step (1). ld links in the libc dynamic library (2), then executes _start in our program (3). Our program actually calls libc (4) before executing main to do library initialization, which then calls main. After main returns (5), it returns into libc, which then terminates our program with the _exit system call. So why are there so many system calls made in the C program? There’s a lot of execution that happens outside of our logic! Most of the system calls are from ld." /><figcaption>Why are there so many system calls in a simple C program? Lets compare what happens in the C versus assembly programs. The process on the left is <code>normal_syscall</code> above, while <code>asm_syscall</code> is on the right. The assembly system call avoids much of the C runtime support, thus starts execution at <code>_start</code>, and makes system calls directly. In contrast, the C program starts execution in the dynamic linker <code>ld</code> (i.e. at <code>_start</code> in <code>ld</code>) – step (1). <code>ld</code> links in the <code>libc</code> dynamic library (2), then executes <code>_start</code> in our program (3). Our program actually calls <code>libc</code> (4) before executing <code>main</code> to do library initialization, which then calls <code>main</code>. After <code>main</code> returns (5), it returns into <code>libc</code>, which then terminates our program with the <code>_exit</code> system call. So why are there so many system calls made in the C program? There’s a lot of execution that happens outside of our logic! Most of the system calls are from <code>ld</code>.</figcaption>
</figure>
<h2 id="system-call-overhead"><span class="header-section-number">14.3</span> System Call Overhead</h2>
<p>There are many reasons why some functionality might be in a library, and accessed via function calls, or in the kernel, and accessed with system calls.</p>
<p>Lets look at an example of memory allocation. We can, of course, use <code>malloc</code> and <code>free</code> to allocate and free memory. But we can also call <code>mmap</code> and <code>munmap</code> that make <em>system calls</em> to allocate and free memory.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>Which will be <em>faster</em>, <code>malloc</code>/<code>free</code> or <code>mmap</code>/<code>munmap</code>?</li>
<li>How much overhead would you <em>guess</em> a system call has?</li>
</ul>
<div class="sourceCode" id="cb325"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb325-1" title="1"><span class="pp">#include </span><span class="im">&quot;10/timer.h&quot;</span></a>
<a class="sourceLine" id="cb325-2" title="2"></a>
<a class="sourceLine" id="cb325-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb325-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb325-5" title="5"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb325-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb325-7" title="7"></a>
<a class="sourceLine" id="cb325-8" title="8"><span class="pp">#define ITER 256</span></a>
<a class="sourceLine" id="cb325-9" title="9"></a>
<a class="sourceLine" id="cb325-10" title="10"><span class="dt">int</span></a>
<a class="sourceLine" id="cb325-11" title="11">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb325-12" title="12">{</a>
<a class="sourceLine" id="cb325-13" title="13">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb325-14" title="14">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> start, end;</a>
<a class="sourceLine" id="cb325-15" title="15">    <span class="dt">int</span> *mem;</a>
<a class="sourceLine" id="cb325-16" title="16"></a>
<a class="sourceLine" id="cb325-17" title="17">    <span class="co">/* How many cycles does `write` take? */</span></a>
<a class="sourceLine" id="cb325-18" title="18">    start = cycles();</a>
<a class="sourceLine" id="cb325-19" title="19">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; ITER; i++) {</a>
<a class="sourceLine" id="cb325-20" title="20">        mem = malloc(<span class="dv">256</span>);</a>
<a class="sourceLine" id="cb325-21" title="21">        mem[<span class="dv">0</span>] = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb325-22" title="22">        free(mem);</a>
<a class="sourceLine" id="cb325-23" title="23">    }</a>
<a class="sourceLine" id="cb325-24" title="24">    end = cycles();</a>
<a class="sourceLine" id="cb325-25" title="25">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">malloc + free overhead (cycles): %lld</span><span class="sc">\n</span><span class="st">&quot;</span>, (end - start) / ITER);</a>
<a class="sourceLine" id="cb325-26" title="26"></a>
<a class="sourceLine" id="cb325-27" title="27">    <span class="co">/* How many cycles does `fwrite` take? */</span></a>
<a class="sourceLine" id="cb325-28" title="28">    start = cycles();</a>
<a class="sourceLine" id="cb325-29" title="29">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; ITER; i++) {</a>
<a class="sourceLine" id="cb325-30" title="30">        mem = mmap(NULL, <span class="dv">256</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb325-31" title="31">        mem[<span class="dv">0</span>] = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb325-32" title="32">        munmap(mem, <span class="dv">256</span>);</a>
<a class="sourceLine" id="cb325-33" title="33">    }</a>
<a class="sourceLine" id="cb325-34" title="34">    end = cycles();</a>
<a class="sourceLine" id="cb325-35" title="35">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">mmap + munmap overhead (cycles): %lld</span><span class="sc">\n</span><span class="st">&quot;</span>, (end - start) / ITER);</a>
<a class="sourceLine" id="cb325-36" title="36"></a>
<a class="sourceLine" id="cb325-37" title="37">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb325-38" title="38">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>
malloc + free overhead (cycles): 1314

mmap + munmap overhead (cycles): 36381</code></pre>
<blockquote>
<p>What is a “cycle”? When you read that you have a 3GHz, that essentially says that the internal “clock” that drives the logic in the processor cycles by at 3 billion cycles per second. That’s a <em>lot</em>. Each cycle is 1/3 a nanosecond. A cycle is the smallest unit of measurement on a processor, and the <code>cycles</code> function we implement here gives us how many cycles have elapsed since the system boots.</p>
</blockquote>
<p>We can also look at the output APIs like <code>write</code> and compare them to the stream APIs that buffer their output.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>If we write a byte to a file using <code>write</code> or to a stream (via a <code>FILE</code>) using <code>fwrite</code>, what performance would you expect?</li>
<li>How about if we did an <code>fflush</code> after the <code>fwrite</code>?</li>
</ul>
<div class="sourceCode" id="cb327"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb327-1" title="1"><span class="pp">#include </span><span class="im">&quot;10/timer.h&quot;</span></a>
<a class="sourceLine" id="cb327-2" title="2"></a>
<a class="sourceLine" id="cb327-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb327-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb327-5" title="5"></a>
<a class="sourceLine" id="cb327-6" title="6"><span class="pp">#define ITER 256</span></a>
<a class="sourceLine" id="cb327-7" title="7"></a>
<a class="sourceLine" id="cb327-8" title="8"><span class="dt">int</span></a>
<a class="sourceLine" id="cb327-9" title="9">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb327-10" title="10">{</a>
<a class="sourceLine" id="cb327-11" title="11">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb327-12" title="12">    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> start, end;</a>
<a class="sourceLine" id="cb327-13" title="13"></a>
<a class="sourceLine" id="cb327-14" title="14">    <span class="co">/* How many cycles does `write` take? */</span></a>
<a class="sourceLine" id="cb327-15" title="15">    start = cycles();</a>
<a class="sourceLine" id="cb327-16" title="16">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; ITER; i++) write(<span class="dv">1</span>, <span class="st">&quot; &quot;</span>, <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb327-17" title="17">    end = cycles();</a>
<a class="sourceLine" id="cb327-18" title="18">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">write overhead (cycles): %lld</span><span class="sc">\n</span><span class="st">&quot;</span>, (end - start) / ITER);</a>
<a class="sourceLine" id="cb327-19" title="19"></a>
<a class="sourceLine" id="cb327-20" title="20">    <span class="co">/* How many cycles does `fwrite` take? */</span></a>
<a class="sourceLine" id="cb327-21" title="21">    start = cycles();</a>
<a class="sourceLine" id="cb327-22" title="22">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; ITER; i++) fwrite(<span class="st">&quot; &quot;</span>, <span class="dv">1</span>, <span class="dv">1</span>, stdout);</a>
<a class="sourceLine" id="cb327-23" title="23">    end = cycles();</a>
<a class="sourceLine" id="cb327-24" title="24">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">fwrite (stream) overhead (cycles): %lld</span><span class="sc">\n</span><span class="st">&quot;</span>, (end - start) / ITER);</a>
<a class="sourceLine" id="cb327-25" title="25"></a>
<a class="sourceLine" id="cb327-26" title="26">    <span class="co">/* How many cycles does `fwrite + fflush` take? */</span></a>
<a class="sourceLine" id="cb327-27" title="27">    start = cycles();</a>
<a class="sourceLine" id="cb327-28" title="28">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; ITER; i++) {</a>
<a class="sourceLine" id="cb327-29" title="29">        fwrite(<span class="st">&quot; &quot;</span>, <span class="dv">1</span>, <span class="dv">1</span>, stdout);</a>
<a class="sourceLine" id="cb327-30" title="30">        fflush(stdout);</a>
<a class="sourceLine" id="cb327-31" title="31">    }</a>
<a class="sourceLine" id="cb327-32" title="32">    end = cycles();</a>
<a class="sourceLine" id="cb327-33" title="33">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">fwrite + fflush overhead (cycles): %lld</span><span class="sc">\n</span><span class="st">&quot;</span>, (end - start) / ITER);</a>
<a class="sourceLine" id="cb327-34" title="34"></a>
<a class="sourceLine" id="cb327-35" title="35">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb327-36" title="36">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>                                                                                                                                                                                                                                                                
write overhead (cycles): 15574
                                                                                                                                                                                                                                                                
fwrite (stream) overhead (cycles): 148
                                                                                                                                                                                                                                                                
fwrite + fflush overhead (cycles): 15423</code></pre>
<h2 id="library-vs.-kernel-trade-offs-in-memory-allocation"><span class="header-section-number">14.4</span> Library vs. Kernel Trade-offs in Memory Allocation</h2>
<p>We’ve seen that</p>
<ol type="1">
<li>the kernel is there to facilitate access to hardware resources (memory, processing, etc…),</li>
<li>the kernel provides processes (<code>fork</code>, <code>exec</code>) and inter-process interactions (<code>wait</code>, <code>pipe</code>, etc…) as these functionalities require implementation beyond any single process,</li>
<li>functions in dynamic libraries are much faster to invoke as system calls have significant overhead.</li>
</ol>
<p>This leads us to the conclusion that for performance, we’d like to implement as many functions as possible in libraries, and to rely on the kernel when processes require modifications (<code>exec</code>, <code>fork</code>), when there are multiple processes involved (IPC), or when the finite resources of the system must be split up between processes (<code>open</code>, <code>creat</code>, <code>sbrk</code>).</p>
<p>Here, we’re going to dive into the design of the <em>memory management</em> functionalities in UNIX to better understand the trade-offs. Specifically, <em>how does <code>malloc</code> and <code>free</code> work</em>!?</p>
<h3 id="library-tracking-of-memory"><span class="header-section-number">14.4.1</span> Library Tracking of Memory</h3>
<p>So <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, and <code>free</code> are implemented in a library (in <code>libc</code>), and when we request memory from them, they might call <code>sbrk</code> (or <code>mmap</code> on some systems) to get memory from the kernel, but from that point on, they will manage that memory themselves. What does this mean? When the <em>heap</em> doesn’t have enough free memory to satisfy a <code>malloc</code> request, we call the kernel to <em>expand the heap</em>. To do so, we ask the kernel for memory via <code>sbrk</code> or <code>mmap</code>, and we generally get a large chunk of memory. For example, we might ask <code>sbrk</code> for 64KB of memory with <code>mem = sbrk(1 &lt;&lt; 16)</code><a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a>. Then it is <code>malloc</code>’s job to split up that memory into the smaller chunks that we’ll return in each subsequent call to <code>malloc</code>. When memory is <code>free</code>d, it is returned to the pool of memory which we’ll consider for future allocations. Because we’re <em>reusing</em> freed memory, we’re avoiding system calls when the heap contains enough <code>free</code>d memory to satisfy a request.</p>
<figure>
<img src="figures/10_mem_splitting.svg" alt="In (a), we see the heap with red rectangles that designate allocated memory. (b) we get a malloc request. First we check to see if there is any span of unallocated memory we can use to satisfy the request. (c) shows what we must avoid: the overlapping of two different allocations. As we cannot find a sufficient span of memory to satisfy the malloc request, in (d), we expand the heap using sbrk. (e) shows how we can satisfy the request from the newly expanded heap memory." /><figcaption>In (a), we see the heap with red rectangles that designate allocated memory. (b) we get a <code>malloc</code> request. First we check to see if there is any span of unallocated memory we can use to satisfy the request. (c) shows what we must avoid: the overlapping of two different allocations. As we cannot find a sufficient span of memory to satisfy the <code>malloc</code> request, in (d), we expand the heap using <code>sbrk</code>. (e) shows how we can satisfy the request from the newly expanded heap memory.</figcaption>
</figure>
<p>This is what it means that our <code>malloc</code>/<code>free</code> code in the <code>libc</code> library need to track the memory in the heap. We need to track <em>where allocated memory is located</em> and <em>where freed spans of memory are located</em>, to enable intelligent allocation decisions for future <code>malloc</code> calls.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>What data-structures should we use to track allocated/freed memory?</li>
<li>Do you foresee any challenges in using data-structures to track memory?</li>
</ul>
<h3 id="malloc-data-structures"><span class="header-section-number">14.4.2</span> Malloc Data-structures</h3>
<p>The <code>malloc</code> and <code>free</code> implementation must track which chunks of memory are allocated, and which are freed, but it cannot use <code>malloc</code> to allocate data-structures. That would result in <code>malloc</code> calling itself recursively, and infinitely! If <code>malloc</code> requires memory allocation for its tracking data-structures, who tracks the memory for the tracking data-structures? Yikes.</p>
<p>We solve this problem by allocating the tracking data-structures along with the actual memory allocation itself. That is to say, we allocate a <em>header</em> that is a struct defined by <code>malloc</code> that is <em>directly before</em> an actual memory allocation. Because the header is part of the same contiguous memory chunk, we allocate the header at the same time as we allocate memory! When memory is freed, we use the header to track the chunk of memory (the header plus the free memory directly following the header) in a linked list of free chunks of memory called a <em>freelist</em>.</p>
<figure>
<img src="figures/10_malloc.svg" alt="Memory allocations through various sets of details. The red boxes are allocated memory, white box is memory that we’ve retrieved in the heap from sbrk, the green boxes are the headers data-structures that track free chunks of memory we can use for future allocations, and they are arranged in a linked list called freelist, and orange boxes are headers for allocated chunks of memory thta track how large that allocation is so that when we free it, we know large the chunk of freed memory will be." /><figcaption>Memory allocations through various sets of details. The red boxes are allocated memory, white box is memory that we’ve retrieved in the heap from <code>sbrk</code>, the green boxes are the <em>headers</em> data-structures that track free chunks of memory we can use for future allocations, and they are arranged in a linked list called <em>freelist</em>, and orange boxes are headers for allocated chunks of memory thta track how large that allocation is so that when we <code>free</code> it, we know large the chunk of freed memory will be.</figcaption>
</figure>
<ul>
<li><ol type="a">
<li>the heap with some memory allocated, and some free spans of memory.</li>
</ol></li>
<li><ol start="2" type="a">
<li>we need to make a data-structure to track where the free spans of memory are, so we add a structure into each of the free chunks, and use it to construct a linked list of the free chunks.</li>
</ol></li>
<li><ol start="3" type="a">
<li>When we <code>malloc</code>, we can find the free chunk large enough for the allocation, remove it from the freelist, …</li>
</ol></li>
<li><ol start="4" type="a">
<li>…and return it!</li>
</ol></li>
<li><ol start="5" type="a">
<li>If we want to free that memory, we must understand somehow (i.e. must have a structure that tracks) the size of the allocation, so that we can add it back onto the freelist.</li>
</ol></li>
<li><ol start="6" type="a">
<li>We can track the size of each allocation in a <em>header</em> directly before the memory we return. We are tracking the memory in the same contiguous span of memory we use for the allocation!</li>
</ol></li>
<li><ol start="7" type="a">
<li>So when we free, we’re just adding that memory back onto the freelist.</li>
</ol></li>
<li><ol start="8" type="a">
<li>If we ever receive a <code>malloc</code> request that can’t be satisfied by the freelist, <em>only then</em> do we make a system call to allocate more heap.</li>
</ol></li>
</ul>
<h3 id="exercise-smalloc"><span class="header-section-number">14.4.3</span> Exercise: <code>smalloc</code></h3>
<p>Look at the <a href="https://github.com/gwu-cs-sysprog/lectures/blob/main/10/smalloc.c"><code>10/smalloc.c</code> (link)</a> file for a simple implementation of a <code>malloc</code>/<code>free</code> that assumes <em>only allocations of a specific size</em>. This means that we don’t need to track the sizes of allocations and free chunks in the headers, simplifying our implementation. Build, and run the program:</p>
<pre><code>$ make
$ ./smalloc.bin</code></pre>
<p>It currently implements this simple <code>malloc</code>! Read through the <code>smalloc</code> and <code>sfree</code> functions, and the <code>main</code>. Answer <code>QUESTION 1-3</code>. Then, move on to <code>QUESTION 4</code>. In <code>expand_heap</code>, we make the system call to allocate more memory from the system with <code>sbrk</code>. We need to set up that newly allocated heap memory to include memory chunks that we can allocate with <code>smalloc</code>. Answering how this is done is the core of <code>QUESTION 4</code>.</p>
<h1 id="unix-security-users-groups-and-filesystem-permissions"><span class="header-section-number">15</span> UNIX Security: Users, Groups, and Filesystem Permissions</h1>
<blockquote>
<p><strong>This material adapted from Prof. Aviv’s <a href="https://classes.adamaviv.com/ic221/s18/units/01/unit.html#org26c0ea7">material</a>.</strong></p>
</blockquote>
<p>We’ve seen how the filesystem is used to store and name files and channels, and we’ve seen the APIs to access directories and files. If everyone had access to every else’s files, then there would be no way to secure your information. Thus, the kernel provides means to control different user’s <em>access</em> to different files and directories. This means that I cannot access your files, and vice-versa!</p>
<p>To understand the core concept of <em>access control</em> in UNIX, we have to understand</p>
<ol type="1">
<li>how UNIX thinks about, implements, and organizes users and groups of users,</li>
<li>how files and directories provide various access permissions to different users and how to alter those permissions, and</li>
<li>how services, even when executed by a user, can have heightened access to system resources.</li>
</ol>
<h2 id="file-and-directory-permissions"><span class="header-section-number">15.1</span> File and Directory Permissions</h2>
<p>The filesystem stores files and directories are somehow associated with each of us, separately. Lets check out the properties of a file that are returned by running <code>ls -l</code>:</p>
<pre><code>.- Directory?
|    .-------Permissions                   .- Directory Name
| ___|___     .----- Owner                 |
v/       \    V     ,---- Group            V
drwxr-x--x 4 aviv scs 4096 Dec 17 15:14 im_a_directory
-rw------- 1 aviv scs 400  Dec 19  2013 .ssh/id_rsa.pub
                       ^   \__________/    ^
File Size -------------&#39;       |           &#39;- File Name
  in bytes                     |
                               |
   Last Modified --------------&#39;</code></pre>
<p>An example from the class’ server where we create a file, a directory, and see the results:</p>
<pre><code>$ echo hi &gt; file.txt
$ mkdir hello
$ ls -l
-rw-r--r-- 1 gparmer dialout    3 Mar 18 12:19 file.txt
drwxr-xr-x 2 gparmer dialout 4096 Mar 18 12:20 hello</code></pre>
<p>We see that each file and directory has a owner and group associated with it.</p>
<p><strong>Question:</strong></p>
<ul>
<li>What do you think this means? Why do files have owners and groups?</li>
</ul>
<h3 id="file-ownership-and-groups"><span class="header-section-number">15.1.1</span> File Ownership and Groups</h3>
<p>The <em>owner</em> of a file is the <em>user</em> that is directly responsible for the file and has special status with respect to the file permissions. Users can also be collected together into a set called a <em>group</em>, a collection of users who posses the same permissions. A file is associated with a group. A file’s or directory’s owners and groups have different permissions to access the file. Before we dive into that, lets understand how to understand users and groups.</p>
<p>You all are already aware of your username. You can get your username with the <code>whoami</code> command:</p>
<pre><code>$ whoami
gparmer</code></pre>
<p>To have UNIX tell you your username and connection information on this machine, use the command, <code>who</code>:</p>
<pre><code>$ who
gparmer  pts/1        2022-03-18 12:12 (128.164...)</code></pre>
<p>The first part of the output is the username. The rest of the information in the output refers to the terminal you’re using (it is a “pseudo-terminal device”, something that pretends it is a typewriter from the 60s), the time the terminal was created, and from which host you are connected.</p>
<p>You can determine which groups you are in using the groups command.</p>
<pre><code>$ groups
dialout CS_Admins</code></pre>
<p>On the class’ server, I’m in the <code>dialout</code> and <code>CS_Admins</code> groups. On my work computer, I’m in a few more groups:</p>
<pre><code>$ groups
ycombinator adm cdrom sudo dip plugdev lpadmin sambashare</code></pre>
<p>The good news is that I can use my <code>cdrom</code>. Fantastic. It will pair well with my pseudo-typewriter. Cool.</p>
<h3 id="file-permissions"><span class="header-section-number">15.1.2</span> File Permissions</h3>
<p>The <em>permissions</em> associated with each file/directory specify who should be able to have the following access:</p>
<ul>
<li><code>r</code> - the ability to <em>read</em> the file, or <em>read the contents</em> of a directory.</li>
<li><code>w</code> - the ability to <em>write</em> to the file, or update the contents of a directory.</li>
<li><code>x</code> - the ability to <em>execute</em> a file (i.e. a program), or <code>chdir</code> into a directory.</li>
</ul>
<p>We think about different users as having different sets of these permissions to access files and directories. When we see the permissions string for a file, we see three sets of these <code>rwx</code> permissions:</p>
<pre><code>-rw-r--r-- 1 gparmer dialout    3 Mar 18 12:19 file.txt</code></pre>
<p>Here we have three sets of permissions <code>rw-</code> (read and write), <code>r--</code> (read only), and <code>r--</code> (read only). These three sets of permissions each specify the access permissions for the <em>owner</em>, the <em>group</em>, and everyone else’s <em>global</em> permissions.</p>
<pre><code> .-- Directory Bit
|
|       ,--- Global Permission (i.e. &quot;every else&quot;)
v      / \
-rwxr-xr-x
 \_/\_/
  |  `--Group Permission
  |
   `-- Owner Permission</code></pre>
<p>Given this, now we can understand the permissions for each file in:</p>
<pre><code>ls -l 11/perm_example/
total 0
-rw-r--r-- 1 gparmer gparmer 0 Mar 25 18:43 bar
-rw-rw-r-- 1 gparmer gparmer 0 Mar 25 18:43 baz
-rwx------ 1 gparmer gparmer 0 Mar 25 18:42 foo</code></pre>
<p><em>Question:</em></p>
<ul>
<li><em>Who</em> has <em>what access permissions</em> to which files?</li>
</ul>
<h3 id="numerical-representation-of-permissions"><span class="header-section-number">15.1.3</span> Numerical Representation of Permissions</h3>
<p>Each permission has a <em>numerical representation</em>. We represent it in <em>octal</em>, which is a fancy way to say that we think of each digit of our numerical representation as being between <code>0-7</code> – it is “base 8” (in contrast to the normal digits numbers we use every day that are “base 10”). Thus, each of the three sets of permissions is <code>3</code> bits.</p>
<p>Each of the three permissions, <code>r</code>, <code>w</code>, and <code>x</code> correspond to the most-significant to the least significant bits in each octal digit. For example:</p>
<pre><code>rwx -&gt; 1 1 1 -&gt; 7
r-x -&gt; 1 0 1 -&gt; 5
--x -&gt; 0 0 1 -&gt; 1
rw- -&gt; 1 1 0 -&gt; 6</code></pre>
<p>On the left we see a permission, its bit representation, and the associated octal digit. The shorthand, you can think of this is this:</p>
<ul>
<li><code>r = 4</code> as it is represented with the most significant bit</li>
<li><code>w = 2</code> as the second bit</li>
<li><code>x = 1</code> as it is the least significant bit</li>
</ul>
<p>Thus the octal digit is simply the addition of each of these numeric values for each access right. We can combine these digits to encapsulate permissions for the owner, group, and everyone else:</p>
<pre><code>-rwxrwxrwx -&gt; 111 111 111 -&gt; 7 7 7
-rwxrw-rw- -&gt; 111 110 110 -&gt; 7 6 6
-rwxr-xr-x -&gt; 111 101 101 -&gt; 7 5 5</code></pre>
<p>So now we know how to interpret, and understand these permission values, and how to represent them as digits.</p>
<h3 id="updating-filedirectory-permissions"><span class="header-section-number">15.1.4</span> Updating File/Directory Permissions</h3>
<p>To change a file permission, you use the <code>chmod</code> command, or the <code>chmod</code> system call. In each, we specify the file to update, and the new permissions in octal. Lets play around with permission and see their impact:</p>
<pre><code>$ gcc helloworld.c -o helloworld.bin
$ ls -l helloworld.bin
-rwxrwxr-x 1 gparmer gparmer 41488 Mar 22 08:52 helloworld.bin
$ ./helloworld.bin
hello world!</code></pre>
<p>I can execute the program, and I could read the program, for example using <code>nm</code>. I could even overwrite the file.</p>
<blockquote>
<p>Note: on the server, the default permissions are more restrictive – <code>-rwxr-xr-x 1 gparmer dialout 16464 Mar 25 19:16 helloworld.bin</code>. We don’t want anyone other than us writing to the file on a shared server!</p>
</blockquote>
<p>What if I removed all permissions for everyone but the owner, and even removed my own ability to execute?</p>
<pre><code>$ chmod 600 helloworld.bin
$ ls -l helloworld.bin
-rw------- 1 gparmer gparmer 41488 Mar 22 08:52 helloworld.bin
$ ./helloworld.bin
-bash: ./helloworld.bin: Permission denied</code></pre>
<p>We removed our own ability to execute the file, so we no longer can! Note that permission <code>6</code> is <code>4 + 2</code> which is <code>r</code> + <code>w</code>. If I wanted on the system to be able to execute the program:</p>
<pre><code>$ chmod 711 helloworld.bin
$ ls -l helloworld.bin
-rwx--x--x 1 gparmer gparmer 41488 Mar 22 08:52 helloworld.bin
$ ./helloworld.bin
hello world!</code></pre>
<p>Recall, <code>7 = 4 + 2 + 1</code> which is <code>r</code> + <code>w</code> + <code>x</code>. We can see that we’ve given everyone on the system execute permissions, so the file is again about to execute! Any other user on the system would also be able to execute the program.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>How do you think permissions change access to directories? Try out setting the permissions of a directory (recall <code>mkdir</code>), and seeing what accesses cannot be made if permissions are removed.</li>
<li>You and a classmate should sit down together, and use <code>chmod</code> to concretely understand when you can access each other’s files. Remember, you can find out where your files are with <code>pwd</code>, what groups you’re in with <code>groups</code>. Which files can another user can access at that path with sufficient permissions? You can use the <code>/tmp/</code> directory to store files that you can both mutually access, permissions allowing.</li>
</ul>
<h3 id="changing-filedirectory-owner-and-group"><span class="header-section-number">15.1.5</span> Changing File/Directory Owner and Group</h3>
<p>We’ve seen that each file and directory is associated with a user, and with a group. Which means that, of course, we can change those settings! Two commands (and their corresponding system call: <code>chown</code>):</p>
<ul>
<li><code>chown &lt;user&gt; &lt;file/directory&gt;</code> - change owner of the file/directory to the user</li>
<li><code>chgrp &lt;group&gt; &lt;file/directory&gt;</code> - change group of the file to the group</li>
</ul>
<p>UNIX limits who is able to execute these operations.</p>
<ul>
<li>Only a <em>superuser</em> called <code>root</code> is allowed to <code>chown</code> a file or directory. <code>root</code> is special in that they are able to change the permissions of any file/directory, and most of the most sensitive files on the system are owned by root. For example, the devices (think, hard-drives holding the filesystem, monitors, and network devices) are only accessible by <code>root</code> (check out <code>/dev/*</code>).</li>
<li>Only the <em>owner</em> of a file (and <code>root</code>) is allowed to change the group of a file, and only to a group that user is in (recall <code>groups</code>).</li>
</ul>
<p>We can see this:</p>
<pre><code>$ chown root helloworld.bin
chown: changing ownership of &#39;helloworld.bin&#39;: Operation not permitted</code></pre>
<p><strong>Question:</strong></p>
<ul>
<li>Why do you think we aren’t allowed to change the owner of a file, nor change the group to one in which we don’t belong?</li>
</ul>
<h2 id="security-and-programming-with-users-and-groups"><span class="header-section-number">15.2</span> Security and Programming with Users and Groups</h2>
<p>We’ve seen that a lot of UNIX security centers around users, groups, and the corresponding permissions associated with files and directories. When a process is <code>fork</code>ed, it <em>inherits</em> the user and group of the parent process. Thus, when you’re typing at a shell, the <em>shell process</em> is what really is executing as your user id, and when you create programs, they inherit your user id. These are the core of the security primitives, so lets dive into a little more detail.</p>
<h4 id="apis-for-accessing-a-programs-privilege-settings"><span class="header-section-number">15.2.0.1</span> APIs for Accessing a Program’s Privilege Settings</h4>
<p>If every process has a user and group, we must be able to access them, right? There are two basic system calls for retrieving user and group information within a program.</p>
<ul>
<li><code>uid_t getuid(void)</code> - Returns the real user id of the calling process.</li>
<li><code>gid_t getgid(void)</code> - Returns the real group id of the calling process.</li>
</ul>
<p>Let’s look at an example program.</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb345-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb345-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb345-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb345-4" title="4"></a>
<a class="sourceLine" id="cb345-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb345-6" title="6">main(<span class="dt">int</span> argc, <span class="dt">char</span> * argv[])</a>
<a class="sourceLine" id="cb345-7" title="7">{</a>
<a class="sourceLine" id="cb345-8" title="8">    uid_t uid;</a>
<a class="sourceLine" id="cb345-9" title="9">    gid_t gid;</a>
<a class="sourceLine" id="cb345-10" title="10"></a>
<a class="sourceLine" id="cb345-11" title="11">    uid = getuid();</a>
<a class="sourceLine" id="cb345-12" title="12">    gid = getgid();</a>
<a class="sourceLine" id="cb345-13" title="13"></a>
<a class="sourceLine" id="cb345-14" title="14">    printf(<span class="st">&quot;uid=%d gid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, uid, gid);</a>
<a class="sourceLine" id="cb345-15" title="15"></a>
<a class="sourceLine" id="cb345-16" title="16">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb345-17" title="17">}</a></code></pre></div>
<p>Program output:</p>
<pre><code>uid=1003 gid=20</code></pre>
<p>Every user has different identifiers as does each group. If another user where to run the same program, they’d get a different value.</p>
<p><strong>Question:</strong></p>
<ul>
<li>In groups, one of you compile this program, and the other run it! Use <code>chmod</code> to make sure that they can! What do you observe?</li>
<li>If the kernel thinks of users as numeric identifiers, how does <code>whoami</code> print out a <em>human-readable string</em>? Use <code>strace whoami</code> to come up with a strong guess.</li>
<li>How do we get human-readable groups with <code>groups</code> (investigate with <code>strace groups</code>)?</li>
</ul>
<p>Interestingly, whomever <em>executes</em> the program will have their uid/gid printed out; it won’t use the uid/gid of the owner of the program. Remember, that we inherit the uid/gid on fork, thus when the shell runs the program, it uses our shell’s (thus our) uid/gid.</p>
<h3 id="user-and-group-strings"><span class="header-section-number">15.2.1</span> User and Group Strings</h3>
<p>If the UNIX programmatic APIs provide access to user and group <em>identifiers</em> (i.e. integers), how is it that we can see strings corresponding to these numeric values? The mapping of the identifiers to strings are defined in two places. The first is a file called <code>/etc/passwd</code> which manages all the users of the system. Here is the <code>/etc/passwd</code> entry on my local system (the server uses another means to store user info):</p>
<pre><code>$ cat /etc/passwd | grep gparmer
gparmer:x:1000:1000:Gabe Parmer,,,:/home/ycombinator:/bin/bash
   |    |   |     |      |                 |             |
   V    |   V     |      V                 V             V
 user   | user id |  human-readable id  home directory  shell to use upon login
        V         V
    password    group id</code></pre>
<p>We can lookup our username and associate it with a numerical user id, and a group id for that user. These numbers are what the system uses to track users, but UNIX nicely converts these numbers into names for our convenience. The file additionally holds the path to the user’s home directory, and their shell. These are used upon the user logging in: the login logic will switch to the user’s home directory, and execute their shell. The <code>password</code> entry is deprecated. The translation between userid and username is in the password file. The translation between groupid and group name is in the group file, <code>/etc/group</code>. Here is the entry for the administrators on the class’ server:</p>
<pre><code>$ grep CS_Admins /etc/group
CS_Admins:x:1004:aaviv,timwood,gparmer,...</code></pre>
<p>There you can see that the users <code>aaviv</code>, <code>timwood</code>, and <code>gparmer</code> are all in the group of administrators.</p>
<p>All of this information, including identifiers, and human-readable strings can be retrieved with <code>id</code>.</p>
<pre><code>$ id
uid=1000(gparmer) gid=1000(gparmer) groups=1000(gparmer),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare)</code></pre>
<p><strong>Question:</strong> Take a moment to explore these files and the commands. See what groups you are in.</p>
<h2 id="application-specific-privileges-using-set-user-idset-group-id"><span class="header-section-number">15.3</span> Application-Specific Privileges using set-user-id/set-group-id</h2>
<p>Systems that support multiple users are quite complex. They have services used by many users, but that must be protected from the potentially accidental or malicious actions of users. These programs require more privileges than a user to do their job. A few examples:</p>
<ul>
<li><em>Logging</em> is a very important functionality in systems. It enables services to log actions that are taken, for example, users logging in to <code>ssh</code> and clients connecting to webservers. The logs are stored in files (often in <code>/var/log/</code>), and users must <em>not</em> be able to directly modify (and potentially corrupt) the logs. But they must be able to append to the logs. How can we support this contradiction when a logging process will run with our user id when we execute it!?</li>
<li><em>Coordinating actions</em> such as running commands regularly, or at specific points in time. The programs <code>at</code> and <code>cron</code> enable exactly this! They require adding entries into system files (e.g. <code>crontab</code>) to record the actions, but one user must not corrupt the entires of another user. Again, we want to both be able to add entries to the files, but cannot modify the file!</li>
</ul>
<p>We already know one way to solve this problem. We can write a service, and have clients <em>request</em> (e.g. via IPC and domain sockets) it perform actions on our behalf. So long as a service runs as a different user, its files will be in accessible from clients.</p>
<p>However, there is another way to solve the above contradictions. We really want a program to run with a <em>different</em> user’s permissions – those that go beyond our own. We want the <em>logger</em> to run with the permissions of the logging user, and we want <code>cron</code> to run with the permissions of the <code>cron</code> service. This is possible with the set-uid-bits (and set-gid-bits).</p>
<p>The <code>set-*-bits</code> can be seen in the <code>man chmod</code> manual page. We’re used to permissions being three digits (for the owner, the group, and everyone else), but it can be specified as <em>four</em> digits. The most significant digit can be set on executable binaries, and will result in the binary executing with the owner’s uid/gid.</p>
<p>That is, we previously assumed a permission string contained 3 octal digits, but really there are 4 octal digits. The missing octal digit is that for the set-bits. There are three possible set-bit settings and they are combined in the same way as other permissions:</p>
<ul>
<li><code>4</code> - <em>set-user-id</em>: sets the program’s effective user id to the owner of the program</li>
<li><code>2</code> - <em>set-group-id</em>: sets the program’s effective group id to the group of the program</li>
<li><code>1</code> - <em>the sticky bit</em>: which, when set on a directory, prevents others from deleting files from that directory. We won’t cover the stick bit.</li>
</ul>
<p>These bits are used in much the same way as the other permission modes. For example, we can change the permission of our get_uidgid program from before like so:</p>
<pre><code>chmod 6751 get_uidgid</code></pre>
<p>And we can interpet the octals like so:</p>
<pre><code>set      group
bits user |  other
  |   |   |   |
  V   V   V   V
 110 111 101 001
  6   7   5   1</code></pre>
<p>When we look at the <code>ls -l</code> output of the program, the permission string reflects these settings with an “s” in the execute part of the string for user and group.</p>
<pre><code>$ ls -l get_uidgid
-rwsr-s--x 1 aviv scs 8778 Mar 30 16:45 get_uidgid</code></pre>
<h4 id="real-vs.-effective-capabilities"><span class="header-section-number">15.3.0.1</span> Real vs. Effective Capabilities</h4>
<p>With the set-bits, when the program runs, the capabilities of the program are effectively that of the owner and group of the <em>program</em>. However, the real user id and real group id remain that of the user who ran the program. This brings up the concept of <em>effective</em> vs. <em>real</em> identifiers:</p>
<ul>
<li><em>real user id</em> (or <em>group id</em>): the identifier of the actual user who executed a program.</li>
<li><em>effective user id</em> (or <em>group id</em>): the idenifier for the capabilities or permissions settings of an executing program.</li>
</ul>
<p>The system calls <code>getuid</code> and <code>getgid</code> return the <em>real</em> user and group identifiers, but we can also retrieve the <em>effective</em> user and group identifiers with</p>
<ul>
<li><code>uid_t geteuid(void)</code> - return the effective user identifier for the calling process.</li>
<li><code>gid_t getegid(void)</code> - return the effective group identifer for the calling process.</li>
</ul>
<p>We now have enough to test <em>set-x-bit</em> programs using a the following program that prints both the real and effective user/group identities.</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb353-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb353-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb353-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb353-4" title="4"></a>
<a class="sourceLine" id="cb353-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb353-6" title="6">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb353-7" title="7">{</a>
<a class="sourceLine" id="cb353-8" title="8">    uid_t uid,euid;</a>
<a class="sourceLine" id="cb353-9" title="9">    gid_t gid,egid;</a>
<a class="sourceLine" id="cb353-10" title="10"></a>
<a class="sourceLine" id="cb353-11" title="11">    uid = getuid();</a>
<a class="sourceLine" id="cb353-12" title="12">    gid = getgid();</a>
<a class="sourceLine" id="cb353-13" title="13">    printf(<span class="st">&quot; uid=%d  gid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>,  uid,  gid);</a>
<a class="sourceLine" id="cb353-14" title="14"></a>
<a class="sourceLine" id="cb353-15" title="15">    euid = geteuid();</a>
<a class="sourceLine" id="cb353-16" title="16">    egid = getegid();</a>
<a class="sourceLine" id="cb353-17" title="17">    printf(<span class="st">&quot;euid=%d egid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, euid, egid);</a>
<a class="sourceLine" id="cb353-18" title="18"></a>
<a class="sourceLine" id="cb353-19" title="19">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb353-20" title="20">}</a></code></pre></div>
<p>As the owner of the file, after compilation, the permissions can be set to add set-user-id:</p>
<pre><code>$ gcc 11/get_uidgid.c -o get_uidgid
$ chmod 6755 get_uidgid
$ ls -l get_uidgid
-rwsr-sr-x   1 gparmer        gparmer     16880 2022-03-29 08:30 get_uidgid</code></pre>
<p>Notice the <code>s</code> values to denote the <code>set-*-bits</code>.</p>
<p>Lets test this set uid stuff!</p>
<pre><code>$ cp get_uidgid /tmp/
$ chmod 4755 /tmp/get_uidgid</code></pre>
<p>Now you should all have access to the file, with it being set as set-uid.</p>
<p><strong>Question:</strong></p>
<ul>
<li>Compile and run the <code>get_uidgid</code> program. What would you expect to happen? What do you observe? Recall that you can use <code>id</code> to print out both of your ids and groups.</li>
<li>Run the <code>get_uidgid</code> program I placed in <code>/tmp/</code>. What is the expected output? What do you observe?</li>
<li><p>What happens if we enable a program to create files while using the <code>set-*-id</code> bits? Lets use the following program that will create a file named after each command line arguments.</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb356-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb356-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb356-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb356-4" title="4"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb356-5" title="5"></a>
<a class="sourceLine" id="cb356-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb356-7" title="7">main(<span class="dt">int</span> argc, <span class="dt">char</span> * argv[])</a>
<a class="sourceLine" id="cb356-8" title="8">{</a>
<a class="sourceLine" id="cb356-9" title="9">    <span class="dt">int</span> i, fd;</a>
<a class="sourceLine" id="cb356-10" title="10"></a>
<a class="sourceLine" id="cb356-11" title="11">    <span class="cf">for</span>(i = <span class="dv">0</span>; i &lt; argc; i++){</a>
<a class="sourceLine" id="cb356-12" title="12">        <span class="co">/* create an empty file */</span></a>
<a class="sourceLine" id="cb356-13" title="13">        <span class="cf">if</span>((fd = open(argv[i],O_CREAT,<span class="bn">0666</span>) &gt; <span class="dv">0</span>) &gt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb356-14" title="14">            close(fd);</a>
<a class="sourceLine" id="cb356-15" title="15">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb356-16" title="16">            perror(<span class="st">&quot;open&quot;</span>);</a>
<a class="sourceLine" id="cb356-17" title="17">        }</a>
<a class="sourceLine" id="cb356-18" title="18">    }</a>
<a class="sourceLine" id="cb356-19" title="19"></a>
<a class="sourceLine" id="cb356-20" title="20">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb356-21" title="21">}</a></code></pre></div>
<p>Run the following program in your home directory (can also be found in <code>create_files.c</code>), passing as arguments the names of files you want to create: <code>./create_files blah</code> will create a file <code>blah</code>. Check out the owner of the files (<code>ls -l blah</code>). I’ve also set up the file as <strong>setuid</strong> on the server in <code>/tmp/create_files</code>. Try running the following</p>
<pre><code>$ /tmp/create_files /tmp/blah
$ ls -l /tmp/blah
...
$ /tmp/create_files ~/blah
...</code></pre>
<p>What do you think the output for the first <code>...</code> will be – who is the owner of the file? The second? What are the outputs, and why?</p></li>
</ul>
<h4 id="programmatically-downgradingupgrading-capabilities"><span class="header-section-number">15.3.0.2</span> Programmatically Downgrading/Upgrading Capabilities</h4>
<p>The set-bits automatically start a program with the effective user or group id set; however, there are times when we might want to <em>downgrade privilege</em> or change permission dynamically. There are two system calls to change user/group settings of an executing process:</p>
<ul>
<li><code>setuid(uid_t uid)</code> - change the effective user id of a process to uid</li>
<li><code>setgid(gid_t gid)</code> - change the effective group id of a proces to gid</li>
</ul>
<p>The requirements of <code>setuid()</code> (for all users other than root) is that the effective user id can be changed to the <em>real user id of the program</em> or to an <em>effective user id as described in the set-bits</em>. The root user, however, can <em>downgrade to any user id</em> and upgrade back to the root user. For <code>setgid()</code> the user can chance the group id to any group the user belongs to or as allowed by the set-group-id bit.</p>
<p>Now we can look at a program that downgrades and upgrades a program dynamically:</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb358-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb358-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb358-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb358-4" title="4"></a>
<a class="sourceLine" id="cb358-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb358-6" title="6">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb358-7" title="7">{</a>
<a class="sourceLine" id="cb358-8" title="8">    uid_t uid, euid;</a>
<a class="sourceLine" id="cb358-9" title="9">    gid_t gid, egid;</a>
<a class="sourceLine" id="cb358-10" title="10">    uid_t saved_euid;</a>
<a class="sourceLine" id="cb358-11" title="11"></a>
<a class="sourceLine" id="cb358-12" title="12">    uid = getuid();</a>
<a class="sourceLine" id="cb358-13" title="13">    gid = getgid();</a>
<a class="sourceLine" id="cb358-14" title="14">    printf(<span class="st">&quot; uid=%d  gid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>,  uid,  gid);</a>
<a class="sourceLine" id="cb358-15" title="15"></a>
<a class="sourceLine" id="cb358-16" title="16">    euid = geteuid();</a>
<a class="sourceLine" id="cb358-17" title="17">    egid = getegid();</a>
<a class="sourceLine" id="cb358-18" title="18">    printf(<span class="st">&quot;euid=%d egid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, euid, egid);</a>
<a class="sourceLine" id="cb358-19" title="19"></a>
<a class="sourceLine" id="cb358-20" title="20">    saved_euid=euid;</a>
<a class="sourceLine" id="cb358-21" title="21">    setuid(uid);</a>
<a class="sourceLine" id="cb358-22" title="22">    printf(<span class="st">&quot;---- setuid(%d) ----</span><span class="sc">\n</span><span class="st">&quot;</span>,uid);</a>
<a class="sourceLine" id="cb358-23" title="23"></a>
<a class="sourceLine" id="cb358-24" title="24">    uid = getuid();</a>
<a class="sourceLine" id="cb358-25" title="25">    gid = getgid();</a>
<a class="sourceLine" id="cb358-26" title="26">    printf(<span class="st">&quot; uid=%d  gid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>,  uid,  gid);</a>
<a class="sourceLine" id="cb358-27" title="27"></a>
<a class="sourceLine" id="cb358-28" title="28">    euid = geteuid();</a>
<a class="sourceLine" id="cb358-29" title="29">    egid = getegid();</a>
<a class="sourceLine" id="cb358-30" title="30">    printf(<span class="st">&quot;euid=%d egid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, euid, egid);</a>
<a class="sourceLine" id="cb358-31" title="31"></a>
<a class="sourceLine" id="cb358-32" title="32">    setuid(saved_euid);</a>
<a class="sourceLine" id="cb358-33" title="33">    printf(<span class="st">&quot;---- setuid(%d) ----</span><span class="sc">\n</span><span class="st">&quot;</span>,saved_euid);</a>
<a class="sourceLine" id="cb358-34" title="34">    uid = getuid();</a>
<a class="sourceLine" id="cb358-35" title="35">    gid = getgid();</a>
<a class="sourceLine" id="cb358-36" title="36">    printf(<span class="st">&quot; uid=%d  gid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>,  uid,  gid);</a>
<a class="sourceLine" id="cb358-37" title="37"></a>
<a class="sourceLine" id="cb358-38" title="38">    euid = geteuid();</a>
<a class="sourceLine" id="cb358-39" title="39">    egid = getegid();</a>
<a class="sourceLine" id="cb358-40" title="40">    printf(<span class="st">&quot;euid=%d egid=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, euid, egid);</a>
<a class="sourceLine" id="cb358-41" title="41"></a>
<a class="sourceLine" id="cb358-42" title="42">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb358-43" title="43">}</a></code></pre></div>
<p><strong>Question:</strong></p>
<ul>
<li>What do think will happen if you have a peer run it on the server after you set the <code>set-uid</code> bit?</li>
</ul>
<h2 id="applications-of-identify-and-permission-management"><span class="header-section-number">15.4</span> Applications of Identify and Permission Management</h2>
<h3 id="logging-events-selectively-increasing-access-rights"><span class="header-section-number">15.4.1</span> Logging Events: Selectively Increasing Access Rights</h3>
<p>We previously covered the general desire to have a log in the system of the events for different activities. For example, logging when each user logs in, when clients make web requests of an http server, etc…</p>
<p>We might support two high-level operations:</p>
<ol type="1">
<li>adding a logging event, and</li>
<li>reading the log.</li>
</ol>
<p>If we don’t care to censor the log, we can support the second very easily by, for example, making the log file’s group the <code>log</code> group, and giving read (<code>4</code>) permissions to the log for anyone in that group. Now any user in the <code>log</code>group can read the log.</p>
<p>However, to support adding logging events to the log, we might use the set-uid-bit to ensure that a <code>log</code> program runs with the effictive user-id of the logger user. Thus, it will be able to append to the log in a straightforward manner.</p>
<h3 id="logging-in-carefully-decreasing-access-rights"><span class="header-section-number">15.4.2</span> Logging In: Carefully Decreasing Access Rights</h3>
<p>One example of how you might want to use the identity management APIs is when logging in. The process of logging in requires that the <code>login</code> program access sensitive files that include (encrypted) user passwords (<code>/etc/shadow</code>). Understandably, users don’t generally have access to these files. Thus, the act of logging in requires programs running as <code>root</code> to read in username and password. Only if they match the proper values for a user, will the login logic then change uid/gid to the corresponding user and group id, and execute a shell for the user (as the user). See the figure for more details.</p>
<figure>
<img src="figures/login.svg" alt="The login procedure on a system. On a system that uses a nameserver like systemd, it will ensure that terminals are available (either attached to the keyboard/monitor, or remote) by executing the getty (link), or “get tty” program (or ssh for remote, or gdm for graphical) which makes available a terminal for a user to interact with. getty executes the login (link) program that reads the username and password from the user. If it is unable to find a match, it exits, letting systemd start again. If the username and password match what is in the /etc/passwd and /etc/shadow (password) files, it will change the user and group ids to those for the user in the /etc/passwd file, change to the home directory specified in that same file, and exec the corresponding shell." /><figcaption>The login procedure on a system. On a system that uses a nameserver like <code>systemd</code>, it will ensure that terminals are available (either attached to the keyboard/monitor, or remote) by executing the <a href="https://github.com/mirror/busybox/blob/master/loginutils/getty.c"><code>getty</code> (link)</a>, or “get tty” program (or <code>ssh</code> for remote, or <code>gdm</code> for graphical) which makes available a terminal for a user to interact with. <code>getty</code> executes the <a href="https://github.com/mirror/busybox/blob/master/loginutils/login.c"><code>login</code> (link)</a> program that reads the username and password from the user. If it is unable to find a match, it exits, letting <code>systemd</code> start again. If the username and password match what is in the <code>/etc/passwd</code> and <code>/etc/shadow</code> (password) files, it will change the user and group ids to those for the user in the <code>/etc/passwd</code> file, change to the home directory specified in that same file, and <code>exec</code> the corresponding shell.</figcaption>
</figure>
<h3 id="sudo-and-su-increasing-access-rights"><span class="header-section-number">15.4.3</span> <code>sudo</code> and <code>su</code>: Increasing Access Rights</h3>
<p>There are many times in systems that we want to <em>increase</em> the privileges of a human. For example, for security, it is often <em>not possible</em> to login as <em>root</em>. But it is certainly true that sometimes humans need to be able to run commands as root. For example, updating some software, installing new software, creating new users, and many other operations, all require <em>root</em>.</p>
<p>To control who is able to execute commands as <em>root</em>, the <code>sudo</code> and <code>su</code> programs enable restricted access to root privileges. Specifically, <code>sudo</code> and <code>su</code> will execute a command as a <em>specified user</em> or <em>switch to a specified user</em>. By default, these commands execute as the root user, and you need to know the root password or have sudo access to use them.</p>
<p>We can see this as the case if I were to run the <code>get_euidegid</code> program using <code>sudo</code>. First notice that it is no longer set-group or set-user:</p>
<pre><code>$ sudo ./get_euidegid
[sudo] password for gparmer:
 uid=0  gid=0
euid=0 egid=0</code></pre>
<p>After sudo authenticated me, the program’s effective and real user identification becomes 0 which is the uid/gid for the root user.</p>
<h4 id="sudoers"><span class="header-section-number">15.4.3.1</span> sudoers</h4>
<p>Who has permission to run <code>sudo</code> commands? This is important because on many modern unix systems, like ubuntu, there is no default root password.</p>
<p><strong>Question:</strong></p>
<ul>
<li>Why don’t we just have a <code>root</code> account with a password instead of having <code>sudo</code> and <code>su</code>?</li>
</ul>
<p>Instead certain users are deemed to be sudoers or privileged users. These are set in a special configuraiton file called the <code>/etc/sudoers</code>.</p>
<pre><code>aviv@saddleback: lec-23-demo $ cat /etc/sudoers
cat: /etc/sudoers: Permission denied
aviv@saddleback: lec-23-demo $ sudo cat /etc/sudoers
#
# This file MUST be edited with the &#39;visudo&#39; command as root.
#
# Please consider adding local content in /etc/sudoers.d/ instead of
# directly modifying this file.
#
# See the man page for details on how to write a sudoers file.
#
Defaults    env_reset
Defaults    mail_badpass
Defaults    secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;

# Host alias specification

# User alias specification

# Cmnd alias specification

# User privilege specification
root    ALL=(ALL:ALL) ALL

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL

# See sudoers(5) for more information on &quot;#include&quot; directives:

#includedir /etc/sudoers.d</code></pre>
<p>Notice that only root has access to read this file, and since I am a <code>sudoer</code> on the system I can get access to it. If you look carefully, you can perform a basic parse of the settings. The root user has full <code>sudo</code> permissions, and other sudoer’s are determine based on group membership. Users in the <code>sudo</code> or <code>admin</code> group may run commands as <code>root</code>, and I am a member of the <code>sudo</code> group:</p>
<pre><code>$ id
uid=1000(gparmer) gid=1000(gparmer) groups=1000(gparmer),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare)</code></pre>
<p><strong>Question:</strong></p>
<ul>
<li>How do you think that <code>sudo</code> is implemented? What mechanisms from this week’s lecture is it using to provide the requested functionality?</li>
</ul>
<h4 id="assignment-submission"><span class="header-section-number">15.4.3.2</span> Assignment Submission</h4>
<p>What if we implemented an assignment submission program that copied a student’s directory into the instructor’s home directory? For example, if you wanted to submit the directory of code at <code>my_hw/</code> for homework <code>HW1</code>,</p>
<pre><code>$ ./3410_submit HW1 my_hw</code></pre>
<p>This program, run by you, has your user and group permissions, but it is able to take your submission and copy/save those submissions to my home directory, with my permissions at a location where you do not have access to write. How is that possible?</p>
<p>Naively, we’d have a problem:</p>
<ul>
<li>The submission program is written and provided by the instructor.</li>
<li>The students would be executing the program, thus it would execute with their identity.</li>
<li>We don’t want the submitted data to be visible to <em>any</em> students.</li>
<li><em>However</em>, if the students run the submission program, it will run as their uid/gid, and 1. it won’t have access to the instructor’s home directory, and 2. any files it creates (during the copy) will belong to the user.</li>
</ul>
<p>Yikes.</p>
<p><strong>Question:</strong></p>
<ul>
<li>How could we go about implementing a homework submission program?</li>
</ul>
<h1 id="security-attacks-on-system-programs"><span class="header-section-number">16</span> Security: Attacks on System Programs</h1>
<blockquote>
<p><strong>This material adapted from Prof. Aviv’s <a href="https://classes.adamaviv.com/ic221/s18/units/07/unit.html#org67f4730">material</a>.</strong></p>
</blockquote>
<p>It is an unfortunate truth of security that all programs have faults because humans have faults — human’s write programs. As such, we will take some time to understand the kinds of mistakes you, me, and all programmers may make that can lead to security violations.</p>
<p>This is a broad topic area, and we only have a small amount of time to talk about it. We will focus on three classes of attack that are very common for the kinds of programs we’ve been writing in this course.</p>
<ul>
<li><em>Path Lookup Attacks</em>: Where the attacker leverages path lookup to compromise an executable or library</li>
<li><em>Injection Attacks</em>: Where an attacker can inject code, usually in the form of bash, into a program that will get run.</li>
<li><em>Overflow Attacks</em>: Where the attack overflows a buffer to alter program state.</li>
</ul>
<p>In isolation, each of these attacks can just make a program misbehave; however, things get interesting when an attack can lead to <em>privilege escalation</em>. Privilege escalation enables a user to maliciously access resources (e.g. files) normally unavailable to the user, by exploiting a program with heightened privilege (e.g. due to <code>setuid</code> bits, or explicit id upgrades) to perform arbitrary tasks. The ultimate goal of an attacker is to achieve privilege escalation to <code>root</code>, which essentially gives them access to all system resources.</p>
<blockquote>
<p>You might think that the kernel has more privilege than the <code>root</code> user. However, the <code>root</code> user is given access to the <code>/dev/mem</code> pseudo-device that is “all of memory” including all of the kernel’s memory, and <code>root</code> has the ability to insert dynamic libraries (called “kernel modules”) into the kernel to dynamically update kernel code! Being <code>root</code> truly is a super-power!</p>
</blockquote>
<p>Each of these topics are quite nuanced, and the hope is to give you a general overview so you can explore the topic more on your own.</p>
<h2 id="path-attacks"><span class="header-section-number">16.1</span> Path Attacks</h2>
<p>We’ve been using path lookup throughout the class. Perhaps the best example is when we are in the shell and type a command:</p>
<pre><code>$ cat Makefile
BINS=$(patsubst %.c,%,$(wildcard *.c))

all: $(BINS)

%: %.c
        gcc -o $@ $&lt;

clean:
        rm -rf $(BINS)</code></pre>
<p>The command <code>cat</code> is run, but the program that is actually cat’s the file exists in a different place in the file system. We can find that location using the <code>which</code> command:</p>
<pre><code>$ which cat
/bin/cat</code></pre>
<p>So when we type <code>cat</code>, the shell look for the <code>cat</code> binary, finds it in <code>/bin/cat</code>, and executes that. Recall when we discussed environment variables that binaries are found by looking in all of the directories in the <code>PATH</code> enviroment variable.</p>
<pre><code>$ echo $PATH
/home/gparmer/.local/bin/:/home/gparmer/.local/bin:/home/gparmer/.cargo/bin:/home/gparmer/.local/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/gparmer/local/bin:/usr/racket/bin/:/home/gparmer/local/bin:/usr/racket/bin/</code></pre>
<p>Lets look at that by converting the <code>:</code>, which separate the directories, with newlines:</p>
<pre><code>$ echo $PATH | tr : &quot;\n&quot;
/home/gparmer/.local/bin/
/home/gparmer/.local/bin
/home/gparmer/.cargo/bin
/home/gparmer/.local/bin/
/usr/local/sbin
/usr/local/bin
/usr/sbin
/usr/bin
/sbin
/bin
/usr/games
/usr/local/games
/snap/bin
/home/gparmer/local/bin
/usr/racket/bin/
/home/gparmer/local/bin
/usr/racket/bin/</code></pre>
<p>Each of the directories listed is searched, in order, until the command’s program is found.</p>
<p>Environment variables are <em>global variables</em> set across programs that provide information about the current environment. The <code>PATH</code> environment variable is a perfect example of this, and the customizability of the environment variables. If you look at the directories along my path, I have a bin directory Win my home directory so I can load custom binaries. The fact that I can customize the <code>PATH</code> in this way can lead to some interesting security situations.</p>
<h3 id="system"><span class="header-section-number">16.1.1</span> <code>system()</code></h3>
<p>To help this conversation, we need to introduce two library functions that work much like <code>execvp()</code> with a <code>fork()</code>, like we’ve done all along, but more compact. Here’s an abridged description in the manual page:</p>
<pre><code>NAME
       system - execute a shell command

SYNOPSIS
       #include &lt;stdlib.h&gt;

       int system(const char *command);

DESCRIPTION

       system() executes a command specified in command by calling
       /bin/sh -c command, and returns after the command has been
       completed.  During execution of the command, SIGCHLD will be
       blocked, and SIGINT and SIGQUIT will be ignored.</code></pre>
<p>That is, the <code>system()</code> function will run an arbitrary shell command, inheriting all of the file descriptors of the caller of <code>system</code>. Let’s look at a very simple example, a “hello world” that uses two commands.</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb368-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb368-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb368-3" title="3"></a>
<a class="sourceLine" id="cb368-4" title="4"><span class="dt">int</span></a>
<a class="sourceLine" id="cb368-5" title="5">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb368-6" title="6">{</a>
<a class="sourceLine" id="cb368-7" title="7">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb368-8" title="8"><span class="co">     * Execute `cat`. It inherits the stdin/stdout/stderr</span></a>
<a class="sourceLine" id="cb368-9" title="9"><span class="co">     * of the current process.</span></a>
<a class="sourceLine" id="cb368-10" title="10"><span class="co">     */</span></a>
<a class="sourceLine" id="cb368-11" title="11">    system(<span class="st">&quot;cat&quot;</span>);</a>
<a class="sourceLine" id="cb368-12" title="12"></a>
<a class="sourceLine" id="cb368-13" title="13">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb368-14" title="14">}</a></code></pre></div>
<pre><code>$ echo &quot;Hello World&quot; | ./system_cat
Hello World</code></pre>
<p>The <code>system_cat</code> program runs cat with <code>system()</code>, thus it will print whatever it reads from stdin to the screen (recall: <code>cat</code> essentially echos stdin to stdout). It turns out, that this program, despite its simplicity, actually has a relatively bad security flaw. Let’s quickly consider what might happen if we were to <em>change the <code>PATH</code> value</em> to include our local directory:</p>
<pre><code>$ export PATH=.:$PATH
$ echo $PATH
./:/home/gparmer/.local/bin/:/home/gparmer/.local/bin:/home/gparmer/.cargo/bin:/home/gparmer/.local/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/gparmer/local/bin:/usr/racket/bin/:/home/gparmer/local/bin:/usr/racket/bin/
$ echo $PATH | tr : &quot;\n&quot; | head -n 2
./
/home/gparmer/.local/bin</code></pre>
<p>The <code>export</code> builtin command in our shell updates an environment variable. We see that at the start of the <code>PATH</code> variable is now the current directory! <code>system</code> (and <code>execvp</code>) will look for the program in the <em>current directory</em> before the others. So now the local directory is on the path, thus if I were to create a program named cat, then that cat would run instead of the one you would expect. For example, here is such a program (in <code>fake_cat.c</code>):</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb371-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb371-2" title="2"></a>
<a class="sourceLine" id="cb371-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb371-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb371-5" title="5">{</a>
<a class="sourceLine" id="cb371-6" title="6">    system(<span class="st">&quot;echo &#39;Goodbye World&#39;&quot;</span>);</a>
<a class="sourceLine" id="cb371-7" title="7"></a>
<a class="sourceLine" id="cb371-8" title="8">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb371-9" title="9">}</a></code></pre></div>
<p>This is our <em>imposter</em> program! In this case it is innocuous, but you can imagine it being more nefarious. To do this, we’ll make a <em>new</em> <code>cat</code> command in the current directory.</p>
<pre><code>$ echo &quot;Hello World&quot; | ./system_cat
$ cp fake_cat cat
$ echo &quot;Hello World&quot; | ./system_cat
Goodbye World</code></pre>
<p>This is not just a problem with the <code>system()</code> command, but also <code>execvp()</code>, which will also look up commands along the path.</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb373-1" title="1"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb373-2" title="2"></a>
<a class="sourceLine" id="cb373-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb373-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb373-5" title="5">{</a>
<a class="sourceLine" id="cb373-6" title="6">    <span class="dt">char</span> * args[] = { <span class="st">&quot;cat&quot;</span>, NULL };</a>
<a class="sourceLine" id="cb373-7" title="7"></a>
<a class="sourceLine" id="cb373-8" title="8">    execvp(args[<span class="dv">0</span>], args);</a>
<a class="sourceLine" id="cb373-9" title="9"></a>
<a class="sourceLine" id="cb373-10" title="10">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb373-11" title="11">}</a></code></pre></div>
<pre><code>$ rm ./cat
$ echo &quot;Hello World&quot; | ./execvp_cat
Hello World
$ cp fake_cat cat
$ echo &quot;Hello World&quot; | ./execvp_cat
Goodbye World</code></pre>
<p><strong>Question:</strong></p>
<ul>
<li>Explain what has happened here to your teammates.</li>
<li>How do you think we can prevent the intended execution of our program from being taken over so easily?</li>
</ul>
<h4 id="fixing-path-attacks"><span class="header-section-number">16.1.1.1</span> Fixing Path Attacks</h4>
<p>How do we fix this? There are two solutions:</p>
<ol type="1">
<li>Always use full paths. Don’t specify a command to run by its name, instead describe exactly which program is to be executed.</li>
<li>Fix the path before executing using <code>setenv()</code></li>
</ol>
<p>You can actually control the current <code>PATH</code> setting during execution. To do this you can set the enviorment variables using <code>setenv()</code> and <code>getenv()</code></p>
<div class="sourceCode" id="cb375"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb375-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb375-2" title="2"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb375-3" title="3"></a>
<a class="sourceLine" id="cb375-4" title="4"><span class="dt">int</span></a>
<a class="sourceLine" id="cb375-5" title="5">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb375-6" title="6">{</a>
<a class="sourceLine" id="cb375-7" title="7">    <span class="co">/* ensure the enviorment only has the path we want and overwrite */</span></a>
<a class="sourceLine" id="cb375-8" title="8">    setenv(<span class="st">&quot;PATH&quot;</span>,<span class="st">&quot;/bin&quot;</span>,<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb375-9" title="9"></a>
<a class="sourceLine" id="cb375-10" title="10">    <span class="dt">char</span> * args[] = { <span class="st">&quot;cat&quot;</span>, NULL };</a>
<a class="sourceLine" id="cb375-11" title="11">    execvp(args[<span class="dv">0</span>], args);</a>
<a class="sourceLine" id="cb375-12" title="12"></a>
<a class="sourceLine" id="cb375-13" title="13">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb375-14" title="14">}</a></code></pre></div>
<pre><code>$ rm ./cat
$ echo &quot;Hello World&quot; | ./setenv_cat
Hello World
$ cp fake_cat cat
$ echo &quot;Hello World&quot; | ./setenv_cat
Hello World</code></pre>
<p>Success! Because we used a controlled and known <code>PATH</code>, we can avoid the attacker-chosen <code>cat</code> from executing.</p>
<h3 id="path-attacks-with-set-user-id-bits-for-privilege-escalation"><span class="header-section-number">16.1.2</span> Path Attacks with Set-user-id Bits for Privilege Escalation</h3>
<p>The previous examples were <em>bad</em> as we made the program execute different than the programmer intended. But we didn’t necessarily see the risk of <em>privilege escalation</em> yet. So let’s see what happens when we introduce <code>set-uid</code> to the mix. This time, I’ve set the program system_cat to be set-user-id in a place that others can run it:</p>
<pre><code>$ chmod 4775 system_cat
$ ls -l system_cat
-rwsrwxr-x 1 gparmer gparmer 16704 Apr  4 13:01 system_cat</code></pre>
<p>Now lets imagine there is another user on the system <code>hacker-mchackyface</code>, and as that user we update the <code>PATH</code>…</p>
<pre><code>$ export PATH=.:$PATH
</code></pre>
<p>…and do something this time that is not so innocuous. Lets run a shell after <em>changing our real user id to that of <code>gparmer</code></em>. Yikes.</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb379-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb379-2" title="2"></a>
<a class="sourceLine" id="cb379-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb379-4" title="4">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb379-5" title="5">{</a>
<a class="sourceLine" id="cb379-6" title="6">    <span class="dt">char</span> * args[]={<span class="st">&quot;/bin/sh&quot;</span>,NULL};</a>
<a class="sourceLine" id="cb379-7" title="7"></a>
<a class="sourceLine" id="cb379-8" title="8">    <span class="co">/* set our real uid to our effective uid */</span></a>
<a class="sourceLine" id="cb379-9" title="9">    setreuid(geteuid(),geteuid());</a>
<a class="sourceLine" id="cb379-10" title="10">    execvp(args[<span class="dv">0</span>],args);</a>
<a class="sourceLine" id="cb379-11" title="11"></a>
<a class="sourceLine" id="cb379-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb379-13" title="13">}</a></code></pre></div>
<p>This time when we run the system_cat program, it will run bash as the set-user-id user. Now we’ve just escalated privilege.</p>
<pre><code>$ whoami
hacker-mchackyface
$ ./system_cat
$ whoami  &lt;---- new shell!
gparmer
$</code></pre>
<p>Uh oh. Now user <code>hacker-mchackyface</code> has escalated their privilege to that of user <code>gparmer</code>!</p>
<p><strong>Path Attacks Summary:</strong> Multiple UNIX APIs rely on the <code>PATH</code> environment variable to help us find a program we want to execute. The attacker can modify <code>PATH</code> by adding their attack path, and ensure that a program with the same name as the target is in that path. This will lead to the program executing the attacker’s code! Should this attack exist in a program that is <code>set-uid</code>, the attacker can now execute the program at the higher privilege.</p>
<h3 id="ld_preload-attacks"><span class="header-section-number">16.1.3</span> <code>LD_PRELOAD</code> Attacks?</h3>
<p>We might be clever, and think that we can use <code>LD_PRELOAD</code> to take over some of the library APIs with our own code! Fortunately, this doesn’t work. The dynamic linker (<code>ld.so</code>) will only use the <code>LD_PRELOAD</code> environment variable if the real user id is the same as the effective user id! A simple solution to a threatening problem.</p>
<h2 id="injection-attacks"><span class="header-section-number">16.2</span> Injection Attacks</h2>
<p>Now, lets consider a situation where you use <code>system()</code> in a safer way. You call all programs with absolute path, or update and control <code>PATH</code> before using it. Unfortunately, <em>even that is not enough</em>. You must also consider <em>injection attacks</em> which is when the attacker can inject code that will run. In our case, the injected code will be bash.</p>
<p>Consider this program which prompts the user for a file to cat out.</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb381-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb381-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb381-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb381-4" title="4"></a>
<a class="sourceLine" id="cb381-5" title="5"></a>
<a class="sourceLine" id="cb381-6" title="6"><span class="dt">int</span></a>
<a class="sourceLine" id="cb381-7" title="7">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb381-8" title="8">{</a>
<a class="sourceLine" id="cb381-9" title="9">    <span class="dt">char</span> cmd[<span class="dv">1024</span>] = <span class="st">&quot;/bin/cat ./&quot;</span>; <span class="co">/* will append to this string */</span></a>
<a class="sourceLine" id="cb381-10" title="10">    <span class="dt">char</span> input[<span class="dv">40</span>];</a>
<a class="sourceLine" id="cb381-11" title="11"></a>
<a class="sourceLine" id="cb381-12" title="12">    printf(<span class="st">&quot;What input do you want to &#39;cat&#39; (choose from below)</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb381-13" title="13">    system(<span class="st">&quot;/bin/ls&quot;</span>); <span class="co">/* show available files */</span></a>
<a class="sourceLine" id="cb381-14" title="14"></a>
<a class="sourceLine" id="cb381-15" title="15">    printf(<span class="st">&quot;input &gt; &quot;</span>);</a>
<a class="sourceLine" id="cb381-16" title="16">    fflush(stdout); <span class="co">/* force stdout to print */</span></a>
<a class="sourceLine" id="cb381-17" title="17"></a>
<a class="sourceLine" id="cb381-18" title="18">    scanf(<span class="st">&quot;%s&quot;</span>,input);<span class="co">/* read input */</span></a>
<a class="sourceLine" id="cb381-19" title="19"></a>
<a class="sourceLine" id="cb381-20" title="20">    strcat(cmd,input); <span class="co">/* create the command */</span></a>
<a class="sourceLine" id="cb381-21" title="21"></a>
<a class="sourceLine" id="cb381-22" title="22">    printf(<span class="st">&quot;Executing: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, cmd);</a>
<a class="sourceLine" id="cb381-23" title="23">    fflush(stdout); <span class="co">/* force stdout to print */</span></a>
<a class="sourceLine" id="cb381-24" title="24"></a>
<a class="sourceLine" id="cb381-25" title="25">    system(cmd);</a>
<a class="sourceLine" id="cb381-26" title="26"></a>
<a class="sourceLine" id="cb381-27" title="27">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb381-28" title="28">}</a></code></pre></div>
<p>If we were to run this program, it hopefully does what you’d expect:</p>
<pre><code>$ ./inject_system
What input do you want to &#39;cat&#39; (choose from below)
01_lecture.md  cat  execvp_cat  execvp_cat.c  fake_cat  fake_cat.c  inject_system  inject_system.c  Makefile  setenv_cat  setenv_cat.c  system_cat  system_cat.c
input &gt; Makefile
Executing: /bin/cat ./Makefile
BINS=$(patsubst %.c,%,$(wildcard *.c))

all: $(BINS)

%: %.c
        gcc -o $@ $&lt;

clean:
        rm -rf $(BINS)</code></pre>
<p>Ok, now consider if we were to provide input that doesn’t fit this model. What if we were to provide <em>shell commands as input</em> instead of simply the file name?</p>
<pre><code>$ ./inject_system
What input do you want to &#39;cat&#39; (choose from below)
01_lecture.md  cat  execvp_cat  execvp_cat.c  fake_cat  fake_cat.c  inject_system  inject_system.c  Makefile  setenv_cat  setenv_cat.c  system_cat  system_cat.c
input &gt; ;echo
Executing: /bin/cat ./;echo
/bin/cat: ./: Is a directory

$</code></pre>
<p>The input we provided was <code>;echo</code> the semi-colon closes off a bash command allowing a new one to start. Specifically, the programmer thought that the command to be executed would <em>only take the shape</em> <code>/bin/cat ./&lt;file&gt;</code> for some user-specified <code>&lt;file&gt;</code>. Instead, we make the command execute <code>/bin/cat ./;echo</code>! Notice that there is an extra new line printed, that was the echo printing. This is pretty innocuous; can we get this program to run something more interesting?</p>
<p>We still have the <code>cat</code> program we wrote that prints “Goodbye World” and the <code>PATH</code> is set up to look in the local directory. Setting that up, we get the following result:</p>
<pre><code>$ ./inject_system
What input do you want to &#39;cat&#39; (choose from below)
01_lecture.md  cat  execvp_cat  execvp_cat.c  fake_cat  fake_cat.c  inject_system  inject_system.c  Makefile  setenv_cat  setenv_cat.c  system_cat  system_cat.c
input &gt; ;cat
Executing: /bin/cat ./;cat
/bin/cat: ./: Is a directory
Goodbye World</code></pre>
<p>At this point, we own this program (<code>pwn</code> in the parlance) – we can essentially get it to execute whatever we want. If the program were <code>set-uid</code>, we could escalate our privilege.</p>
<p><strong>Injection Attacks Summary:</strong> When the user can enter commands that are passed to functions that will execute them, we must be exceedingly careful about <em>sanitizing</em> the input. For shell commands, this often means avoiding <code>;</code> and <code>|</code> in inputs. Interestingly, one of the most common attacks on webpages is <strong>SQL injection</strong>. When user input is used to create SQL commands, an attacker might add <code>;</code> followed by additional queries. For example, we might append <code>; DROP TABLE USERS</code> to destructively harm the database!</p>
<figure>
<img src="figures/sql_injection.png" alt="SQL injection can be weaponized in many different ways." /><figcaption>SQL injection can be weaponized in many different ways.</figcaption>
</figure>
<h2 id="overflow-attacks"><span class="header-section-number">16.3</span> Overflow Attacks</h2>
<p>Two attacks down, moving onto the third. Let’s now assume that the programmer has wised up to the two previous attacks. Now we are using full paths to executables and we are scrubbing the input to remove any potential bash commands prior to execution. The result is the following program:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb385-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb385-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb385-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb385-4" title="4"></a>
<a class="sourceLine" id="cb385-5" title="5"><span class="dt">int</span></a>
<a class="sourceLine" id="cb385-6" title="6">main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb385-7" title="7">{</a>
<a class="sourceLine" id="cb385-8" title="8">    <span class="dt">char</span> cmd[<span class="dv">1024</span>] = <span class="st">&quot;/bin/cat ./&quot;</span>; <span class="co">/* will append to this string */</span></a>
<a class="sourceLine" id="cb385-9" title="9">    <span class="dt">char</span> input[<span class="dv">40</span>];</a>
<a class="sourceLine" id="cb385-10" title="10">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb385-11" title="11"></a>
<a class="sourceLine" id="cb385-12" title="12">    printf(<span class="st">&quot;What input do you want to &#39;cat&#39; (choose from below)</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb385-13" title="13">    system(<span class="st">&quot;/bin/ls&quot;</span>); <span class="co">/* show available files */</span></a>
<a class="sourceLine" id="cb385-14" title="14"></a>
<a class="sourceLine" id="cb385-15" title="15">    printf(<span class="st">&quot;input &gt; &quot;</span>);</a>
<a class="sourceLine" id="cb385-16" title="16">    fflush(stdout); <span class="co">/* force stdout to print */</span></a>
<a class="sourceLine" id="cb385-17" title="17"></a>
<a class="sourceLine" id="cb385-18" title="18">    scanf(<span class="st">&quot;%s&quot;</span>,input);<span class="co">/* read input */</span></a>
<a class="sourceLine" id="cb385-19" title="19"></a>
<a class="sourceLine" id="cb385-20" title="20">    <span class="co">/* clean input before passing to /bin/cat */</span></a>
<a class="sourceLine" id="cb385-21" title="21">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">40</span>; i++) {</a>
<a class="sourceLine" id="cb385-22" title="22">        <span class="cf">if</span> (input[i] == <span class="ch">&#39;;&#39;</span> || input[i] == <span class="ch">&#39;|&#39;</span> || input[i] == <span class="ch">&#39;$&#39;</span> || input[i] == <span class="ch">&#39;&amp;&#39;</span>) {</a>
<a class="sourceLine" id="cb385-23" title="23">            input[i] = &#39;\<span class="dv">0</span><span class="er">&#39;</span>; <span class="co">/* change all ;,|,$,&amp; to a NULL */</span></a>
<a class="sourceLine" id="cb385-24" title="24">        }</a>
<a class="sourceLine" id="cb385-25" title="25">    }</a>
<a class="sourceLine" id="cb385-26" title="26"></a>
<a class="sourceLine" id="cb385-27" title="27">    <span class="co">/* concatenate the two strings */</span></a>
<a class="sourceLine" id="cb385-28" title="28">    strcat(cmd,input);</a>
<a class="sourceLine" id="cb385-29" title="29">    printf(<span class="st">&quot;Executing: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, cmd);</a>
<a class="sourceLine" id="cb385-30" title="30">    fflush(stdout);</a>
<a class="sourceLine" id="cb385-31" title="31"></a>
<a class="sourceLine" id="cb385-32" title="32">    system(cmd);</a>
<a class="sourceLine" id="cb385-33" title="33"></a>
<a class="sourceLine" id="cb385-34" title="34">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb385-35" title="35">}</a></code></pre></div>
<pre><code>$ ./overflow_system
What input do you want to &#39;cat&#39; (choose from below)
cat    execvp_cat    inject_system    inject_system.c~  Makefile  overflow_system    overflow_system.c~  run_foo.c  setenv_cat    setenv_cat.c~  system_cat    #system-ex.c#
cat.c  execvp_cat.c  inject_system.c  input.txt     mal-lib   overflow_system.c  run_foo         run_foo.o  setenv_cat.c  shared-lib     system_cat.c
input &gt; ;cat
Executing: /bin/cat ./
/bin/cat: ./: Is a directory</code></pre>
<p>This time, no dice, but the jig is not up yet. There is an <em>overflow attack</em>.</p>
<p><strong>Question:</strong></p>
<ul>
<li>Inspect the program. What happens when we increase the size of the string input into the program?</li>
<li>At any point does the program start to do “bad things”?</li>
</ul>
<p>To increase the input side programatically, we’ll use a small trick to print a bunch of <code>A</code>s:</p>
<pre><code>$ python -c &quot;print &#39;A&#39;*10&quot;
AAAAAAAAAA
$ python -c &quot;print &#39;A&#39;*30&quot;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
$ python -c &quot;print &#39;A&#39;*50&quot;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code></pre>
<p>This produces strings of varying lengths <code>10</code>, <code>30</code>, and <code>50</code>. Those strings can be sent to the target program using a pipe. And we can see the result:</p>
<pre><code>$ python -c &quot;print &#39;A&#39;*10&quot; | ./inject_system
What input do you want to &#39;cat&#39; (choose from below)
01_lecture.md  cat  execvp_cat  execvp_cat.c  fake_cat  fake_cat.c  inject_system  inject_system.c  Makefile  overflow_system.c  setenv_cat  setenv_cat.c  system_cat  system_cat.c
input &gt; Executing: /bin/cat ./AAAAAAAAAA
/bin/cat: ./AAAAAAAAAA: No such file or directory
$ python -c &quot;print &#39;A&#39;*30&quot; | ./inject_system
What input do you want to &#39;cat&#39; (choose from below)
01_lecture.md  cat  execvp_cat  execvp_cat.c  fake_cat  fake_cat.c  inject_system  inject_system.c  Makefile  overflow_system.c  setenv_cat  setenv_cat.c  system_cat  system_cat.c
input &gt; Executing: /bin/cat ./AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
/bin/cat: ./AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA: No such file or directory
$ python -c &quot;print &#39;A&#39;*50&quot; | ./inject_system
What input do you want to &#39;cat&#39; (choose from below)
01_lecture.md  cat  execvp_cat  execvp_cat.c  fake_cat  fake_cat.c  inject_system  inject_system.c  Makefile  overflow_system.c  setenv_cat  setenv_cat.c  system_cat  system_cat.c
input &gt; Executing: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
sh: 1: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA: not found</code></pre>
<p>Something changes at when the input string is <code>50</code> bytes long. We overflow the buffer for the input.</p>
<p><strong>Question:</strong></p>
<ul>
<li>Inspect the code, or run the program above, and deduce what values of the string length cause the first failure to execute <code>/bin/cat</code>.</li>
</ul>
<p>Recall that the input buffer is only <code>40</code> bytes and size, and it is placed adjacent to the cmd buffer:</p>
<pre><code>char cmd[1024] = &quot;/bin/cat ./&quot;; /* will append to this string */
char input[40];</code></pre>
<p>When the <code>input</code> buffer overflows, we begin to write <code>A</code>s to <code>cmd</code> which replaces <code>/bin/cat</code> with whatever string is written at that location! Yikes. Finally, we concatenate <code>cmd</code> with input, resulting in a long string of <code>A</code>s for the command being executed by <code>system()</code>.</p>
<p>How do we leverage this error to pwn this program? The program is trying to execute a command that is <code>AAA...</code> and we can control the <code>PATH</code>. Lets get dangerous. Let’s create such a program named <code>AAA...</code>, so that it is executed when we overflow!</p>
<pre><code>$ cp cat AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
$ ./AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Goodbye World</code></pre>
<p>Now when we execute the overflow, we get our desired “Goodbye World” result:</p>
<pre><code>python -c &quot;print &#39;A&#39;*50&quot; | ./inject_system
What input do you want to &#39;cat&#39; (choose from below)
01_lecture.md                                          cat           fake_cat       inject_system.c    setenv_cat    system_cat.c
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA     execvp_cat    fake_cat.c     Makefile           setenv_cat.c
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  execvp_cat.c  inject_system  overflow_system.c  system_cat
input &gt; Executing: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Goodbye World</code></pre>
<p>Uh-oh: we’re executing attacker-controlled code again!</p>
<p><strong>Question:</strong></p>
<ul>
<li>How would you fix this bug?</li>
<li>How should we generally fix overflow bugs?</li>
</ul>
<p>The most direct way is to always “bound check” accesses to strings, just like Java and Python do. For example, always use library functions like <code>strncp()</code> or <code>strncat()</code> that we can use to prevent <code>input</code> from overflowing, but that is even sometimes not sufficient. This can all get quite complex. This is an introduction to this issue, and not the final say.</p>
<h1 id="the-android-unix-personality"><span class="header-section-number">17</span> The Android UNIX Personality</h1>
<p>Find the <a href="./slides/android_slides.html">slides</a>.</p>
<h1 id="unix-containers"><span class="header-section-number">18</span> UNIX Containers</h1>
<p>Find the <a href="./slides/container_slides.html">slides</a>.</p>
<h1 id="appendix-c-programming-conventions"><span class="header-section-number">19</span> Appendix: C Programming Conventions</h1>
<p>C gives you quite a bit of freedom in how you write your code. Conventions are <em>necessary</em> in C because they bring order to the unrestricted freedom that allows code that is too complicated to debug, too clever to understand, and completely unmaintainable. Conventions are a set of rules that we follow that inherently <em>limit</em> the way in which we write code. The intention is to put <a href="https://en.wikipedia.org/wiki/Guard_rail">guard rails</a> onto our development process and to only deviate from the conventions in exceptional cases. An important aspect of this is that once you understand the conventions, it is <em>drastically easier to read the code</em> because you only have to consider how convention-based code is written. This means that there is a significant importance to uniformly applying conventions. Because of this, it is less important if one likes the conventions, than it is to adhere to them for uniformity.</p>
<p>Put another way, it is easy for <em>any</em> programmer to code themself into a corner where the program is more complex than our brains can handle. Being an experienced programmer is <em>much less</em> about being able to handle more complexity, and much more about understanding that you need to spend significant development time <em>simplifying</em> your code. Conventions are a set of codified simplifications, in some sense. They provide your a set of rules (that you don’t need to think about, you just do) to simplify the structure of your code.</p>
<p>OK, onward to conventions!</p>
<h2 id="naming-conventions"><span class="header-section-number">19.1</span> Naming Conventions</h2>
<p>There are many potential naming conventions, for example, <a href="https://en.wikipedia.org/wiki/Camel_case">camel case</a>, <a href="https://en.wikipedia.org/wiki/Snake_case">snake case</a>, and <a href="https://en.wikipedia.org/wiki/Hungarian_notation">hungarian notiation</a>. Some are antiquated (hungarian), but most are a matter of taste and convention.</p>
<blockquote>
<p><strong>Convention.</strong> Most C uses lower-case <code>snake_case</code> for variables, types, and functions, capital <code>SNAKE_CASE</code> for constants and macros.</p>
</blockquote>
<p>Stick to this convention. A new convention will likely not feel “right” because it is new and different. Remember that they are subjective, but the aim to apply them uniformly.</p>
<p>For names that are visible across <code>.c</code> files (i.e. functions in a <code>.h</code> file), use names that are the shortest they can be to convey the functionality. Within functions, names can be short, and here there are a few conventions as well:</p>
<ul>
<li><code>ret</code> is a variable that stores a return value (i.e. a value that will later be used as in <code>return ret;</code>).</li>
<li><code>i</code>, <code>j</code>, <code>k</code>, <code>l</code> are iterator variables.</li>
</ul>
<h2 id="namespacing"><span class="header-section-number">19.2</span> Namespacing</h2>
<p>When you create a global variable, type, or function, you’re creating a symbol that can be accessed for any <code>.c</code> file. This has a significant downside: if you choose a name that is already used in a library, or that is common, you might get a linker error along the lines of:</p>
<pre><code>multiple definition of `foo&#39;; /tmp/ccrvA8in.o:a.c:(.text+0x0): first defined here
...
collect2: error: ld returned 1 exit status</code></pre>
<p>This means that the naming choices each application and library makes can easily cause such a problem.</p>
<blockquote>
<p><strong>Convention.</strong> Thus, the convention is that you should “namespace” your functions and variables by pre-pending them with a functionality-specific prefix. For example, a key-value store might have all of its types, variables, and functions prefixed with <code>kv_</code>, for example, <code>kv_get</code>.</p>
</blockquote>
<h2 id="headers-and-visibility"><span class="header-section-number">19.3</span> Headers and Visibility</h2>
<p>C does not have classes and the rules therein to support per-class/object encapsulation. Instead, C views each <code>.c</code> file as a unit of visibility. Functions and global variables (known as “symbols”) can be hooked up with references to them in other objects by the linker. However, it is possible to write code in a <code>.c</code> file that is <em>not visible</em> outside of that file. In contrast to the linking error above emphasizing good naming, if a symbol is marked as <code>static</code>, no other <code>.c</code> file will be able to reference that symbol.</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb393-1" title="1"><span class="dt">static</span> <span class="dt">int</span> global_var;</a>
<a class="sourceLine" id="cb393-2" title="2"><span class="dt">static</span> <span class="dt">void</span> foo(<span class="dt">void</span>) { }</a></code></pre></div>
<p>No other <code>.c</code> file can define code that will be able to access <code>global_var</code> nor call <code>foo</code>. You can see the list of all symbols within a <code>.c</code> file that are accessible outside of it by compiling into a <code>.o</code> file (using <code>gcc -c ...</code>), and <code>nm -g --defined-only x.o | awk '{print $3}'</code> (replace <code>x</code> with your object file name).</p>
<blockquote>
<p><strong>Convention.</strong> All functions and variables that are not part of the <em>public interface</em> with which to interact with the <code>.c</code> file should be <code>static</code> so that they cannot be used from other objects.</p>
</blockquote>
<p>This convention enables <code>.c</code> files to support encapsulation. It is also important to support encapsulation at compile time (which is before linking). We want our compiler to tell us if we try and access a symbol we shouldn’t be able to access. Header files are <code>#include</code>d into <code>.c</code> files, thus providing access to the symbol names and types, so that the <code>.c</code> file can compile while referencing symbols in another.</p>
<blockquote>
<p><strong>Convention.</strong> The focus of header files should be to provide the types for the data and functions of a public interface, and nothing more.</p>
</blockquote>
<p>When we include a file, it just copies the file at the point of the <code>#include</code>. Thus, if the same header is included separately into two <code>.c</code> files, then it effectively replicates the header’s contents into the two <code>.o</code> files. This can cause problems if the two <code>.o</code> files are linked together. An example:</p>
<p><code>a.c</code>:</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb394-1" title="1"><span class="pp">#include </span><span class="im">&quot;c.h&quot;</span></a></code></pre></div>
<p><code>b.c</code>:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb395-1" title="1"><span class="pp">#include </span><span class="im">&quot;c.h&quot;</span></a>
<a class="sourceLine" id="cb395-2" title="2"></a>
<a class="sourceLine" id="cb395-3" title="3"><span class="dt">int</span> main(<span class="dt">void</span>) { <span class="cf">return</span> <span class="dv">0</span>; }</a></code></pre></div>
<p><code>c.h</code>:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb396-1" title="1"><span class="dt">int</span> foo(<span class="dt">void</span>) { <span class="cf">return</span> -<span class="dv">1</span>; }</a></code></pre></div>
<p>After compiling these files, we get</p>
<pre><code>$ gcc -c a.c -o a.o
$ gcc -c b.c -o b.o
$ gcc a.o b.o -o test
/usr/bin/ld: b.o: in function `foo&#39;:
b.c:(.text+0x0): multiple definition of `foo&#39;; a.o:a.c:(.text+0x0): first defined here
collect2: error: ld returned 1 exit status</code></pre>
<p>Because <code>foo</code> was replicated into each <code>.o</code> file, when they were linked together the linker said “I see two <code>foo</code>s!”. Note that we would have avoided this if we put only the function declaration (i.e. the type information) in the <code>.h</code> file (e.g. <code>int foo(void);</code>).</p>
<blockquote>
<p><strong>Convention.</strong> Never put global data in a <code>.h</code> file. Only put type information (e.g. function declarations) in <code>.h</code> files<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a>.</p>
</blockquote>
<h2 id="what-to-include"><span class="header-section-number">19.4</span> What to Include?</h2>
<p>You <em>must</em> include the header files that provide the functionality that you rely on and use. This sounds obvious, but it is <em>very</em> easy to mess this up. A couple of examples:</p>
<p><em>Example 1: Implementing a library.</em> You’re implementing a library, and you have a <code>.h</code> file for it that exposes the types of the library’s functions. You test your library, and it works wonderfully – victory! However, because it is a library, it might be used by other people’s code, and all they are going to do is <code>#include &lt;your_lib.h&gt;</code>, and expect everything to work.</p>
<p>What if the following happened? Your <code>your_lib.h</code> file does this:</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb398-1" title="1"><span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb398-2" title="2"><span class="dt">size_t</span> my_function(<span class="kw">struct</span> my_type *t);</a>
<a class="sourceLine" id="cb398-3" title="3"><span class="co">/* ... */</span></a></code></pre></div>
<p>In your test file, you do this:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb399-1" title="1"><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span></a>
<a class="sourceLine" id="cb399-2" title="2"><span class="pp">#include </span><span class="im">&lt;your_lib.h&gt;</span></a>
<a class="sourceLine" id="cb399-3" title="3"></a>
<a class="sourceLine" id="cb399-4" title="4"><span class="co">/* ... */</span></a></code></pre></div>
<p>Your tests of your library work wonderfully! But if the user of your library simply does:</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb400-1" title="1"><span class="pp">#include </span><span class="im">&lt;your_lib.h&gt;</span></a>
<a class="sourceLine" id="cb400-2" title="2"><span class="co">/* ... */</span></a></code></pre></div>
<p>The user will get a compiler error that says it doesn’t understand what <code>size_t</code> is! The core problem is that your library’s header file didn’t include all of the headers it relies on! Instead, it should updated to look like so:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb401-1" title="1"><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span><span class="pp"> </span><span class="co">/* we require `size_t` */</span></a>
<a class="sourceLine" id="cb401-2" title="2"><span class="co">/* ... */</span></a>
<a class="sourceLine" id="cb401-3" title="3"><span class="dt">size_t</span> my_function(<span class="kw">struct</span> my_type *t);</a>
<a class="sourceLine" id="cb401-4" title="4"><span class="co">/* ... */</span></a></code></pre></div>
<p>A good way to defensively code to try to minimize the chance that this error happens, you should include your header files <em>before</em> the rest of the header files. The only real solution is to be very careful, and always include what headers are necessary for the functionality you depend on.</p>
<p><em>Example 2: implementing a program or test.</em> A <code>.c</code> file, lets say <code>my_prog.c</code>, includes some header file, <code>head.h</code>. It compiles just fine. But if <code>my_prog.c</code> relies on some header file – lets say <code>dep.h</code> – that is only included itself in the <code>head.h</code> file, then if <code>head.h</code> is updated and removes the include, it will break any program that depends on it! In this case, <code>my_prog.c</code> should explicitly include <code>dep.h</code>: include the headers that are required for your functionality!</p>
<p><em>How do you know which headers to include?</em> If you’re using a system function, the <code>man</code> page for it is explicit about which headers provide the necessary functionality. If you’re implementing a library in the class, we are explicit about what headers are required.</p>
<h2 id="depth-complexity"><span class="header-section-number">19.5</span> Depth = Complexity</h2>
<p>Syntactic nesting, or depth often significantly increase the cognitive complexity in C<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a>. Two examples of this:</p>
<p><strong>Depth through indentation nesting.</strong> Each additional nesting level (each nested set of <code>{}</code>) adds another condition that you must keep in your mind<a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a> when understanding the code. This includes the conditions, or looping conditions associated with the nesting level. This is <em>a lot</em> to keep in your head, and makes developing and reading code quite a bit more difficult.</p>
<p>What can you do to avoid this nesting? <em>First</em>, return early for errors. Instead of the following code…</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb402-1" title="1"><span class="cf">if</span> (a) {</a>
<a class="sourceLine" id="cb402-2" title="2">    <span class="co">/* normal code */</span></a>
<a class="sourceLine" id="cb402-3" title="3">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb402-4" title="4">    <span class="co">/* error code */</span></a>
<a class="sourceLine" id="cb402-5" title="5">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb402-6" title="6">}</a></code></pre></div>
<p>…do the following…</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb403-1" title="1"><span class="cf">if</span> (!a) {</a>
<a class="sourceLine" id="cb403-2" title="2">    <span class="co">/* error code */</span></a>
<a class="sourceLine" id="cb403-3" title="3">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb403-4" title="4">}</a>
<a class="sourceLine" id="cb403-5" title="5"><span class="co">/* normal code */</span></a></code></pre></div>
<p>Though seemingly trivial, it enables you to separate your understanding of error conditions from the complexity of the following code. Try to perform as much error checking as soon as it possibly can be done so that you can switch into “normal case” thinking.</p>
<p><em>Second</em>, if you nest deeper than four levels of brackets, then pull code out into appropriately-named functions. Long functions aren’t necessarily bad, but <em>complex</em> functions are.</p>
<blockquote>
<p><strong>Convention.</strong></p>
<ol type="1">
<li>Separate error handling where possible, and put it as close to the top of the function as possible.</li>
<li>If you nest brackets deeper than 4 levels, pull logic out into separate, appropriately named functions.</li>
</ol>
</blockquote>
<p>I use indentation levels in C of eight visual spaces to make it visually clear when I’m indenting too much.</p>
<p><strong>Depth through field nesting.</strong> It can be quite difficult to follow code that nests access to fields. For example:</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb404-1" title="1">a.b-&gt;c[d].e = f.g-&gt;h;</a></code></pre></div>
<p>Of course, this is fake code, but even if it wasn’t, keeping track of the types of each of the levels of increasing depth of field reference is nearly impossible. This will make writing the code fickle and challenging, and reading the code, needlessly complex.</p>
<p>The main means we have to remove this complexity is to</p>
<ol type="1">
<li><p>Create an set of typed variables</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb405-1" title="1"><span class="kw">struct</span> *b   = &amp;a.b;</a>
<a class="sourceLine" id="cb405-2" title="2"><span class="kw">struct</span> *c[] = b-&gt;c;</a>
<a class="sourceLine" id="cb405-3" title="3"><span class="kw">struct</span> *g   = &amp;f.g;</a>
<a class="sourceLine" id="cb405-4" title="4"></a>
<a class="sourceLine" id="cb405-5" title="5">c[d].e = g-&gt;h;</a></code></pre></div>
It is up to you to decide where it is right to provide an “intermediate” type for a certain depth in the fields, and when to directly dive into a few fields.</li>
<li><p>If any the structs (or sub-structs, or arrays) represents an API layer, then you can call a function that performs the necessary operation on that part of the data-structure. This both provide abstraction over the data access, and documents the types.</p></li>
</ol>
<blockquote>
<p><strong>Convention.</strong> When faced with walking through nested composite data-structures, use intermediate variables to make types explicit, or functions to abstract operations.</p>
</blockquote>
<h2 id="object-orientation-initialization-destruction-and-methods"><span class="header-section-number">19.6</span> Object Orientation: Initialization, Destruction, and Methods</h2>
<p>C is an imperative programming language as it came before Object Orientation (OO) took hold. That said, the OO concept of <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">encapsulation</a> behind an <a href="https://en.wikipedia.org/wiki/Abstract_data_type">abstract data type</a> is a universal requirement of programming in complex environments. Though C doesn’t support this explicitly, conventions can provide much of the same benefit. Such an abstraction requires</p>
<ol type="1">
<li>a <em>datatype</em> that stores the information required for the abstraction (think: a list, a key-value store, etc…),</li>
<li>a set of <em>methods</em> to operate on that datatype, and</li>
<li>means to <em>create and destroy</em> objects of that datatype.</li>
</ol>
<p>If we wanted to provide a key-value datatype, <code>kv</code>, we’d provide these in C by</p>
<ol type="1">
<li>providing a <code>struct kv</code> for the datatype in which the rest of the data is contained,</li>
<li>publicly providing (in <code>kv.h</code>) a set of functions with names all prefixed with <code>kv_</code>, that take the <code>kv</code> to operate on as the first argument (e.g. <code>void *kv_get(struct kv *kv, int key);</code>) – this first argument acts as “<code>this</code>” in Java, and</li>
<li>allocate and deallocate functions, for example, <code>struct kv *kv_alloc(...)</code> and <code>void kv_free(struct kv *kv)</code><a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a>.</li>
</ol>
<p>C can support polymorphism, inheritance, dependency injection and composition as well, but we’ll leave that for a future discussion.</p>
<blockquote>
<p><strong>Convention.</strong></p>
<ol type="1">
<li>Meticulously name your header files, your structure, and the methods to act on the datatype to associate them with each other.</li>
<li>Pass the object to be acted on as the first argument to each of the “methods” to act as the C equivalent of “<code>this</code>”.</li>
<li>Provide allocation and deallocation functions for the datatype.</li>
</ol>
</blockquote>
<p>With this, we encourage the client (user of the API) to think of the datatype as encapsulated.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Description from Wikipedia. https://en.wikipedia.org/wiki/Sizeof<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Definition from Wikipedia. https://en.wikipedia.org/wiki/Union_type<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Which is provided by <code>gcc</code> and can be found in <code>/usr/include/gcc/x86_64-linux-gnu/9/include/stddef.h</code>.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>In <code>/usr/include/limits.h</code>.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>Arrays differ from pointers as 1. the <code>sizeof</code> operator on an array variable gives the total size of the array (including all elements) whereas for pointers, it returns the size of the pointer (i.e. 8 bytes on a 64 bit architecture); 2. <code>&amp;</code> on an array returns the address of the first item in the array whereas for pointers, it returns the address of the pointer; and 3. assignments to pointers end up initializing the pointer to an address, or doing math on the pointer whereas for arrays, initialization will initialize items in the array, and math/assignment after initialization are not allowed.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>Not always an easy feat. See the previous discussion on Common Errors.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>for example, in <code>/usr/include/asm/errno.h</code>.<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>C was also created as part of the original UNIX as a necessary tool to implement the OS!<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>This is a little bit like when an agent transforms from a normal citizen in the Matrix.<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>Yes, yes, yes, I know this is getting redundant. Key-value stores are <em>everywhere</em>!<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p>Hint: make sure to read the <code>man</code> pages for <code>exit</code> (<code>man 1 exit</code>).<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p><code>ps</code> prints out process information, <code>grep</code> filters the output to only lines including the argument (<code>gparmer</code> here), and <code>awk</code> enables us to print out specific columns (column <code>2</code> here). You should start getting familiar with your command-line utilities!<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>“Channel” is a term that is heavily overloaded, but I’ll inherit the general term from the <a href="https://www.gnu.org/software/libc/manual/html_node/Stream_002fDescriptor-Precautions.html">glibc documentation</a>.<a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>We see why the name “file” in file descriptors is not very accurate. Recall that I’m using the traditional “file descriptors” to denote all of our generic descriptors.<a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p>We’ll discuss the kernel later, and dual-mode execution to protect the implementation of these calls in OS.<a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p>A hallmark of <em>bad design</em> is functionality that is not <a href="https://www.youtube.com/watch?v=mKJcqvozfA8&amp;t=2124s"><em>orthogonal</em> with existing functionality</a>. When a feature must be considered in the logic for many other features, we’re adding a significant complexity to the system.<a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p>Please, please do <em>not</em> try this.<a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p>This is useful to redirect shell output to if you don’t care about the output.<a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p>I’ll try and call it a “file descriptor” when we know the descriptor is to a file.<a href="#fnref19" class="footnote-back">↩</a></p></li>
<li id="fn20"><p>This is called a “race condition”. File “locking” helps solve this issue, but we’ll delay discussing locking until the OS class.<a href="#fnref20" class="footnote-back">↩</a></p></li>
<li id="fn21"><p>ELF is a file format for binary programs in the same way that <code>html</code> is the data format for webpages, <code>.c</code> for C files, <a href="https://raw.githubusercontent.com/corkami/pics/master/binary/PNG.png"><code>.png</code></a> for images, and <a href="https://raw.githubusercontent.com/corkami/pics/master/binary/PDF.png"><code>.pdf</code></a> for documents. It just happens to contain all of the information necessary to link and execute a program! It may be surprising, but comparable formats even exist for <a href="https://github.com/corkami/pics/blob/master/binary/CLASS.png">java (<code>.class</code>) files</a> as well.<a href="#fnref21" class="footnote-back">↩</a></p></li>
<li id="fn22"><p>Note: these are hexadecimal values, not base-10 digits.<a href="#fnref22" class="footnote-back">↩</a></p></li>
<li id="fn23"><p>This is increasingly not true as many compilers support <a href="https://en.wikipedia.org/wiki/Interprocedural_optimization#WPO_and_LTO">Link-Time Optimization</a> (LTO). This goes beyond the scope of this class.<a href="#fnref23" class="footnote-back">↩</a></p></li>
<li id="fn24"><p>We can even choose to use a different program interpreter, for example, <code>interp.so</code>, using <code>gcc -Wl,--dynamic-linker,interp.so</code>.<a href="#fnref24" class="footnote-back">↩</a></p></li>
<li id="fn25"><p>This sharing of library memory across processes is why dynamic libraries are also called <em>shared libraries.</em><a href="#fnref25" class="footnote-back">↩</a></p></li>
<li id="fn26"><p>What are “flags”? The notion of “flags” is pretty confusing. Flags are often simply a set of bits (in this case, the bits of the <code>int</code>) where each bit specifies some option. In this case, there’s a bit for <code>RTLD_NOW</code> which says to load all of the symbol dependencies now, and a separate bit for <code>RTLD_LOCAL</code> which says that subsequent libraries should not see this library’s symbols. In short, these are just single bits in the “flags” integer, thus they can be bitwise or-ed together (thus the <code>|</code>) to specify options – they are simply a way to specify a set of options.<a href="#fnref26" class="footnote-back">↩</a></p></li>
<li id="fn27"><p>Note, this is just <span class="math inline">2<sup>16</sup></span>, using shifts to emulate the power operator.<a href="#fnref27" class="footnote-back">↩</a></p></li>
<li id="fn28"><p>There are sometimes optimization-driven motivations to place function definitions in <code>.h</code> files. In such cases, the functions <em>must</em> be marked <code>static</code> to avoid the above problem.<a href="#fnref28" class="footnote-back">↩</a></p></li>
<li id="fn29"><p>…and in most languages that don’t support first class functions/closures.<a href="#fnref29" class="footnote-back">↩</a></p></li>
<li id="fn30"><p>Short term memory only holds 7 <span class="math inline">±</span> 2 items, an each nesting level expands at least one.<a href="#fnref30" class="footnote-back">↩</a></p></li>
<li id="fn31"><p>We also often provide an initialization function that initializes a <code>struct kv</code> instead of allocating a new one (e.g. <code>int kv_init(struct kv *kv)</code>). These are useful since C allows stack and global allocation of the datatype, and we want to provide a means to initialize one of those allocations.<a href="#fnref31" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
